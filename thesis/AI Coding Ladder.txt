AI Coding Ladder
Skip to content
Open sidebar
ChatGPT
5.2
Add people
You said:
AI
Coding
üìÖ December 6, 2025
‚è±Ô∏è 8 min read
‚úçÔ∏è Jeroen Gordijn
The AI Coding Ladder
AI coding is changing fast. A few years ago, we wrote every line by hand. Now, we have AI agents that can build entire features. But not all AI help is the same. I see different "levels" of AI, from a simple chat interface to fully independent workers. These levels aren't official rules, and higher isn't always better. It's a way to think about the way you use AI. During a coding session, you can switch between the different levels, depending on the task at hand.

Level 0: The purist (No AI)
In this level, there is no AI involved. The developer writes every line of code. It's just you, the blinking cursor, and searching Stack Overflow for hours. It may feel old-fashioned, but until very recently, this was the only way to go. Many people still find pride in crafting code by hand.

Control: None. You do everything.
Context: None. The computer knows nothing about what you want.
The Good Part: Total Understanding. You rely on no one. You know exactly how every single line of code works.
The Bad Part: You get stuck on a problem. You spend hours searching for a solution to a small problem. You get tired of typing the same standard code over and over.
Level 1: The Copy-Paster
This is where most of us started. Instead of Googling for answers, you ask a chatbot. You ask for a piece of code, and like magic, it appears on your screen. At first, you are amazed. You even worry about your job! But when you paste the code into your project, it doesn't work. It uses functions that don't exist, or provides incorrect arguments. AI can be very helpful in this level, but it can also be very frustrating.

The AI has read almost every programming book and all of Stack Overflow, so it knows a lot. And if you provide it with some context, it can give a more tailored answer. But it doesn't know your whole codebase.

Control: None. You ask, it answers, you paste.
Context: It knows only what you tell it. Putting some effort in creating nice prompts and provide context about your problem can help get better results.
The Good Part: A better Stack overflow. You can get results more tailored to your problem. It's also great for learning new things.
The Bad Part: Switching Context. You have to switch between your browser and your code constantly. Also, the AI might make up libraries that don't exist, leading to frustration.
Level 2: The Autocompleter
This is basically super-powered text prediction. The AI lives inside your code editor and guesses what you want to type next. Sometimes it feels like it reads your mind and knows exactly what you need. Other times, it writes a whole block of code that looks perfect but is actually just not it. Refactoring that feels like it takes more work than when you have written it yourself. The big win here is that you don't have to leave your editor to copy-paste code from a browser.

Control: None. It reacts to your cursor and suggests the next block of code.
Context: Current File and open tabs. You can provide it with better context of your intention by starting to type a comment, good function name, or variable name.
The Good Part: No need to leave your editor. If steered well it can save you some typing. And simple clear cases generally work pretty good.
The Bad Part: The "Wait, What?" Effect. You accept a suggestion because it looks right, but later find out it's wrong. It might use a variable that doesn't exist, or hallucinates a function (like in level 1).
Level 3: The Inline Editor
In this level, you can talk to your code editor. In level 2, we could only add code, but in this level, we can change, add or remove code. You highlight a piece of code and tell the AI: "Simplify this" or "Add error checks." It's like having a helpful assistant sitting next to you. It's great for cleaning up messy code or understanding how a complex function works. But the AI only changes the selected code, or injects code at the cursor position. If the function name or arguments are changed here, it might break code elsewhere in your project because the AI doesn't see the full picture.

Control: Some. The AI can now change some code, based on a description of what you want.
Context: Selected Code and open tabs. It understands the specific block of code you highlighted and the files around it. The prompt you give directs it what to do.
The Good Part: Fast Cleanup. You can highlight a messy function and say, "Clean this up," and it's done. AI can now change code, not only add code.
The Bad Part: Limited scope. It fixes the function perfectly, but might break the code that uses it, because it doesn't consider the rest of the project. It still hallucinates non-existing functions.
Level 4: The Prompt Coder
Now the AI steps out of the single file and looks at your entire project. It's not just fixing one function; it can add a whole new feature across multiple files. You feel like you have superpowers. You describe what you want, and the AI builds it. But it can be risky. If the AI misunderstands you, it might mess up files all over your project. And if you try to fix it with more prompts, you can get stuck in a loop where nothing seems to work right.

Control: Full. The AI can now change any code in your project.
Context: The Whole Project. It can read all files in your project.
The Good Part: Super Speed. You can make big changes across 20 files in minutes. It sees your whole codebase, so it makes changes which are more in line with the project's code style.
The Bad Part: If the AI misunderstands your command, it writes bad code across many files. Cleaning up a big mess is often harder than doing the work by hand.
Level 5: The Agentic Coder
At this level, the AI gets access to tools (MCPs, skills, sub-agents). You don't only give it your project's code as context, but you can feed it more information, such that it has some knowledge about your organization. It also knows how to use the tools, such that it can compile your code, run tests or even use a browser to see the result of its changes. You can teach it your team's rules, like how to format code or handle security. It can take a vague task like "fix this bug," run tests to find the problem, and solve it. But like a junior developer, it sometimes gets confused and needs your guidance to stop it from trying the same wrong solution over and over.

Control: Full+. Can change all code, but can also reach out and depending on the tools you allowed, the possibilities are endless.
Context: The project + all the tools you gave it.
The Good Part: Level 4, but with checks if the code works. Follows the rules you set and access to more tools. It can investigate Kubernetes logs for instance.
The Bad Part: The Infinite Loop. Without perfect instructions, it can get stuck trying the same wrong fix over and over, wasting time.
Level 6: The Architect
At this stage, you stop being a coder and start being an architect. Instead of directing what needs to change in the code, you write a clear plan (a specification) of what you want. You tell the AI the goal, and it figures out the steps to get there. We lift the whole process to a higher level. By putting a lot of effort into the spec phase, we try to set the AI up for success. This is what I described in My AI Writes Code. Yours Can Too.

Control: Full+. The same control as in level 5, the process changes, not the AI.
Context: The project + the tools + the plan.
The Good Part: Thinking Big Picture. You stop thinking about how to write the code and start thinking about what the code should do. In the spec phase, we create a plan that guides the AI during the build, to get the right result.
The Bad Part: Bad Plan = Bad Code. If your plan is vague, the AI will build the wrong thing. Writing good plans takes time and effort.
More levels?
What will the next level be? I can imagine that AI at some point takes more responsibility. After a vague feature request, it will set out to get clarification. Maybe other levels will pop up, but from this point it is only speculation.

Relevance of the levels
There's no right or wrong level. It depends on the task at hand. I mostly start at level 4/5 to brainstorm with AI about the feature. I want to understand how something currently works in the codebase and figure out the best approach, or clarify the idea. When that is clear I switch to level 6 and specify the feature. During the build phase, I switch to level 5 to make some changes.

Disclaimer: I made these levels up. It makes sense to me.
ChatGPT said:
Here's a
concise synthesis
of
"The AI Coding Ladder"
with the core idea, trade-offs, and how to use it in practice.
The Big Idea (TL;DR)
The article frames AI-assisted coding as a
spectrum of interaction modes
, not a single tool. You move
up and down the ladder
depending on task scope, risk, and clarity‚Äînot because higher levels are inherently better.
The Ladder, Compressed
Level
Role of AI
What Changes
Main Risk
0 ‚Äî Purist
None
Full manual coding
Time & repetition
1 ‚Äî Copy-Paster
Answers questions
Faster lookup
Hallucinated code
2 ‚Äî Autocompleter
Predicts next code
Less typing
Subtle wrongness
3 ‚Äî Inline Editor
Modifies selected code
Rapid cleanup
Local fixes break globals
4 ‚Äî Prompt Coder
Refactors whole project
Massive speed
Project-wide damage
5 ‚Äî Agentic Coder
Uses tools/tests
Self-checking changes
Infinite fix loops
6 ‚Äî Architect
Executes a spec
Design-first workflow
Bad spec ‚Üí bad system
What's Actually New Here
The novelty isn't the tools‚Äîit's the
mental model
:
Control ‚â† Safety
More AI capability increases
blast radius
. Speed goes up; error cost goes up faster.
Context is the real currency
Each level mainly differs by
how much of the world
the AI can see: file ‚Üí project ‚Üí tools ‚Üí intent.
Level switching is a skill
Expert use means:
Brainstorm at
4/5
Lock intent at
6
Execute and verify at
5
Drop back to
3/2
for tight, risky edits
Practical Guidance (Actionable)
Use
Level 2-3
for:
Boilerplate
Refactors with obvious intent
Use
Level 4-5
for:
Feature scaffolding
Cross-cutting changes
after
understanding the code
Use
Level 6
when:
The problem is complex
Failure is expensive
You can invest in a clear spec
Rule of thumb:
If you can't explain the change clearly to a human, don't hand it to Level 4+ AI.
Subtle Insight Worth Keeping
This ladder quietly reframes the developer's job:
Not
"writing code"
‚Üí but
managing degrees of delegation
Not
"prompt engineering"
‚Üí but
scope engineering
Seniority increasingly =
spec quality
, not syntax speed
If you want, I can:
Turn this into a
one-page cheat sheet
Rewrite it as a
team policy / engineering playbook
Map it onto
real tools
(Copilot, Cursor, Claude, agent frameworks)
Or connect it to
software risk models
(blast radius, change isolation)
Just say which direction you want to take it.
ChatGPT can make mistakes. Check important info. See
Cookie Preferences
.

