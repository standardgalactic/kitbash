Galactic Simulation: Entropic Empire Evolution - Grok
Toggle Sidebar
I would like to make this more elaborate like stars 1995: 
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Entropic Empire - Space Tier</title>
<style>
  body { font-family: monospace; background: #111; color: #eee; text-align:center; }
  canvas { border: 1px solid #555; background: #222; display: block; margin: 10px auto; }
  #metrics { width: 90%; margin: 10px auto; }
  button { margin: 5px; padding: 8px 12px; font-size: 16px; }
</style>
</head>
<body>

<h1>Entropic Empire - Space Tier</h1>
<canvas id="spaceCanvas" width="800" height="600"></canvas>
<div id="metrics"></div>
<button onclick="stepWorld()">Next Turn</button>

<script>
// -----------------------------
// Configuration
// -----------------------------
const NUM_STARS = 3;
const PLANETS_PER_STAR = 4;
const AGENTS_PER_PLANET = 10;

// Field params
const ALPHA_CREATE = 0.05;
const ALPHA_RESTORE = 0.08;
const ALPHA_DECAY = 0.001;
const BETA_DAMP = 0.05;
const KAPPA_DIV = 0.03;

// Canvas config
const WIDTH = 800;
const HEIGHT = 600;

// -----------------------------
// Utilities
// -----------------------------
function randomChoice(arr) { return arr[Math.floor(Math.random()*arr.length)]; }
function distance(x1,y1,x2,y2){ return Math.sqrt((x1-x2)**2+(y1-y2)**2); }

// -----------------------------
// Entities
// -----------------------------
class Planet {
  constructor(x,y,name) {
    this.x = x; this.y = y; this.name = name;
    this.phi = 0.8; this.v = 0.0; this.s = 0.1;
    this.agents = [];
  }
}

class Agent {
  constructor(planet) {
    this.planet = planet;
    this.type = randomChoice(['producer','maintainer','corporate','commons']);
    this.currency = 100;
    this.reputation = 0;
  }

  act() {
    const action = randomChoice(['produce','maintain','automate','trade','moveStar']);
    if (action === 'produce') {
      const deltaS = 0.01 * Math.random();
      this.planet.s += deltaS;
      this.planet.phi += ALPHA_CREATE*0.01;
    } else if (action === 'maintain') {
      const delta = ALPHA_RESTORE*0.02;
      this.planet.s = Math.max(0,this.planet.s-delta);
      this.planet.phi += ALPHA_RESTORE*0.005;
      this.reputation += 0.02;
    } else if (action === 'automate') {
      const extraS = 0.02*Math.random();
      this.planet.s += extraS;
      this.planet.v += 0.05;
      this.currency += 0.1;
    } else if (action === 'trade') {
      // simple interplanetary trade
      const other = randomChoice(world.stars.flatMap(s => s.planets.filter(p=>p!==this.planet)));
      const trade_amount = Math.min(this.currency, 5);
      this.currency -= trade_amount;
      other.phi += trade_amount*0.002;
    } else if (action === 'moveStar') {
      // move to a random planet
      const other = randomChoice(world.stars.flatMap(s=>s.planets));
      this.planet = other;
    }
  }
}

class Star {
  constructor(x,y,name) {
    this.x = x; this.y = y; this.name = name;
    this.planets = [];
  }
}

// -----------------------------
// World
// -----------------------------
class World {
  constructor() {
    this.stars = [];
    // Create stars and planets
    for(let i=0;i<NUM_STARS;i++){
      const x = Math.random()*WIDTH*0.8+WIDTH*0.1;
      const y = Math.random()*HEIGHT*0.6+HEIGHT*0.2;
      const star = new Star(x,y,'Star'+i);
      for(let j=0;j<PLANETS_PER_STAR;j++){
        const px = x + Math.random()*50-25;
        const py = y + Math.random()*50-25;
        const planet = new Planet(px,py,`P${i}${j}`);
        for(let k=0;k<AGENTS_PER_PLANET;k++){
          planet.agents.push(new Agent(planet));
        }
        star.planets.push(planet);
      }
      this.stars.push(star);
    }
    this.time = 0;
  }

  step() {
    this.stars.forEach(star => {
      star.planets.forEach(planet => {
        planet.agents.forEach(agent=>agent.act());
        // planet decay
        planet.phi = Math.max(0,planet.phi-ALPHA_DECAY*planet.phi);
        planet.v *= (1-BETA_DAMP);
        planet.s += 0.001*(Math.random()-0.5);
      });
    });
    this.time++;
    this.draw();
    this.logMetrics();
  }

  draw() {
    const canvas = document.getElementById('spaceCanvas');
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#111'; ctx.fillRect(0,0,WIDTH,HEIGHT);

    // draw stars
    this.stars.forEach(star=>{
      ctx.fillStyle = 'yellow';
      ctx.beginPath();
      ctx.arc(star.x,star.y,8,0,2*Math.PI);
      ctx.fill();
      // draw planets
      star.planets.forEach(planet=>{
        const brightness = Math.min(1,planet.s*5);
        ctx.fillStyle = `rgb(${brightness*255}, ${255-brightness*100}, ${255-brightness*150})`;
        ctx.beginPath();
        ctx.arc(planet.x,planet.y,5,0,2*Math.PI);
        ctx.fill();
      });
    });
  }

  logMetrics() {
    let totalS=0, totalPhi=0, totalAgents=0;
    this.stars.forEach(star=>{
      star.planets.forEach(p=>{
        totalS += p.s;
        totalPhi += p.phi;
        totalAgents += p.agents.length;
      });
    });
    document.getElementById('metrics').innerText=
      `Turn: ${this.time} | Total S: ${totalS.toFixed(2)} | Avg Phi: ${(totalPhi/this.stars.flatMap(s=>s.planets).length).toFixed(2)} | Agents: ${totalAgents}`;
  }
}

const world = new World();
world.draw();

function stepWorld(){ world.step(); }
</script>
</body>
</html>
index.html
html
Edit in files
â€¢
Show inline
<button id="autoplayBtn" onclick="toggleAutoplay()">Start/Stop Autoplay</button>

<script>
let paused = true;
let animationFrameId = null;

function toggleAutoplay() {
  paused = !paused;
  const btn = document.getElementById('autoplayBtn');
  btn.textContent = paused ? "Start Autoplay" : "Stop Autoplay";

  if (!paused) {
    const animate = () => {
      if (!paused) {
        world.step();
        animationFrameId = requestAnimationFrame(animate);
      }
    };
    animationFrameId = requestAnimationFrame(animate);
  } else if (animationFrameId) {
    cancelAnimationFrame(animationFrameId);
  }
}
</script>
To incorporate the provided autoplay functionality into the existing "Entropic Empire - Galactic Nexus" code, I will update the HTML and JavaScript to include the new autoplay button and its associated logic. The changes will involve adding the button to the controls section and integrating the
toggleAutoplay
function, while ensuring the existing
togglePause
functionality is preserved but modified to avoid conflicts. The
paused
variable will be renamed to
isPaused
to avoid confusion with the autoplay state, and the
togglePause
function will be adjusted to work harmoniously with the new autoplay mechanism.
