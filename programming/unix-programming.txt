The
unix
programming
en
vironmen
t
Edition
.,
F
eb
			
Mark
Burgess
Cen
tre
of
Science
and
T
ec
hnology
F
acult
y
of
Engineering,
Oslo
College

Cop
yrigh
t
c

		/
Mark
Burgess
P
ermission
is
gran
ted
to
mak
e
and
distribute
v
erbatim
copies
of
this
man
ual
pro
vided
the
cop
yrigh
t
notice
and
this
p
ermission
notice
are
preserv
ed
on
all
copies.
P
ermission
is
gran
ted
to
cop
y
and
distribute
mo
died
v
ersions
of
this
man
ual
under
the
conditions
for
v
erbatim
cop
ying,
pro
vided
also
that
the
section
en
titled
"GNU
General
Public
License"
is
included
exactly
as
in
the
original,
and
pro
vided
that
the
en
tire
resulting
deriv
ed
w
ork
is
distributed
under
the
terms
of
a
p
ermission
notice
iden
tical
to
this
one.
P
ermission
is
gran
ted
to
cop
y
and
distribute
translations
of
this
man
ual
in
to
another
lan-
guage,
under
the
ab
o
v
e
conditions
for
mo
died
v
ersions,
except
that
the
section
en
titled
"GNU
General
Public
License"
ma
y
b
e
included
in
a
translation
appro
v
ed
b
y
the
author
instead
of
in
the
original
English.

F
orew
ord

F
orew
ord
This
is
a
revised
v
ersion
of
the
UNIX
comp
endium
whic
h
is
a
v
ailable
in
prin
ted
form
and
online
via
the
WWW
and
info
h
yp
ertext
readers.
It
forms
the
basis
for
a
one
or
t
w
o
semester
course
in
UNIX.
The
most
up-to-date
v
ersion
of
this
man
ual
can
b
e
found
at
http://www.iu.hioslo.no/
~mar
k/un
ix.
html
.
It
is
a
reference
guide
whic
h
con
tains
enough
to
help
y
ou
to
nd
what
y
ou
need
from
other
sources.
It
is
not
(and
probably
can
nev
er
b
e)
a
complete
and
self-con
tained
w
ork.
Certain
topics
are
co
v
ered
in
more
detail
than
others.
Some
topics
are
included
for
future
reference
and
are
not
in
tended
to
b
e
part
of
an
in
tro
ductory
course,
but
will
probably
b
e
useful
later.
The
c
hapter
on
X
programming
has
b
een
deleted
for
the
time
b
eing.
Commen
ts
to
Mark.Burgess@iu.hioslo.no
Oslo,
June
		


The
unix
programming
en
vironmen
t

W
elcome

W
elcome
If
y
ou
are
coming
to
unix
for
the
rst
time,
from
a
Windo
ws
or
MacIn
tosh
en
vironmen
t,
b
e
prepared
for
a
rather
dieren
t
culture
than
the
one
y
ou
are
used
to.
Unix
is
not
ab
out
`pro
ducts'
and
o-the-shelf
soft
w
are,
it
is
ab
out
op
en
standards,
free
soft
w
are
and
the
abilit
y
to
c
hange
just
ab
out
ev
erything.

What
y
ou
p
ersonally
migh
t
p
erceiv
e
as
user
friendliness
in
other
systems,
others
migh
t
p
erceiv
e
as
anno
ying
time
w
asting.
Unix
oers
y
ou
just
ab
out
ev
ery
lev
el
of
friendli-
ness
and
unfriendliness,
if
y
ou
c
ho
ose
y
our
programs
righ
t.
In
this
b
o
ok,
w
e
tak
e
the
programmer's
p
oin
t
of
view.

Unix
is
ab
out
functionalit
y
,
not
ab
out
simplicit
y
.
Be
prepared
for
p
o
w
erful,
not
neces-
sarily
`simple'
solutions.
Y
ou
should
approac
h
Unix
the
w
a
y
y
ou
should
approac
h
an
y
new
system:
with
an
op
en
mind.
The
journey
b
egins...


The
unix
programming
en
vironmen
t

Chapter
:
Ov
erview


Ov
erview
In
this
manual
the
wor
d
"host"
is
use
d
to
r
efer
to
a
single
c
omputer
system
{
i.e.
a
single
machine
which
has
a
name
terme
d
its
"hostname".
.
What
is
unix?
Unix
is
one
of
the
most
imp
ortan
t
op
erating
system
in
use
to
da
y
,
p
erhaps
ev
en
the
most
imp
ortan
t.
Since
its
in
v
en
tion
around
the
b
eginning
of
the
	0s
it
has
b
een
an
ob
ject
of
con
tin
ual
researc
h
and
dev
elopmen
t.
UNIX
is
not
p
opular
b
ecause
it
is
the
b
est
op
erating
system
one
could
imagine,
but
b
ecause
it
is
an
extremely
exible
system
whic
h
is
easy
to
extend
and
mo
dify
.
It
is
an
ideal
platform
for
dev
eloping
new
ideas.
Muc
h
of
the
success
of
UNIX
ma
y
b
e
attributed
to
the
rapid
pace
of
its
dev
elopmen
t
(a
dev
elopmen
t
to
whic
h
all
of
its
users
ha
v
e
b
een
able
to
con
tribute)
its
eciency
at
running
programs
and
the
man
y
p
o
w
erful
to
ols
whic
h
ha
v
e
b
een
written
for
it
o
v
er
the
y
ears,
suc
h
as
the
C
programming
language,
make,
shell,
lex
and
yacc
and
man
y
others.
UNIX
w
as
written
b
y
programmers
for
programmers.
It
is
p
opular
in
situations
where
a
lot
of
computing
p
o
w
er
is
required
and
for
database
applications,
where
timesharing
is
critical.
In
con
trast
to
some
op
erating
systems,
UNIX
p
erforms
equally
w
ell
on
large
scale
computers
(with
man
y
pro
cessors)
and
small
computers
whic
h
t
in
y
our
suitcase!
All
of
the
basic
mec
hanisms
required
of
a
m
ulti-user
op
erating
system
are
presen
t
in
UNIX.
During
the
last
few
y
ears
it
has
b
ecome
ev
er
more
p
opular
and
has
formed
the
basis
of
new
er,
though
less
mature,
systems
lik
e
NT.
One
reason
for
this
that
no
w
computers
ha
v
e
no
w
b
ecome
p
o
w
erful
enough
to
run
UNIX
eectiv
ely
.
UNIX
places
burdens
on
the
resources
of
a
computer,
since
it
exp
ects
to
b
e
able
to
run
p
oten
tially
man
y
programs
sim
ultaneously
.
If
y
ou
are
coming
to
UNIX
from
DOS
y
ou
ma
y
w
ell
b
e
used
to
using
applications
soft
w
are
or
helpful
in
teractiv
e
utilities
to
solv
e
ev
ery
problem.
UNIX
is
not
usually
lik
e
this:
the
op
erating
system
has
m
uc
h
greater
functionalit
y
and
pro
vides
the
p
ossibilities
for
making
y
our
o
wn,
so
it
is
less
common
to
nd
applications
soft
w
are
whic
h
implemen
ts
the
same
things.
UNIX
has
long
b
een
in
the
hands
of
academics
who
are
used
to
making
their
o
wn
applications
or
writing
their
o
wn
programs,
whereas
as
the
DOS
w
orld
has
b
een
driv
en
b
y
businesses
who
are
willing
to
sp
end
money
on
soft
w
are.
F
or
that
reason
commerical
UNIX
soft
w
are
is
often
v
ery
exp
ensiv
e
and
therefore
not
a
v
ailable
at
this
college.
On
the
other
hand,
the
exibilit
y
of
UNIX
means
that
it
is
easy
to
write
programs
and
it
is
p
ossible
to
fetc
h
gigab
ytes
of
fr
e
e
softwar
e
from
the
in
ternet
to
suit
y
our
needs.
It
ma
y
not
lo
ok
lik
e
what
y
ou
are
used
to
on
y
our
PC,
but
then
y
ou
ha
v
e
to
remem
b
er
that
UNIX
users
are
a
dieren
t
kind
of
animal
altogether
Lik
e
all
op
erating
systems,
UNIX
has
man
y
faults.
The
biggest
problem
for
an
y
op
erating
system
is
that
it
ev
olv
es
without
b
eing
redesigned.
Op
erating
systems
ev
olv
e
as
more
and
more
patc
hes
and
hac
ks
are
applied
to
solv
e
da
y-to-da
y
problems.
The
result
is
either
a
mess
whic
h
w
orks
someho
w
(lik
e
UNIX)
or
a
blank
refusal
to
c
hange
(lik
e
DOS
or
MacIn
tosh).
F
rom
a
practical
p
ersp
ectiv
e,
Unix
is
imp
ortan
t
and
successful
b
ecause
it
is
a
m
ulti-pro
cess
system
whic
h

has
an
enormous
functionalit
y
built
in,
and
the
capacit
y
to
adapt
itself
to
c
hanging
tec
hnologies,


The
unix
programming
en
vironmen
t

is
relativ
ely
p
ortable,

is
go
o
d
at
sharing
resources
(but
not
so
go
o
d
at
securit
y),

has
to
ols
whic
h
are
eac
h
dev
elop
ed
to
do
one
thing
wel
l,

allo
ws
these
to
ols
to
b
e
com
bined
in
ev
ery
imaginable
w
a
y
,
using
pip
es
and
c
hanneling
of
data
streams,

incorp
orates
net
w
orking
almost
trivially
,
b
ecause
all
the
righ
t
mec
hanisms
are
already
there
for
pro
viding
services
and
sharing,
building
clien
t-serv
er
pairs
etc,.

it
is
v
ery
adaptable
and
is
often
used
to
dev
elop
new
ideas
b
ecause
of
the
ric
h
v
ariet
y
of
to
ols
it
p
ossesses.
Unix
has
some
problems:
it
is
old,
it
con
tains
a
lot
of
rubbish
whic
h
no
one
ev
er
b
othered
to
thro
w
a
w
a
y
.
Although
it
dev
elops
quic
kly
(at
ligh
t
sp
eed
compared
to
either
DOS
or
MacIn
tosh)
the
user
in
terface
has
b
een
the
slo
w
est
thing
to
c
hange.
Unix
is
not
user-
friendly
for
b
eginners,
it
is
user-friendly
for
adv
anced
users:
it
is
made
for
users
who
know
ab
out
computing.
It
sometimes
mak
es
simple
things
dicult,
but
ab
o
v
e
all
it
mak
es
things
p
ossible!
The
aim
of
this
in
tro
duction
is
to

in
tro
duce
the
unix
system
basics
and
user
in
terface,

dev
elop
the
unix
philosoph
y
of
using
and
com
bining
to
ols,

learn
ho
w
to
mak
e
new
to
ols
and
write
soft
w
are,

learn
ho
w
to
understand
existing
soft
w
are.
T
o
accomplish
this
task,
w
e
m
ust
rst
learn
something
ab
out
the
shell
(the
w
a
y
in
whic
h
UNIX
starts
programs).
Later
w
e
shall
learn
ho
w
to
solv
e
more
complex
problems
using
P
erl
and
C.
Eac
h
of
these
is
a
language
whic
h
can
b
e
used
to
put
UNIX
to
w
ork.
W
e
m
ust
also
learn
when
to
use
whic
h
to
ol,
so
that
w
e
do
not
w
aste
time
and
eort.
T
ypical
uses
for
these
dieren
t
in
terfaces
are
shel
l
Command
line
in
teraction,
making
scripts
whic
h
p
erform
simple
jobs
suc
h
as
running
programs
in
batc
h,
installing
new
soft
w
are,
simple
system
conguration
and
administration.
p
erl
T
ext
in
terpretation,
text
formatting,
output
lters,
mail
rob
ots,
WWW
cgi
(common
gatew
a
y
in
terface)
scripts
in
forms,
passw
ord
testing,
simple
database
manipulation,
simple
clien
t-serv
er
applications.
C
Nearly
all
of
UNIX
is
written
in
C.
An
y
program
whic
h
cannot
b
e
solv
ed
quic
kly
using
shell
or
p
erl
can
b
e
written
in
C.
One
adv
an
tage
is
that
C
is
a
compiled
language
and
man
y
simple
errors
can
b
e
caugh
t
at
compile
time.
Muc
h
of
UNIX's
recen
t
p
opularit
y
has
b
een
a
result
of
its
net
w
orking
abilities:
unix
is
the
bac
kb
one
of
the
in
ternet.
No
other
widely
a
v
ailable
system
could
k
eep
the
in
ternet
aliv
e
to
da
y
.
Once
y
ou
ha
v
e
mastered
the
unix
in
terface
and
philosoph
y
y
ou
will
nd
that
i)
the
PC
and
MacIn
tosh
windo
w
en
vironmen
ts
seem
to
b
e
easy
to
use,
but
simplistic
and
primitiv
e
b
y
comparison;
ii)
UNIX
is
far
from
b
eing
the
p
erfect
op
erating
system|it
has
a
whole
dieren
t
set
of
problems
and
a
ws.

Chapter
:
Ov
erview

The
op
erating
system
of
the
future
will
not
b
e
UNIX
as
w
e
see
it
to
da
y
,
nor
will
is
b
e
DOS
or
MacIn
tosh,
but
one
thing
is
for
certain:
it
will
o
w
e
a
lot
to
the
UNIX
op
erating
system
and
will
con
tain
man
y
of
the
to
ols
and
mec
hanisms
w
e
shall
describ
e
b
elo
w.
.
Fla
v
ours
of
unix
Unix
is
not
a
single
op
erating
system.
It
has
branc
hed
out
in
man
y
dieren
t
directions
since
it
w
as
in
tro
duced
b
y
A
T&T.
The
most
imp
ortan
t
`fork()'
in
its
history
happ
ened
early
on
when
the
univ
ersit
y
of
Berk
eley
,
California
created
the
BSD
(Berk
eley
Soft
w
are
Distribution),
adding
net
w
ork
supp
ort
and
the
C-shell.
Here
are
some
of
the
most
common
implemen
tations
of
unix.
BSD:
Berk
eley
,
BSD
SunOS:
Sun
Microsystems,
BSD/sys

Solaris:
Sun
Microsystems,
Sys
/BSD
Ultrix:
Digital
Equipmen
t
Corp
eration,
BSD
OSF
:
Digital
Equipmen
t
Corp
eration,
BSD/sys

HPUX:
Hewlett-P
ac
k
ard,
Sys

AIX:
IBM,
Sys

/
BSD
IRIX:
Silicon
Graphics,
Sys

GNU/Linux:
GNU,
BSD/P
osix
.
Ho
w
to
use
this
reference
guide
This
programming
guide
is
something
b
et
w
een
a
user
man
ual
and
a
tutorial.
The
infor-
mation
con
tained
here
should
b
e
sucien
t
to
get
y
ou
started
with
the
unix
system,
but
it
is
far
from
complete.
T
o
use
this
programming
guide,
y
ou
will
need
to
w
ork
through
the
basics
from
eac
h
c
hapter.
Y
ou
will
nd
that
there
is
m
uc
h
more
information
here
than
y
ou
need
straigh
t
a
w
a
y
,
so
try
not
to
b
e
o
v
erwhelmed
b
y
the
amoun
t
of
material.
Use
the
con
ten
ts
and
the
indices
at
the
bac
k
to
nd
the
information
y
ou
need.
If
y
ou
are
follo
wing
a
one-semester
UNIX
course,
y
ou
should
probably
concen
trate
on
the
follo
wing:

The
remainder
of
this
in
tro
duction

The
detailed
kno
wledge
of
the
C
shell

An
appreciation
of
the
Bourne
shell

A
detailed
kno
wledge
of
P
erl,
guided
b
y
c
hapter
.
This
c
hapter
pro
vides
p
oin
ters
on
ho
w
to
get
started
in
p
erl.
It
is
not
a
substitute
for
the
p
erl
b
o
ok.

Ev
erything
in
c
hapter

ab
out
C
programming.
This
c
hapter
is
written
in
note
form,
since
it
is
assumed
that
y
ou
kno
w
a
lot
ab
out
C
programming
already
.

A
sound
appreciation
of
c
hapter

on
net
w
ork
programming.


The
unix
programming
en
vironmen
t
The
only
w
a
y
to
learn
UNIX
is
to
sit
do
wn
and
try
it.
As
with
an
y
new
thing,
it
is
a
pain
to
get
started,
but
once
y
ou
are
started,
y
ou
will
probably
come
to
agree
that
UNIX
con
tains
a
w
ealth
of
p
ossibilities,
p
erhaps
more
than
y
ou
had
ev
er
though
w
as
p
ossible
or
useful!
One
of
the
adv
an
tages
of
the
UNIX
system
is
that
the
en
tire
UNIX
man
ual
is
a
v
ailable
on-line.
Y
ou
should
get
used
to
lo
oking
for
information
in
the
online
man
ual
pages.
F
or
instance,
supp
ose
y
ou
do
not
remem
b
er
ho
w
to
create
a
new
directory
,
y
ou
could
do
the
follo
wing:
nexus%
man
-k
dir
dir
ls
()
-
list
contents
of
directories
dirname
dirname
()
-
strip
non-directory
suffix
from
file
name
dirs
bash
()
-
bash
built-in
commands,
see
bash()
find
find
()
-
search
for
files
in
a
directory
hierarchy
ls
ls
()
-
list
contents
of
directories
mkdir
mkdir
()
-
make
directories
pwd
pwd
()
-
print
name
of
current/working
directory
rmdir
rmdir
()
-
remove
empty
directories
The
`man
-k'
command
lo
oks
for
a
k
eyw
ord
in
the
man
ual
and
lists
all
the
references
it
nds.
The
command
`apropos'
is
completely
equiv
alen
t
to
`man
-k'.
Ha
ving
disco
v
ered
that
the
command
to
create
a
directory
is
`mkdir'
y
ou
can
no
w
lo
ok
up
the
sp
ecic
manaul
page
on
`mkdir'
to
nd
out
ho
w
to
use
it:
man
mkdir
Some
but
no
all
of
the
UNIX
commands
also
ha
v
e
a
help
option
whic
h
is
activ
ated
with
the
`-h'
or
`--help'
command-line
option.
dax%
mkdir
--help
Usage:
mkdir
[OPTION]
DIRECTORY...
-p,
--parents
no
error
if
existing,
make
parent
directories
as
needed
-m,
--mode=MODE
set
permission
mode
(as
in
chmod),
not
0
-
umask
--help
display
this
help
and
exit
--version
output
version
information
and
exit
dax%
.
NEVER-DO's
in
UNIX
There
are
some
things
that
y
ou
should
nev
er
do
in
UNIX.
Some
of
these
will
cause
y
ou
more
serious
problems
than
others.
Y
ou
can
mak
e
y
our
o
wn
list
as
y
ou
disco
v
er
more.

Y
ou
should
NEVER
EVER
switc
h
o
the
p
o
w
er
on
a
Unix
computer
unless
y
ou
kno
w
what
y
ou
are
doing.
A
Unix
mac
hine
is
not
lik
e
a
PC
running
DOS.
Ev
en
when
y
ou
are
not
doing
an
ything,
the
system
is
w
orking
in
the
bac
kground.
If
y
ou
switc
h
o
the
p
o
w
er,
y
ou
could
in
terrupt
the
system
while
it
is
writing
to
the
disk
driv
e
and
destro
y
y
our
disk.
Y
ou
m
ust
also
remem
b
er
that
sev
eral
users
migh
t
b
e
using
the
system
ev
en
though
y
ou
cannot
see
them:
they
do
not
ha
v
e
to
b
e
sitting
at
the
mac
hine,
they
could
b
e
logged
in
o
v
er
the
net
w
ork.
If
y
ou
switc
h
o
the
p
o
w
er,
y
ou
migh
t
ruin
their
v
aluable
w
ork.

Chapter
:
Ov
erview
	

Once
y
ou
ha
v
e
deleted
a
UNIX
le
using
rm
it
is
imp
ossible
to
reco
v
er
it!
Don't
use
wildcards
with
rm
without
thinking
quite
carefully
ab
out
what
y
ou
are
doing!
It
has
happ
ened
to
v
ery
man
y
users
throughout
the
history
of
UNIX
that
one
tries
to
t
yp
e
rm
*~
but
instead,
b
y
a
slip
of
the
hand,
one
writes
rm
*
~
Unix
then
tak
es
these
wildcards
in
turn,
so
that
the
rst
command
is
rm
*
whic
h
deletes
all
of
y
our
les!
BE
CAREFUL!

Don't
ev
er
call
a
program
or
an
imp
ortan
t
le
`core'.
Man
y
scripts
go
around
deleting
les
called
`core'
b
ecause
the,
when
a
program
crashes,
UNIX
dumps
the
en
tire
k
ernel
image
to
a
le
called
`core'
and
these
les
use
up
a
lot
of
disk
space.
If
y
ou
call
a
le
`core'
it
migh
t
get
deleted!

Don't
call
test
programs
test.
There
is
a
UNIX
command
whic
h
is
already
called
test
and
c
hances
are
that
when
y
ou
try
to
run
y
our
program
y
ou
will
start
the
UNIX
command
instead.
This
can
cause
a
lot
of
confusion
b
ecause
the
UNIX
command
do
esn't
seem
to
do
v
ery
m
uc
h
at
all!
.
What
y
ou
should
kno
w
b
efore
starting
..
One
library:
sev
eral
in
terfaces
The
core
of
unix
is
the
library
of
functions
(written
in
C)
whic
h
access
the
system.
Ev
erything
y
ou
do
on
a
unix
system
go
es
through
this
set
of
functions.
Ho
w
ev
er,
y
ou
can
c
ho
ose
y
our
o
wn
in
terface
to
these
library
functions.
Unix
has
v
ery
man
y
dieren
t
in
terfaces
to
its
libraries
in
the
form
of
languages
and
command
in
terpreters.
Y
ou
can
use
the
functions
directly
in
C,
or
y
ou
can
use
command
programs
lik
e
`ls',
`cd'
etc.
These
functions
just
pro
vide
a
simple
user
in
terface
to
the
C
calls.
Y
ou
can
also
use
a
v
ariet
y
of
`script'
languages:
C-shell,
Bourne
shell,
P
erl,
Tcl,
sc
heme.
Y
ou
c
ho
ose
the
in
terface
whic
h
solv
es
y
our
problem
most
easily
.
..
Unix
commands
are
les
With
the
exception
of
a
few
simple
commands
whic
h
are
built
in
to
the
command
in
ter-
preter
(shell),
all
unix
commands
and
programs
consist
of
executable
les.
In
other
w
ords,
there
is
a
separate
executable
le
for
eac
h
command.
This
mak
es
it
extremely
simple
to
add
new
commands
to
the
system.
One
simply
mak
es
a
program
with
the
desired
name
and
places
it
in
the
appropriate
directory
.
Unix
commands
liv
e
in
sp
ecial
directories
(usually
called
bin
for
binary
les).
The
lo
cation
of
these
directories
is
recorded
in
a
v
ariable
called
path
or
PATH
whic
h
is
used
b
y
the
system
to
searc
h
for
binaries.
W
e
shall
return
to
this
in
more
detail
in
later
c
hapters.
..
Kernel
and
Shell
Since
users
cannot
command
the
k
ernel
directly
,
UNIX
has
a
command
language
kno
wn
as
the
shel
l.
The
w
ord
shell
implies
a
la
y
er
around
the
k
ernel.
A
shell
is
a
user
in
terface,
or
command
in
terpreter.

0
The
unix
programming
en
vironmen
t
There
are
t
w
o
main
v
ersions
of
the
shell,
plus
a
n
um
b
er
of
enhancemen
ts.
/bin/sh
The
Bourne
Shell.
The
shell
is
most
often
used
for
writing
system
scripts.
It
is
part
of
the
original
unix
system.
/bin/csh
The
C-shell.
This
w
as
added
to
unix
b
y
the
Berk
eley
w
ork
ers.
The
commands
and
syn
tax
resem
ble
C
co
de.
C-shell
is
b
etter
suited
for
in
teractiv
e
w
ork
than
the
Bourne
shell.
The
program
tcsh
is
a
public-domain
enhancemen
t
of
the
csh
and
is
in
common
use.
Tw
o
impro
v
ed
v
ersions
of
the
Bourne
shell
also
exist:
ksh,
the
Korn
shell
and
bash,
the
Bourne-again
shell.
Although
the
shells
are
mainly
to
ols
for
t
yping
in
commands
(whic
h
are
excutable
les
to
b
e
loaded
and
run),
they
con
tain
features
suc
h
as
aliases,
a
command
history
,
wildcard-
expansions
and
job
con
trol
functions
whic
h
pro
vide
a
comfortable
user
en
vironmen
t.
..
The
role
of
C
Most
of
the
unix
k
ernel
and
daemons
are
written
in
the
C
programming
language

.
Calls
to
the
k
ernel
and
to
services
are
made
through
functions
in
the
standard
C
library
.
The
commands
lik
e
chmod,
mkdir
and
cd
are
all
C
functions.
The
binary
les
of
the
same
name
/bin/chmod,
/bin/mkdir
etc.
are
just
trivial
"wrapp
er"
programs
for
these
C
functions.
Un
til
Solaris
,
the
C
compiler
w
as
a
standard
part
of
the
UNIX
op
erating
system,
th
us
C
is
the
most
natural
language
to
program
in
in
a
UNIX
en
vironmen
t.
Some
to
ols
are
pro
vided
for
C
programmers:
dbx
A
sym
b
olic
debugger.
Also
gdb,
xxgdb
ddd.
make
A
dev
elopmen
t
to
ol
for
compiling
large
programs.
lex
A
`lexer'.
A
program
whic
h
generates
C
co
de
to
recognize
w
ords
of
text.
yac
c
A
`parser'.
This
is
a
to
ol
whic
h
generates
C
co
de
for
c
hec
king
the
syn
tax
of
groups
of
textual
w
ords.
rp
c
gen
A
proto
col
compiler
whic
h
generates
C
co
de
from
a
higher
lev
el
langauge,
for
programming
RPC
applications.
..
Stdin,
stdout,
stderr
Unix
has
three
logical
str
e
ams
or
les
whic
h
are
alw
a
ys
op
en
and
are
a
v
ailable
to
an
y
program.
stdin
The
standard
input
-
le
descriptor
0.
stdout
The
standard
output
-
le
descriptor
.
stderr
The
standard
error
-
le
descriptor
.
The
names
are
a
part
of
the
C
language
and
are
dened
as
p
oin
ters
of
t
yp
e
FILE.

In
particular
they
are
written
in
Kernighan
and
Ritc
hie
C,
not
the
new
er
ANSI
standard
C.

Chapter
:
Ov
erview

#include
<stdio.h>
/*
FILE
*stdin,
*stdout,
*stderr;
*/
fprintf(stderr,"This
is
an
error
message!\n");
The
names
are
`logical'
in
the
sense
that
they
do
not
refer
to
a
particular
device,
or
a
particular
place
for
information
to
come
from
or
go.
Their
role
is
analogous
to
the
`.'
and
`..'
directories
in
the
lesystem.
Programs
can
write
to
these
les
without
w
orrying
ab
out
where
the
information
comes
from
or
go
es
to.
The
user
can
p
ersonally
dene
these
places
b
y
r
e
dir
e
cting
standar
d
I/O.
This
is
discussed
in
the
next
c
hapter.
A
separate
stream
is
k
ept
for
error
messages
so
that
error
output
do
es
not
get
mixed
up
with
a
program's
in
tended
output.
.
The
sup
eruser
(ro
ot)
and
nob
o
dy
When
logged
on
to
a
UNIX
system
directly
,
the
user
whose
name
is
root
has
unlimited
access
to
the
les
on
the
system.
root
can
also
b
ecome
an
y
other
user
without
ha
ving
to
giv
e
a
passw
ord.
root
is
reserv
ed
for
the
system
administrator
or
truste
d
users.
Certain
commands
are
forbidden
to
normal
users.
F
or
example,
a
regular
user
should
not
b
e
able
to
halt
the
system,
or
c
hange
the
o
wnership
of
les
(see
next
paragraph).
These
things
are
reserv
ed
for
the
root
or
sup
eruser.
In
a
net
w
ork
ed
en
vironmen
t,
root
has
no
automatic
authorit
y
on
remote
mac
hines.
This
is
to
prev
en
t
the
system
administrator
of
one
mac
hine
in
Canada
from
b
eing
able
to
edit
les
on
another
in
China.
He
or
she
m
ust
log
in
directly
and
supply
a
passw
ord
in
order
to
gain
access
privileges.
On
a
net
w
ork
where
les
are
often
accessible
in
principle
to
an
y
one,
the
username
root
gets
mapp
ed
to
the
user
nobody,
who
has
no
righ
ts
at
all.
.
The
le
hierarc
h
y
Unix
has
a
hierac
hical
lesystem,
whic
h
mak
es
use
of
directories
and
sub-directories
to
form
a
tree.
The
ro
ot
of
the
tree
is
called
the
ro
ot
lesystem
or
`/'.
Although
the
details
of
where
ev
ery
le
is
lo
cated
dier
for
dieren
t
v
ersions
of
unix,
some
basic
features
are
the
same.
The
main
sub-directories
of
the
ro
ot
directory
together
with
the
most
imp
ortan
t
le
are
sho
wn
in
the
gure.
Their
con
ten
ts
are
as
follo
ws.
`/bin'
Executable
(binary)
programs.
On
most
systems
this
is
a
separate
directory
to
/usr/bin.
In
SunOS,
this
is
a
p
oin
ter
(link)
to
/usr/bin.
`/etc'
Miscellaneous
programs
and
conguration
les.
This
directory
has
b
ecome
v
ery
messy
o
v
er
the
history
of
UNIX
and
has
b
ecome
a
dumping
ground
for
almost
an
ything.
Recen
t
v
ersions
of
unix
ha
v
e
b
egun
to
tidy
up
this
directory
b
y
creating
sub
directories
`/etc/mail',
`/etc/services'
etc!
`/usr'
This
con
tains
the
main
meat
of
UNIX.
This
is
where
application
soft
w
are
liv
es,
together
with
all
of
the
basic
libraries
used
b
y
the
OS.
`/usr/bin'
More
executables
from
the
OS.


The
unix
programming
en
vironmen
t
`/usr/local'
This
is
where
users'
custom
soft
w
are
is
normally
added.
`/sbin'
A
sp
ecial
area
for
statically
link
ed
system
binaries.
They
are
placed
here
to
distinguish
commands
used
solely
b
y
the
system
administrator
from
user
com-
mands
and
so
that
they
lie
on
the
system
ro
ot
partition
where
they
are
guar-
an
teed
to
b
e
accessible
during
b
o
oting.
`/sys'
This
holds
the
conguration
data
whic
h
go
to
build
the
system
k
ernel.
(See
b
elo
w.)
`/export'
Net
w
ork
serv
ers
only
use
this.
This
con
tains
the
disk
space
set
aside
for
clien
t
mac
hines
whic
h
do
not
ha
v
e
their
o
wn
disks.
It
is
lik
e
a
`virtual
disk'
for
diskless
clien
ts.
`/dev,
/devices'
A
place
where
all
the
`logical
devices'
are
collected.
These
are
called
`device
no
des'
in
unix
and
are
created
b
y
mknod.
Logical
devices
are
UNIX's
ocial
en
try
p
oin
ts
for
writing
to
devices.
F
or
instance,
/dev/console
is
a
route
to
the
system
console,
while
/dev/kmem
is
a
route
for
reading
k
ernel
memory
.
Device
no
des
enable
devices
to
b
e
treated
as
though
they
w
ere
les.
`/home'
(Called
/users
on
some
systems.)
Eac
h
user
has
a
separate
login
directory
where
les
can
b
e
k
ept.
These
are
normally
stored
under
/home
b
y
some
con
v
en
tion
decided
b
y
the
system
administrator.
`/var'
System

and
mixed
systems
ha
v
e
a
separate
directory
for
sp
o
oling.
Under
old
BSD
systems,
/usr/spool
con
tains
sp
o
ol
queues
and
system
data.
/var/spool
and
/var/adm
etc
are
used
for
holding
queues
and
system
log
les.
`/vmunix'
This
is
the
program
co
de
for
the
unix
kernel
(see
b
elo
w).
On
HPUX
systems
with
le
is
called
`hp-ux'.
On
lin
ux
it
is
called
`linux'.
`/kernel'
On
new
er
systems
the
k
ernel
is
built
up
from
a
n
um
b
er
of
mo
dules
whic
h
are
placed
in
this
directory
.
Ev
ery
unix
directory
con
tains
t
w
o
`virtual'
directories
mark
ed
b
y
a
single
dot
and
t
w
o
dots.
ls
-a
.
..
The
single
dot
represen
ts
the
directory
one
is
already
in
(the
curren
t
directory).
The
double
dots
mean
the
directory
one
lev
el
up
the
tree
from
the
curren
t
lo
cation.
Th
us,
if
one
writes
cd
/usr/local
cd
..
the
nal
directory
is
/usr.
The
single
dot
is
v
ery
useful
in
C
programming
if
one
wishes
to
read
`the
curren
t
directory'.
Since
this
is
alw
a
ys
called
`.'
there
is
no
need
to
k
eep
trac
k
of
what
the
curren
t
directory
really
is.
`.'
and
`..'
are
`hard
links'
to
the
true
directories.

Chapter
:
Ov
erview

.
Sym
b
olic
links
A
sym
b
olic
link
is
a
p
oin
ter
or
an
alias
to
another
le.
The
command
ln
-s
fromfile
/other/directory/tolink
mak
es
the
le
fromfile
app
ear
to
exist
at
/other/directory/tolink
sim
ultaneously
.
The
le
is
not
copied,
it
merely
app
ears
to
b
e
a
part
of
the
le
tree
in
t
w
o
places.
Sym
b
olic
links
can
b
e
made
to
b
oth
les
and
directories.
A
sym
b
olic
link
is
just
a
small
le
whic
h
con
tains
the
name
of
the
real
le
one
is
in
terested
in.
It
cannot
b
e
op
ened
lik
e
an
ordinary
le,
but
ma
y
b
e
read
with
the
C
call
readlink()
See
Section
	..
[lstat
and
readlink],
page
.
If
w
e
remo
v
e
the
le
a
sym
b
olic
link
p
oin
ts
to,
the
link
remains
{
it
just
p
oin
ts
no
where.
.	
Hard
links
A
har
d
link
is
a
duplicate
ino
de
in
the
lesystem
whic
h
is
in
ev
ery
w
a
y
equiv
alen
t
to
the
original
le
ino
de.
If
a
le
is
p
oin
ted
to
b
y
a
hard
link,
it
cannot
b
e
remo
v
ed
un
til
the
link
is
remo
v
ed.
If
a
le
has
n
hard
links
{
all
of
them
m
ust
b
e
remo
v
ed
b
efore
the
le
can
b
e
remo
v
ed.
The
n
um
b
er
of
hard
links
to
a
le
is
stored
in
the
lesystem
index
no
de
for
the
le.


The
unix
programming
en
vironmen
t

Chapter
:
Getting
started


Getting
started
If
y
ou
ha
v
e
nev
er
met
unix,
or
another
m
ultiuser
system
b
efore,
then
y
ou
migh
t
nd
the
idea
daun
ting.
There
are
sev
eral
things
y
ou
should
kno
w.
.
Logging
in
Eac
h
time
y
ou
use
unix
y
ou
m
ust
log
on
to
the
system
b
y
t
yping
a
username
and
a
passw
ord.
Y
our
login
name
is
sometimes
called
an
`accoun
t'
b
ecause
some
unix
systems
implemen
t
strict
quotas
for
computer
resources
whic
h
ha
v
e
to
b
e
paid
for
with
real
money

.


login:
mark
password:

	
Once
y
ou
ha
v
e
t
yp
ed
in
y
our
passw
ord,
y
ou
are
`logged
on'.
What
happ
ens
then
dep
ends
on
what
kind
of
system
y
ou
are
logged
on
to
and
ho
w.
If
y
ou
ha
v
e
a
colour
monitor
and
k
eyb
oard
in
fron
t
of
y
ou,
with
a
graphical
user
in
terface,
y
ou
will
see
a
n
um
b
er
of
windo
ws
app
ear,
p
erhaps
a
men
u
bar.
Y
ou
then
use
a
mouse
and
k
eyb
oard
just
lik
e
an
y
other
system.
This
is
not
the
only
w
a
y
to
log
on
to
unix.
Y
ou
can
also
log
in
remotely
,
from
another
mac
hine,
using
the
telnet
or
rlogin
programs.
If
y
ou
use
these
programs,
y
ou
will
normally
only
get
a
text
or
command
line
in
terface
(though
graphics
can
still
b
e
arranged).
Once
y
ou
ha
v
e
logged
in,
a
short
message
will
b
e
prin
ted
(called
Message
of
the
Da
y
or
motd)
and
y
ou
will
see
the
C-shell
prompt:
the
name
of
the
host
y
ou
are
logged
on
to
follo
w
ed
b
y
a
p
ercen
t
sign,
e.g.


SunOS
Release
.
Version
Generic
[UNIX(R)
System
V
Release
.0]
Copyright
(c)
	-		,
Sun
Microsystems,
Inc.
Please
report
problems
to
sysadm@iu.hioslo.no
dax%

	
Remem
b
er
that
ev
ery
unix
mac
hine
is
a
separate
en
tit
y:
it
is
not
lik
e
logging
on
to
a
PC
system
where
y
ou
log
on
to
the
`net
w
ork'
i.e.
the
PC
le
serv
er.
Ev
ery
unix
mac
hine
is
a
serv
er.
The
net
w
ork,
in
unix-land,
has
lots
of
pla
y
ers.
The
rst
thing
y
ou
should
do
once
y
ou
ha
v
e
logged
on
is
to
set
a
reliable
passw
ord.
A
p
o
or
passw
ord
migh
t
b
e
ok
a
y
on
a
PC
whic
h
is
not
attac
hed
to
a
large
net
w
ork,
but
once
y
ou
are
attac
hed
to
the
in
ternet,
y
ou
ha
v
e
to
remem
b
er
that
the
whole
w
orld
will
b
e
trying
to
crac
k
y
our
passw
ord.
Don't
think
that
no
one
will
b
other:
some
p
eople
really
ha
v
e
nothing
b
etter
to
do.
A
passw
ord
should
not
con
tain
an
y
w
ord
that
could
b
e
in
a
list
of
w
ords
(in
an
y
language),
or
b
e
a
simple
concatenation
of
a
w
ord
and
a
n
um
b
er
(e.g.

This
is
seldom
true
these
da
ys.


The
unix
programming
en
vironmen
t
mark).
It
tak
es
seconds
to
crac
k
suc
h
a
passw
ord.
Cho
ose
instead
something
whic
h
is
easy
to
remem
b
er.
F
eel
free
to
use
the
PIN
n
um
b
er
from
y
our
bank
ers
card
in
y
our
passw
ord!
This
will
lea
v
e
y
ou
with
few
er
things
to
remem
b
er.
e.g.
Ma	rk).
P
assw
ords
can
b
e
up
to
eigh
t
c
haracters
long.
Some
sites
allo
w
y
ou
to
c
hange
y
our
passw
ord
an
ywhere.
Other
sites
require
y
ou
to
log
on
to
a
sp
ecial
mac
hine
to
c
hange
y
our
passw
ord:


dax%
dax%
passwd
Change
your
password
on
host
nexus
You
cannot
change
it
here
dax%
rlogin
nexus
password:
******
nexus%
passwd
Changing
password
for
mark
Enter
login
password:
********
Enter
new
password:
********
Reenter
new
passwd:
********

	
Y
ou
will
b
e
prompted
for
y
our
old
passw
ord
and
y
our
new
passw
ord
t
wice.
If
y
our
net
w
ork
is
large,
it
migh
t
tak
e
the
system
up
to
an
hour
or
t
w
o
to
register
the
c
hange
in
y
our
passw
ord,
so
don't
forget
the
old
one
righ
t
a
w
a
y!
.
Mouse
buttons
Unix
has
three
mouse
buttons.
On
some
PC's
running
GNU/Lin
ux
or
some
other
PC
unix,
there
are
only
t
w
o,
but
the
middle
mouse
button
can
b
e
sim
ulated
b
y
pressing
b
oth
mouse
buttons
sim
ultaneously
.
The
mouse
buttons
ha
v
e
the
follo
wing
general
functions.
They
ma
y
also
ha
v
e
additional
functions
in
sp
ecial
soft
w
are.
index
nger
This
is
used
to
select
and
clic
k
on
ob
jects.
It
is
also
used
to
mark
out
areas
and
cop
y
b
y
dragging.
This
is
the
button
y
ou
normally
use.
midd
le
nger
Used
to
pull
do
wn
men
us.
It
is
also
used
to
paste
a
mark
ed
area
somewhere
at
the
mouse
p
osition.
outer
nger
Pulls
do
wn
men
us.
On
a
left-handed
system
righ
t
and
left
are
rev
ersed.
.
E-mail
Reading
electronic
mail
on
unix
is
just
lik
e
an
y
other
system,
but
there
are
man
y
pro-
grams
to
c
ho
ose
from.
There
are
v
ery
old
programs
from
the
sev
en
ties
suc
h
as

Chapter
:
Getting
started

mail
and
there
are
fully
graphical
mail
programs
suc
h
as
tkrat
mailtool
Cho
ose
the
program
y
ou
lik
e
b
est.
Not
all
of
the
programs
supp
ort
mo
dern
m
ultimedia
extensions
b
ecause
of
their
age.
Some
programs
lik
e
tkrat
ha
v
e
immediate
mail
notication
alerts.
T
o
start
a
mail
program
y
ou
just
t
yp
e
its
name.
If
y
ou
ha
v
e
an
icon-bar,
y
ou
can
clic
k
on
the
mail-icon.
.
Simple
commands
Inexp
erienced
computer
users
often
prefer
to
use
le-manager
programs
to
a
v
oid
t
yping
an
ything.
With
a
mouse
y
ou
can
clic
k
y
our
w
a
y
through
directories
and
les
without
ha
ving
to
t
yp
e
an
ything
(e.g.
the
fmgr
or
tkdesk
programs).
More
exp
erienced
users
generally
nd
this
to
b
e
slo
w
and
tedious
after
a
while
and
prefer
to
use
written
commands.
Unix
has
man
y
short
cuts
and
k
eyb
oard
features
whic
h
mak
e
t
yp
ed
commands
extremely
fast
and
m
uc
h
more
p
o
w
erful
than
use
of
the
mouse.
If
y
ou
come
from
a
DOS
en
vironmen
t,
the
unix
commands
can
b
e
a
little
strange.
Because
they
stem
from
an
era
when
k
eyb
oards
had
to
b
e
hit
with
hammer
force,
and
mac
hines
w
ere
v
ery
slo
w,
the
command
names
are
generally
as
short
as
p
ossible,
so
they
seem
prett
y
cryptic.
Some
familar
ones
whic
h
DOS
b
orro
w
ed
from
unix
include,
cd
mkdir
whic
h
c
hange
to
a
new
directory
and
mak
e
a
new
directory
resp
ectiv
ely
.
T
o
list
the
les
in
the
curren
t
directory
y
ou
use,
ls
T
o
rename
a
le,
y
ou
`mo
v
e'
it:
mv
old-name
new-name
.
T
ext
editing
and
w
ord
pro
cessing
T
ext
editing
is
one
of
the
things
whic
h
p
eople
sp
end
most
time
doing
on
an
y
computer.
It
is
imp
ortan
t
to
distingiush
text
editing
from
w
ord
pro
cessing.
On
a
PC
or
MacIn
tosh,
y
ou
are
p
erhaps
used
to
W
ord
or
W
ordP
erfect
for
writing
do
cumen
ts.
Unix
has
a
W
ord-lik
e
program
called
lyx,
but
for
the
most
part
Unix
users
do
not
use
w
ord
pro
cessors.
It
is
more
common
in
the
unix
comm
unit
y
to
write
all
do
cumen
ts,
regardless
of
whether
they
are
letters,
b
o
oks
or
computer
programs,
using
a
non-formatting
text
editor.
(Unix
w
ord
pro
cessors
lik
e
Framemaker
do
exist,
but
they
are
v
ery
exp
ensiv
e.
A
v
ersion
of
MS-W
ord
also
exists
for
some
unices.)
Once
y
ou
ha
v
e
written
a
do
cumen
t
in
a
normal
text
editor,
y
ou
call
up
a
text
formatter
to
mak
e
it
prett
y
.
Y
ou
migh
t
think
this
strange,
but
the
truth
of
the
matter
is
that
this
t
w
o-stage
pro
cess
giv
es
y
ou
the
most
p
o
w
er
and
exibilt
y|and
that
is
what
most
unix
folks
lik
e.
F
or
writing
programs,
or
an
ything
else,
y
ou
edit
a
le
b
y
t
yping:


The
unix
programming
en
vironmen
t
emacs
myfile
emacs
is
one
of
dozens
of
text-editors.
It
is
not
the
simplest
or
most
in
tuitiv
e,
but
it
is
the
most
p
o
w
erful
and
if
y
ou
are
going
to
sp
end
time
learning
an
editor,
it
w
ouldn't
do
an
y
harm
to
mak
e
it
this
one.
Y
ou
could
also
clic
k
on
emacs'
icon
if
y
ou
are
relying
on
a
windo
w
system.
Emacs
is
almost
certainly
the
most
p
o
w
erful
text
editor
that
exists
on
an
y
system.
It
is
not
a
w
ord-pro
cessor,
it
not
for
formatting
prin
ted
do
cumen
ts,
but
it
can
b
e
link
ed
to
almost
an
y
other
program
in
order
to
format
and
prin
t
text.
It
con
tains
a
p
o
w
erful
programming
language
and
has
man
y
in
telligen
t
features.
W
e
shall
not
go
in
to
the
details
of
do
cumen
t
formatting
in
this
b
o
ok,
but
only
men
tion
that
programs
lik
e
troff
and
Tex
or
Latex
are
used
for
this
purp
ose
to
obtain
t
ypset-qualit
y
prin
ting.
T
ext
formatting
is
an
area
where
Unix
folks
do
things
dieren
tly
to
PC
folks.

Chapter
:
The
login
en
vironmen
t
	

The
login
en
vironmen
t
Unix
b
egan
as
a
timesharing
mainframe
system
in
the
sev
en
ties,
when
the
only
terminals
a
v
ailable
w
ere
text
based
teletyp
e
terminals
or
tty-s.
Later,
the
Massac
h
usetts
Institute
of
T
ec
hnology
(MIT)
dev
elop
ed
the
X-windo
ws
in
terface
whic
h
is
no
w
a
standard
across
UNIX
platforms.
Because
of
this
history
,
the
X-windo
w
system
w
orks
as
a
fron
t
end
to
the
standard
UNIX
shell
and
in
terface,
so
to
understand
the
user
en
vironmen
t
w
e
m
ust
rst
understand
the
shell.
.
Shells
A
shell
is
a
command
in
terpreter.
In
the
early
da
ys
of
unix,
a
shell
w
as
the
only
w
a
y
of
issuing
commands
to
the
system.
No
w
ada
ys
man
y
windo
w-based
application
programs
pro
vide
men
us
and
buttons
to
p
erform
simple
commands,
but
the
UNIX
shell
remains
the
most
p
o
w
erful
and
exible
w
a
y
of
in
teracting
with
the
system.
After
logging
in
and
en
tering
a
passw
ord,
the
unix
pro
cess
init
starts
a
shell
for
the
user
logging
in.
Unix
has
sev
eral
dieren
t
kinds
of
shell
to
c
ho
ose
from,
so
that
eac
h
user
can
pic
k
his/her
fa
v
ourite
command
in
terface.
The
t
yp
e
of
shell
whic
h
the
system
starts
at
login
is
determined
b
y
the
user's
en
try
in
the
p
asswd
database.
On
most
systems,
the
standard
login
shell
is
a
v
arian
t
of
the
C-shell.
Shells
pro
vide
facilities
and
commands
whic
h

Start
and
stop
pro
cesses
(programs)

Allo
w
t
w
o
pro
cesses
to
comm
unicate
through
a
pip
e

Allo
w
the
user
to
redirect
the
o
w
of
input
or
output

Allo
w
simple
command
line
editing
and
command
history

Dene
aliases
to
frequen
tly
used
commands

Dene
global
"en
vironmen
t"
v
ariables
whic
h
are
used
to
congure
the
default
b
eha
viour
of
a
v
ariet
y
of
programs.
These
lie
in
an
"asso
ciated
arra
y"
for
eac
h
pro
cess
and
ma
y
b
e
seen
with
the
`env'
command.
En
vironmen
t
v
ariables
are
inherited
b
y
all
pro
cesses
whic
h
are
started
from
a
shell.

Pro
vide
wildcard
expansion
(jok
er
notation)
of
lenames
using
`*,?,[]'

Pro
vide
a
simple
script
language,
with
tests
and
lo
ops,
so
that
users
can
com
bine
system
programs
to
create
new
programs
of
their
o
wn.

Change
and
remem
b
er
the
lo
cation
of
the
curren
t
w
orking
directory
,
or
lo
cation
within
the
le
hierarc
h
y
.
The
shell
do
es
not
con
tain
an
y
more
sp
ecic
functions|all
other
commands,
suc
h
as
programs
whic
h
list
les
or
create
directories
etc.,
are
executable
programs
whic
h
are
in-
dep
enden
t
of
the
shell.
When
y
ou
t
yp
e
`ls',
the
shell
lo
oks
for
the
executable
le
called
`ls'
in
a
sp
ecial
list
of
directories
called
the
c
ommand
p
ath
and
attempts
to
start
this
pro-
gram.
This
allo
ws
suc
h
programs
to
b
e
dev
elop
ed
and
replaced
indep
enden
tly
of
the
actual
command
in
terpreter.
Eac
h
shell
whic
h
is
started
can
b
e
customized
and
congured
b
y
editing
a
setup
le.
F
or
the
C-shell
and
its
v
arian
ts
this
le
is
called
`.cshrc',
and
for
the
Bourne
shell
and
its
v
arian
ts
it
is
called
`.profile'.
(Note
that
les
whic
h
b
egin
with
leading
dots
are

0
The
unix
programming
en
vironmen
t
not
normally
visible
with
the
`ls'
command.
Use
`ls
-a'
to
view
these.)
An
y
commands
whic
h
are
placed
in
these
les
are
in
terpreted
b
y
the
shell
b
efore
the
rst
command
prompt
is
issued.
These
les
are
t
ypically
used
to
dene
a
command
searc
h
path
and
terminal
c
haracteristics.
On
e
ach
new
c
ommand
line
you
c
an
use
the
cursor
keys
to
e
dit
the
line.
The
up-arr
ow
br
owses
b
ack
thr
ough
e
arlier
c
ommands.
CTRL-a
takes
you
to
the
start
of
the
line.
CTRL-e
takes
you
to
the
end
of
the
line.
The
h
T
AB
i
c
an
b
e
use
d
to
save
typing
with
the
`c
ompletion
'
facility
Se
e
Se
ction
.
[Command/lename
c
ompletion],
p
age
.
..
Shell
commands
generally
Shell
commands
are
commands
lik
e
cp,
mv,
passwd,
cat,
more,
less,
cc,
grep,
ps
etc..
V
ery
few
commands
are
actually
built
in
to
the
shell
command
line
in
terpreter,
in
the
w
a
y
that
they
are
in
DOS
{
commands
are
mostly
programs
whic
h
exist
as
les.
When
w
e
t
yp
e
a
command,
the
shell
searc
hes
for
a
program
with
the
same
name
and
tries
to
execute
it.
The
le
m
ust
b
e
executable,
or
a
Command
not
found
error
will
result.
T
o
see
what
actually
happ
ens
when
y
ou
t
yp
e
a
command
lik
e
gcc,
try
t
yping
in
the
follo
wing
C-shell
commands
dir
e
ctly
into
a
C-shel
l.
(W
e
shall
discuss
these
commands
so
on.)
foreach
dir
(
$path
)
#
for
every
directory
in
the
list
path
if
(
-x
$dir/gcc
)
then
#
if
the
file
is
executable
echo
Found
$dir/gcc
#
Print
message
found!
break
#
break
out
of
loop
else
echo
Searching
$dir/gcc
endif
end
The
output
of
this
command
is
something
lik
e
Searching
/usr/lang/gcc
Searching
/usr/openwin/bin/gcc
Searching
/usr/openwin/bin/xview/
gcc
Searching
/physics/lib/framemaker
/bin
/gcc
Searching
/physics/motif/bin/gcc
Searching
/physics/mutils/bin/gcc
Searching
/physics/common/scripts
/gcc
Found
/physics/bin/gcc
If
y
ou
t
yp
e
echo
$path
y
ou
will
see
the
en
tire
list
of
directories
whic
h
are
searc
hed
b
y
the
shell.
If
w
e
had
left
out
the
`break'
command,
w
e
migh
t
ha
v
e
disco
v
ered
that
UNIX
often
has
sev
eral
programs
with
the
same
name,
in
dieren
t
directories!
F
or
example,
/bin/mail
/usr/ucb/mail
/bin/Mail
/bin/make
/usr/local/bin/make.

Chapter
:
The
login
en
vironmen
t

Also,
dieren
t
v
ersions
of
unix
ha
v
e
dieren
t
con
v
en
tions
for
placing
the
commands
in
directories,
so
the
path
list
needs
to
b
e
dieren
t
for
dieren
t
t
yp
es
of
unix
mac
hine.
In
the
C-shell
a
few
basic
commands
lik
e
cd
and
kill
are
built
in
to
the
shell
(as
in
DOS).
Y
ou
can
nd
out
whic
h
directory
a
command
is
stored
in
using
the
which
command.
F
or
example
nexus%
which
cd
cd:
shell
built-in
command.
nexus%
which
cp
/bin/cp
nexus%
which
only
searc
hes
the
directories
in
$path
and
quits
after
the
rst
matc
h,
so
if
there
are
sev
eral
commands
with
the
same
name,
y
ou
will
only
see
the
rst
of
them
using
whic
h.
Finally
,
in
the
C-shell,
the
which
command
is
built
in.
In
the
Bourne
shell
it
is
a
program:
nexus%
which
which
which:
shell
built-in
command.
nexus%
sh
$
which
which
/bin/which
$
exit
nexus%
T
ak
e
a
lo
ok
at
the
script
/usr/ucb/which.
It
is
a
script
written
in
the
C-shell.
..
En
vironmen
t
and
shell
v
ariables
En
vironmen
t
v
ariables
are
v
ariables
whic
h
the
shell
k
eeps.
They
are
normally
used
to
congure
the
b
eha
viour
of
utilit
y
programs
lik
e
lpr
(whic
h
sends
a
le
to
the
prin
ter)
and
mail
(whic
h
reads
and
sends
mail)
so
that
sp
ecial
options
do
not
ha
v
e
to
b
e
t
yp
ed
in
ev
ery
time
y
ou
run
these
programs.
An
y
program
can
read
these
v
ariables
to
nd
out
ho
w
y
ou
ha
v
e
congured
y
our
w
orking
en
vironmen
t.
W
e
shall
meet
these
v
ariables
frequen
tly
.
Here
are
some
imp
ortan
t
v
ariables
PATH
#
The
search
path
for
shell
commands
(sh)
TERM
#
The
terminal
type
(sh
and
csh)
DISPLAY
#
X
-
the
name
of
your
display
LD_LIBRARY_PATH
#
Path
to
search
for
object
and
shared
libraries
HOST
#
Name
of
this
unix
host
PRINTER
#
Default
printer
(lpr)
HOME
#
The
path
to
your
home
directory
(sh)
path
#
The
search
path
for
shell
commands
(csh)
term
#
The
terminal
type
(csh)
noclobber
#
See
below
under
redirection
prompt
#
The
default
prompt
for
csh
home
#
The
path
to
your
home
directory
(csh)


The
unix
programming
en
vironmen
t
These
v
ariables
fall
in
to
t
w
o
groups.
T
raditionally
the
rst
group
alw
a
ys
ha
v
e
names
in
upp
ercase
letters
and
are
called
envir
onment
variables,
whereas
v
ariables
in
the
second
group
ha
v
e
names
with
lo
w
ercase
letters
and
are
called
shel
l
variables{
but
this
is
only
a
con
v
en
tion.
The
upp
ercase
v
ariables
are
glob
al
variables,
whereas
the
lo
w
er
case
v
ariables
are
lo
c
al
variables.
Lo
cal
v
ariables
are
not
dened
for
programs
or
sub-shells
started
b
y
the
curren
t
shell,
while
global
v
ariables
are
inherited
b
y
all
sub-shells.
The
Bourne-shell
and
the
C-shell
use
these
con
v
en
tions
dieren
tly
and
not
alw
a
ys
con-
sisten
tly
.
Y
ou
will
see
ho
w
to
dene
these
b
elo
w.
F
or
no
w
y
ou
just
ha
v
e
to
kno
w
that
y
ou
can
use
the
follo
wing
commands
from
the
C-shell
to
list
these
v
ariables.
The
command
env
can
b
e
used
in
either
C-shell
or
Bourne
shell
to
see
all
of
the
dened
en
vironmen
t
v
ariables.
..
Wildcards
Sometimes
y
ou
w
an
t
to
b
e
able
to
refer
to
sev
eral
les
in
one
go.
F
or
instance,
y
ou
migh
t
w
an
t
to
cop
y
all
les
ending
in
`.c'
to
a
new
directory
.
T
o
do
this
one
uses
wildc
ar
ds.
Wildcards
are
c
haracters
lik
e
*
?
whic
h
stand
for
an
y
c
haracter
or
group
of
c
haracters.
In
card
games
the
jok
er
is
a
`wild
card'
whic
h
can
b
e
substituted
for
an
y
other
card.
Use
of
wildcards
is
also
called
lename
substitution
in
the
unix
man
uals,
in
the
sections
on
sh
and
csh.
The
wildcard
sym
b
ols
are,
`?'
Matc
h
single
c
haracter.
e.g.
ls
/etc/rc.????
`*'
Matc
h
an
y
n
um
b
er
of
c
haracters.
e.g.
ls
/etc/rc.*
`[...]'
Matc
h
an
y
c
haracter
in
a
list
enclosed
b
y
these
brac
k
ets.
e.g.
ls
[abc].C
Here
are
some
examples
and
explanations.
`/etc/rc.????'
Matc
h
all
les
in
/etc
whose
rst
three
c
haracters
are
rc.
and
are

c
haracters
long.
`*.c'
Matc
h
all
les
ending
in
`.c'
i.e.
all
C
programs.
`*.[Cc]'
List
all
les
ending
on
`.c'
or
`.C'
i.e.
all
C
and
C++
programs.
`*.[a-z]'
Matc
h
an
y
le
ending
in
.a,
.b,
.c,
...
up
to
.z
etc.
It
is
imp
ortan
t
to
understand
that
the
shel
l
exp
ands
wildc
ar
ds.
When
y
ou
t
yp
e
a
command,
the
program
is
not
in
v
ok
ed
with
an
argumen
t
that
con
tains
*
or
?.
The
shell
expands
the
sp
ecial
c
haracters
rst
and
in
v
ok
es
commands
with
the
en
tire
list
of
les
whic
h
matc
h
the
patterns.
The
programs
nev
er
see
the
wildcard
c
haracters,
only
the
list
of
les
they
stand
for.
T
o
see
this
in
action,
y
ou
can
t
yp
e
echo
/etc/rc.*
whic
h
giv
es
/etc/rc
/etc/rc.boot
/etc/rc.ip
/etc/rc.local
/etc/rc.local%
/etc/rc.local~
/etc/rc.single
/etc/rc~

Chapter
:
The
login
en
vironmen
t

All
shell
commands
are
in
v
ok
ed
with
a
command
line
of
this
form.
This
has
an
imp
ortan
t
corollary
.
It
means
that
m
ultiple
renaming
c
annot
work
!
Unix
les
are
renamed
using
the
mv
command.
In
man
y
micro
computer
op
erating
sys-
tems
one
can
write
rename
*.x
*.y
whic
h
c
hanges
the
le
extension
of
all
les
ending
in
`.x'
to
the
same
name
with
a
`.y'
extension.
This
cannot
w
ork
in
unix,
b
ecause
the
shell
tries
expands
ev
erything
b
efore
passing
the
argumen
ts
to
the
command
line.
The
lo
c
al
shel
l
variable
noglob
switches
o
wildc
ar
d
exp
ansion
in
the
C
shel
l,
but
you
stil
l
c
annot
r
ename
multiple
les
using
mv.
Some
fr
e
e-softwar
e
pr
o
gr
ams
make
this
p
ossible.
..
Regular
expressions
The
wildcards
b
elong
to
the
shell.
They
are
used
for
matc
hing
lenames.
UNIX
has
a
more
general
and
widely
used
mec
hanism
for
matc
hing
strings,
this
is
through
r
e
gular
expr
essions.
Regular
expressions
are
used
b
y
the
egrep
utilit
y
,
text
editors
lik
e
ed,
vi
and
emacs
and
sed
and
awk.
They
are
also
used
in
the
C
programming
language
for
matc
hing
input
as
w
ell
as
in
the
P
erl
programming
language
and
lex
tok
enizer.
Here
are
some
examples
using
the
egrep
command
whic
h
prin
t
lines
from
the
le
/etc/rc
whic
h
matc
h
certain
conditions.
The
con
truction
is
part
of
egrep.
Ev
erything
in
b
et
w
een
these
sym
b
ols
is
a
regular
expression.
Notice
that
sp
ecial
shell
sym
b
ols
!
*
&
ha
v
e
to
b
e
preceded
with
a
bac
kslash
\
in
order
to
prev
en
t
the
shell
from
expanding
them!
#
Print
all
lines
beginning
with
a
comment
#
egrep
'(^#)'
/etc/rc
#
Print
all
lines
which
DON'T
begin
with
#
egrep
'(^[^#])'
/etc/rc
#
Print
all
lines
beginning
with
e,
f
or
g.
egrep
'(^[efg])'
/etc/rc
#
Print
all
lines
beginning
with
uppercase
egrep
'(^[A-Z])'
/etc/rc
#
Print
all
lines
NOT
beginning
with
uppercase
egrep
'(^[^A-Z])'
/etc/rc
#
Print
all
lines
containing
!
*
&
egrep
'([\!\*\&])'
/etc/rc


The
unix
programming
en
vironmen
t
#
All
lines
containing
!
*
&
but
not
starting
#
egrep
'([^#][\!\*\&])'
/etc/rc
Regular
expressions
are
made
up
of
the
follo
wing
`atoms'.
These
examples
assume
that
the
le
`/etc/rc'
exists.
If
it
do
esn't
exist
on
the
mac
hine
y
ou
are
using,
try
to
nd
the
equiv
alen
t
b
y
,
for
instance,
replacing
/etc/rc
with
/etc/rc*
whic
h
will
try
to
nd
a
matc
h
b
eginning
with
the
rc.
`.'
Matc
h
an
y
single
c
haracter
except
the
end
of
line.
`^'
Matc
h
the
b
eginning
of
a
line
as
the
rst
c
haracter.
`$'
Matc
h
end
of
line
as
last
c
haracter.
`[..]'
Matc
h
an
y
c
haracter
in
the
list
b
et
w
een
the
square
brac
k
ets.(see
b
elo
w).
`*'
Matc
h
zero
or
more
o
ccurrances
of
the
preceding
expression.
`+'
Matc
h
one
or
more
o
ccurrences
of
the
preceding
expression.
`?'
Matc
h
zero
or
one
o
ccurrance
of
the
preceding
expression.
Y
ou
can
nd
a
complete
list
in
the
unix
man
ual
pages.
The
square
brac
k
ets
ab
o
v
e
are
used
to
dene
a
class
of
c
haracters
to
b
e
matc
hed.
Here
are
some
examples,

If
the
square
brac
k
ets
con
tain
a
list
of
c
haracters,
$[a-z]$
then
a
single
o
ccurrance
of
an
y
c
haracter
in
the
list
will
matc
h
the
regular
expression:
in
this
case
an
y
lo
w
ercase
letter
or
the
n
um
b
ers
,

and
.

If
the
rst
c
haracter
in
the
brac
k
ets
is
the
caret
sym
b
ol
`^'
then
an
y
c
haracter
exc
ept
those
in
the
list
will
b
e
matc
hed.

Normally
a
dash
or
min
us
sign
`-'
means
a
range
of
c
haracters.
If
it
is
the
rst
c
haracter
after
the
`['
or
after
`[^'
then
it
is
treated
literally
.
..
Nested
shell
commands
and
\
The
bac
kw
ards
ap
ostrophes
`...`
can
b
e
used
in
all
shells
and
also
in
the
programming
language
P
erl.
When
these
are
encoun
tered
in
a
string
the
shell
tries
to
execute
the
com-
mand
inside
the
quotes
and
replace
the
quoted
expression
b
y
the
result
of
that
command.
F
or
example:
unix%
echo
"This
system's
kernel
type
is
`/bin/file
/vmunix`"
This
system's
kernel
type
is
/vmunix:
sparc
executable
not
stripped
unix%
foreach
file
(
`ls
/etc/rc*`
)
?
echo
I
found
a
config
file
$file
?
echo
Its
type
is
`/bin/file
$file`
?
end
I
found
a
config
file
/etc/rc
Its
type
is
/etc/rc:
executable
shell
script
I
found
a
config
file
/etc/rc.boot
Its
type
is
/etc/rc.boot:
executable
shell
script

Chapter
:
The
login
en
vironmen
t

I
found
a
config
file
/etc/rc.ip
Its
type
is
/etc/rc.ip:
executable
shell
script
I
found
a
config
file
/etc/rc.local
Its
type
is
/etc/rc.local:
ascii
text
I
found
a
config
file
/etc/rc.local~
Its
type
is
/etc/rc.local~:
ascii
text
I
found
a
config
file
/etc/rc.single
Its
type
is
/etc/rc.single:
executable
shell
script
I
found
a
config
file
/etc/rc~
Its
type
is
/etc/rc~:
executable
shell
script
This
is
ho
w
w
e
insert
the
result
of
a
shell
command
in
to
a
text
string
or
v
ariable.
.
UNIX
command
o
v
erview
..
Imp
ortan
t
k
eys
h
CTRL-A
i
Jump
to
start
of
line.
If
`screen'
is
activ
e,
this
prexes
all
con
trol
k
ey
com-
mands
for
`screen'
and
then
the
normal
CTRL-A
is
replaced
b
y
CTRL-a
a.
h
CTRL-C
i
In
terrupt
or
break
k
ey
.
Sends
signal

to
a
pro
cess.
h
CTRL-D
i
Signies
`EOF'
(end
of
le)
or
sho
ws
expansion
matc
hes
in
command/lename
completion
See
Section
.
[Command/lename
completion],
page
.
h
CTRL-E
i
Jump
to
end
of
line.
h
CTRL-L
i
Clear
screen
in
new
er
shells
and
in
emacs.
Same
as
`clear'
in
the
shell.
h
CTRL-Z
i
Susp
end
the
presen
t
pro
cess,
but
do
not
destro
y
it.
This
sends
signal

to
the
pro
cess.
..
Alternativ
e
shells
bash
The
Bourne
Again
shell,
an
impro
v
ed
sh.
csh
The
standard
C-shell.
jsh
The
same
as
sh,
with
C-shell
st
yle
job
con
trol.
ksh
The
Korn
shell,
an
impro
v
ed
sh.
sh
The
original
Bourne
shell.
sh
On
UL
TRIX
systems
the
standard
Bourne
shell
is
quite
stupid.
sh
corresp
onds
to
the
normal
Bourne
shell
on
these
systems.
tcsh
An
impro
v
ed
C-shell.
zsh
An
impro
v
ed
sh.


The
unix
programming
en
vironmen
t
..
Windo
w
based
terminal
em
ulators
xterm
The
standard
X
terminal
windo
w.
shelltool,
cmdtool
Op
en
windo
ws
terminals
from
Sun
Microsystems.
These
are
not
completely
X
compatible
during
cop
y/paste
op
erations.
screen
This
is
not
a
windo
w
in
itself,
but
allo
ws
y
ou
to
em
ulate
ha
ving
sev
eral
windo
ws
inside
a
single
(sa
y)
xterm
windo
w.
The
user
can
switc
h
b
et
w
een
dieren
t
win-
do
ws
and
op
en
new
ones,
but
can
only
see
one
windo
w
at
a
time
See
Section
.
[Multiple
screens],
page
.
..
Remote
shells
and
logins
rlogin
Login
on
to
a
remote
unix
system.
rsh
Op
en
a
shell
on
a
remote
system
(require
access
righ
ts).
telnet
Op
en
a
connection
to
a
remo
v
e
system
using
the
telnet
proto
col.
..
T
ext
editors
ed
An
ancien
t
line-editor.
vi
Visual
in
terface
to
ed.
This
is
the
only
"standard"
unix
text
editor
supplied
b
y
v
endors.
emacs
The
most
p
o
w
erful
UNIX
editor.
A
fully
congurable,
user
programmable
editor
whic
h
w
orks
under
X
and
on
tt
y-terminals.
xemacs
A
prett
y
v
ersion
of
emacs
for
X
windo
ws.
pico
A
tt
y-terminal
only
editor,
comes
as
part
of
the
PINE
mail
pac
k
age.
xedit
A
test
X-only
editor
supplied
with
X-windo
ws.
textedit
A
simple
X-only
editor
supplied
b
y
Sun
Microsystems.
..
File
handling
commands
ls
List
les
in
sp
ecied
directory
(lik
e
dir
on
other
systems).
cp
Cop
y
les.
mv
Mo
v
e
or
rename
les.
touch
Creates
an
empt
y
new
le
if
none
exists,
or
up
dates
date
and
time
stamps
on
existing
les.
rm,
unlink
Remo
v
e
a
le
or
link
(delete).
mkdir,
rmdir
Mak
e
or
remo
v
e
a
directory
.
A
directory
m
ust
b
e
empt
y
in
order
to
b
e
able
to
remo
v
e
it.

Chapter
:
The
login
en
vironmen
t

cat
Concatenate
or
join
together
a
n
um
b
er
of
les.
The
output
is
written
to
the
standard
output
b
y
default.
Can
also
b
e
used
to
simply
prin
t
a
le
on
screen.
lp,
lpr
Line
prin
ter.
Send
a
le
to
the
default
prin
ter,
or
the
prin
ter
dened
in
the
`PRINTER'
evironmen
t
v
ariable.
lpq,
lpstat
Sho
w
the
status
of
the
prin
t
queue.
..
File
bro
wsing
more
Sho
ws
one
screen
full
at
a
time.
P
ossibilit
y
to
searc
h
for
a
string
and
edit
the
le.
This
is
lik
e
`type
le
|
more'
in
DOS.
less
An
enhanced
v
ersion
of
more.
mc
Midnigh
t
commander,
a
free
v
ersion
of
the
`Norton
Commander'
PC
utilit
y
for
unix.
(Only
for
non-serious
UNIX
users...)
fmgr
A
windo
w
based
le
manager
with
icons
and
all
that
nonsense.
..
Ownership
and
gran
ting
access
p
ermission
chmod
Change
le
access
mo
de.
chown,
chgrp
Change
o
wner
and
group
of
a
le.
The
GNU
v
ersion
of
chown
allo
ws
b
oth
these
op
erations
to
b
e
p
erformed
together
using
the
syn
tax
chown
o
wner.group
le
.
acl
On
new
er
Unices,
Access
con
trol
lists
allo
w
access
to
b
e
gran
ted
on
a
p
er-user
basis
rather
than
b
y
groups.
..	
Extracting
from
and
rebuilding
les
cut
Extract
a
column
in
a
table
paste
Merge
sev
eral
les
so
that
eac
h
le
b
ecomes
a
column
in
a
table.
sed
A
batc
h
text-editor
for
searc
hing,
replacing
and
selecting
text
without
h
uman
in
terv
en
tion.
awk
A
prerunner
to
the
P
erl
language,
for
extracting
and
mo
difying
textles.
rmcr
Strip
carriage
return
(ASCI
I
)
c
haracters
from
a
le.
Useful
for
con
v
erting
DOS
les
to
unix.
..0
Lo
cating
les
find
Searc
h
for
les
from
a
sp
ecied
directory
using
v
arious
criteria.
locate
F
ast
searc
h
in
a
global
le
database
for
les
con
taining
a
searc
h-string.
whereis
Lo
ok
for
a
command
and
its
do
cumen
tation
on
the
system.


The
unix
programming
en
vironmen
t
..
Disk
usage.
du
Sho
w
n
um
b
er
of
blo
c
ks
used
b
y
a
le
or
les.
df
Sho
w
the
state
of
usage
for
one
or
more
disk
partitions.
..
Sho
w
other
users
logged
on
users
Simple
list
of
other
users.
finger
Sho
w
who
is
logged
on
to
this
and
other
systems.
who
List
of
users
logged
in
to
this
system.
w
Long
list
of
who
is
logged
on
to
this
system
and
what
they
are
doing.
..
Con
tacting
other
users
write
Send
a
simple
message
to
the
named
user,
end
with
h
CTRL-D
i
.
The
command
`mesg
n'
switc
hes
o
messages
receipt.
talk
In
teractiv
e
t
w
o-w
a
y
con
v
ersation
with
named
user.
irc
In
ternet
rela
y
c
hat.
A
conferencing
system
for
realtime
m
ulti-user
con
v
ersa-
tions,
for
addicts
and
losers.
..
Mail
senders/readers
mail
The
standard
(old)
mail
in
terface.
Mail
Another
mail
in
terface.
elm
Electronic
Mail
program.
Lots
of
functionalit
y
but
p
o
or
supp
ort
for
m
ultimedia.
pine
Pine
Is
No-longer
Elm.
Impro
v
ed
supp
ort
for
m
ultimedia
but
v
ery
slo
w
and
rather
stupid
at
times.
Some
of
the
b
est
features
of
elm
ha
v
e
b
een
remo
v
ed!
mailtool
Sun's
op
en
windo
ws
clien
t
program.
rmail
A
mail
in
terface
built
in
to
the
emacs
editor.
netscape
mail
A
mail
in
terface
built
in
to
the
netscap
e
na
vigator.
zmail
A
commerical
mail
pac
k
age.
tkrat
A
graphical
mail
reader
whic
h
supp
orts
most
MIME
t
yp
es,
written
in
tcl/tk.
This
program
has
a
nice
feel
and
allo
ws
y
ou
to
create
a
searc
hable
database
of
old
mail
messages,
but
has
a
hop
eless
lo
c
king
mec
hanism.
..
File
transfer
ftp
The
File
T
ransfer
program
-
copies
les
to/from
a
remote
host.
ncftp
An
enhanced
ftp
for
anon
ymous
login.

Chapter
:
The
login
en
vironmen
t
	
..
Compilers
cc
The
C
compiler.
CC
The
C++
compiler.
gcc
The
GNU
C
compiler.
g++
The
GNU
C++
compiler.
ld
The
system
link
er/loader.
ar
Arc
hiv
e
library
builder.
dbx
A
sym
b
olic
debugger.
gdb
The
GNU
sym
b
olic
debugger.
xxgdb
The
GNU
debugger
with
a
windo
wn
driv
en
fron
t-end.
ddd
A
motif
based
fron
t-end
to
the
gdb
debugger.
..
Other
in
terpreted
languages
perl
Practical
extraction
an
rep
ort
language.
tcl
A
p
erl-lik
e
language
with
sp
ecial
supp
ort
for
building
user
in
terfaces
and
com-
mand
shells.
scheme
A
lisp-lik
e
extensible
scripting
language
from
GNU.
mercury
A
prolog-lik
e
language
for
articial
in
telligence.
..
Pro
cesses
and
system
statistics
ps
List
system
pro
cess
table.
vmstat
List
k
ernel
virtual-memory
statistics.
netstat
List
net
w
ork
connections
and
statistics.
rpcinfo
Sho
w
rp
c
information.
showmount
Sho
w
clien
ts
moun
ting
lo
cal
lesystems.
..	
System
iden
tit
y
uname
Displa
y
system
name
and
op
erating
system
release.
hostname
Sho
w
the
name
of
this
host.
domainname
Sho
w
the
name
of
the
lo
cal
NIS
domain.
Normally
this
is
c
hosen
to
b
e
the
same
as
the
BIND/DNS
domain,
but
it
need
not
b
e.
nslookup
In
terrogate
the
DNS/BIND
name
service
(hostname
to
IP
address
con
v
ersion).

0
The
unix
programming
en
vironmen
t
..0
In
ternet
resources
archie,
xarchie
Searc
h
the
in
ternet
ftp
database
for
les.
xrn,
fnews
Read
news
(bro
wser).
netscape,
xmosaic
Read
w
orld
wide
w
eb
(WWW)
(bro
wser).
..
T
ext
formatting
and
p
ostscript
tex,
latex
Donald
Kn
uth's
text
formatting
language,
pronounced
"tek"
(the
x
is
really
a
greek
"c
hi").
Used
widely
for
tec
hnical
publications.
Compiles
to
dvi
(device
indep
enden
t)
le
format.
texinfo
A
h
yp
ertext
do
cumen
tation
system
using
tex
and
"info"
format.
This
is
the
GNU
do
cumen
tation
system.
This
UNIX
guide
is
written
in
texinfo!!!
xdvi
View
a
tex
dvi
le
on
screen.
dvips
Con
v
ert
dvi
format
in
to
p
ostscript.
ghostview,
ghostscript
View
a
p
ostscript
le
on
screen.
..
Picture
editors
and
pro
cessors
xv
Handles,
edits
and
pro
cesses
pictures
in
a
v
ariet
y
of
standard
graphics
formats
(gif,
jpg,
ti
etc).
Use
xv
-quit
to
place
a
picture
on
y
our
ro
ot
windo
w.
xpaint
A
simple
pain
t
program.
xfig
A
line
dra
wing
gure
editor.
Pro
duces
p
ostscript,
tex,
and
a
v
ariet
y
of
other
output
formats.
xsetroot
Load
an
X-bitmap
image
in
to
the
screen
(ro
ot
windo
w)
bac
kground.
Small
images
are
tiled.
..
Miscellaneous
date
Prin
t
the
date
and
time.
ispell
Sp
elling
c
hec
k
er.
xcalc
A
graphical
calculator.
dc,bc
T
ext-based
calculators.
xclock
A
clo
c
k!
ping
Send
a
"sonar"
ping
to
see
if
another
unix
host
is
aliv
e.

Chapter
:
The
login
en
vironmen
t

.
T
erminals
In
order
to
comm
unicate
with
a
user,
a
shell
needs
to
ha
v
e
access
to
a
terminal.
Unix
w
as
designed
to
w
ork
with
man
y
dieren
t
kinds
of
terminals.
Input/output
commands
in
Unix
read
and
write
to
a
virtual
terminal.
In
r
e
ality
a
terminal
migh
t
b
e
a
text-based
T
elet
yp
e
terminal
(called
a
tty
for
short)
or
a
graphics
based
terminal;
it
migh
t
b
e
0-c
haracters
wide
or
it
migh
t
b
e
wider
or
narro
w
er.
Unix
tak
e
in
to
accoun
t
these
p
ossibilit
y
b
y
dening
a
n
um
b
er
of
instances
of
terminals
in
a
more
or
less
ob
ject
orien
ted
w
a
y
.
Eac
h
user's
terminal
has
to
b
e
congured
b
efore
cursor
based
input/output
will
w
ork
correctly
.
Normally
this
is
done
b
y
c
ho
osing
one
of
a
n
um
b
er
of
standard
terminal
t
yp
es
a
list
whic
h
is
supplied
b
y
the
system.
In
practice
the
user
denes
the
v
alue
of
the
en
vironmen
t
v
ariable
`TERM'
to
an
appropriate
name.
T
ypical
examples
are
`vt00'
and
`xterm'.
If
no
standard
setup
is
found,
the
terminal
can
alw
a
ys
b
e
congured
man
ually
using
UNIX's
most
cryptic
and
opaque
of
commands:
`stty'.
The
job
of
conguring
terminals
is
m
uc
h
easier
no
w
that
hardw
are
is
more
standard.
Users'
terminals
are
usually
congured
cen
trally
b
y
the
system
administrator
and
it
is
seldom
indeed
that
one
ev
er
has
to
c
ho
ose
an
ything
other
than
`vt00'
or
`xterm'.
.
The
X
windo
w
system
Because
UNIX
originated
b
efore
windo
wing
tec
hnology
w
as
a
v
ailable,
the
user-in
terface
w
as
not
designed
with
windo
wing
in
mind.
The
X
windo
w
system
attempts
to
b
e
lik
e
a
virtual
mac
hine
park,
running
a
dieren
t
program
in
eac
h
windo
w.
Although
the
programs
app
ear
on
one
screen,
they
ma
y
in
fact
b
e
running
on
unix
systems
an
ywhere
in
the
w
orld,
with
only
the
output
b
eing
lo
cal
to
the
user's
displa
y
.
The
standard
shell
in
terface
is
a
v
ailable
b
y
running
an
X
clien
t
application
called
`xterm'
whic
h
is
a
graphical
fron
t-end
to
the
standard
UNIX
textual
in
terface.
The
`xterm'
program
pro
vides
a
virtual
terminal
using
the
X
windo
ws
graphical
user
in
terface.
It
w
orks
in
exactly
the
same
w
a
y
as
a
tty
terminal,
except
that
standard
graphical
facilities
lik
e
cop
y
and
paste
are
a
v
ailable.
Moreo
v
er,
the
user
has
the
con
v
enience
of
b
eing
able
to
run
a
dieren
t
shell
in
ev
ery
windo
w.
F
or
example,
using
the
`rlogin'
command,
it
is
p
ossible
to
w
ork
on
the
lo
cal
system
in
one
windo
w,
and
on
another
remote
system
in
another
windo
w.
The
X-windo
w
en
vironmen
t
allo
ws
one
to
cut
and
paste
b
et
w
een
windo
ws,
regardless
of
whic
h
host
the
shell
runs
on.
..
The
comp
onen
ts
of
the
X-windo
w
system
The
X
system
is
based
on
the
clien
t-serv
er
mo
del.
Y
ou
migh
t
w
onder
wh
y
a
windo
w
system
w
ould
b
e
based
on
a
mo
del
whic
h
w
as
in
tro
duced
for
in
terpro
cess
comm
unication,
or
net
w
ork
comm
unication.
The
answ
er
is
straigh
tforw
ard.
The
designers
of
the
X
windo
w
system
realized
that
net
w
ork
comm
unication
w
as
to
b
e
the
paradigm
of
the
next
generation
of
computer
systems.
They
w
an
ted
to
design
a
system
of
windo
ws
whic
h
w
ould
enable
a
user
to
sit
at
a
terminal
in
Massac
h
usetts
and
w
ork
on
a
mac
hine
in
T
oky
o
{
and
still
b
e
able
to
get
high
qualit
y
windo
ws
displa
y
ed
on
their
terminal.
The
aim
of
X
windo
ws
from
the
b
eginning
is
to
create
a
distribute
d
windo
w
en
vironmen
t.
When
I
log
on
to
m
y
friend's
Hewlett
P
ac
k
ard
w
orkstation
to
use
the
text
editor
(b
ecause
I
don't
lik
e
the
one
on
m
y
EUNUCHS
w
orkstation)
I
w
an
t
it
to
w
ork
correctly
on
m
y
screen,


The
unix
programming
en
vironmen
t
with
m
y
k
eyb
oard
{
ev
en
though
m
y
w
orkstation
is
man
ufactured
b
y
a
dieren
t
compan
y
.
I
also
w
an
t
the
colours
to
b
e
righ
t
despite
the
fact
that
the
HP
mac
hine
uses
a
completely
dieren
t
video
hardw
are
to
m
y
mac
hine.
When
I
press
the
curly
brace
k
ey
{,
I
w
an
t
to
see
a
curly
brace,
and
not
some
hieroglyphic
b
ecause
the
HP
station
uses
a
dieren
t
k
eyb
oard.
These
are
the
problems
whic
h
X
tries
to
address.
In
a
net
w
ork
en
vironmen
t
w
e
need
a
c
ommon
window
system
whic
h
will
w
ork
on
an
y
kind
of
hardw
are,
and
hide
the
dierences
b
et
w
een
dieren
t
mac
hines
as
far
as
p
ossible.
But
it
has
to
b
e
exible
enough
to
allo
w
us
to
c
hange
all
of
the
things
w
e
don't
lik
e
{
to
c
ho
ose
our
o
wn
colours,
and
the
kind
of
windo
w
b
orders
w
e
w
an
t
etc.
Other
windo
wing
systems
(lik
e
Microsoft
windo
ws)
ignore
these
problems
and
thereb
y
lo
c
k
the
user
to
a
single
v
endors
pro
ducts
and
a
single
op
erating
system.
(That,
of
course,
is
no
acciden
t.)
The
w
a
y
X
solv
es
this
problem
is
to
use
the
clien
t
serv
er
mo
del.
Eac
h
program
whic
h
w
an
ts
to
op
en
a
windo
w
on
someb
o
dy's
compute
screen
is
a
clien
t
of
the
X
window
servic
e.
T
o
get
something
dra
wn
on
a
user's
screen,
the
clien
t
asks
a
serv
er
on
the
host
of
in
terest
to
dra
w
windo
ws
for
it.
No
clien
t
ev
er
dra
ws
an
ything
itself
{
it
asks
the
serv
er
to
do
it
on
its
b
ehalf.
There
are
sev
eral
reasons
for
this:

The
clien
ts
can
all
talk
a
common
`windo
w
language'
or
pr
oto
c
ol.
W
e
can
hide
the
dierence
b
et
w
een
dieren
t
kinds
of
hardw
are
b
y
making
the
machine-sp
e
cic
part
of
dra
wing
graphics
en
tirely
a
problem
of
implemen
ting
the
serv
er
on
the
particular
hardw
are.
When
a
new
t
yp
e
of
hardw
are
comes
along,
w
e
just
need
to
mo
dify
the
serv
er
{
none
of
the
clien
ts
need
to
b
e
mo
died.

W
e
can
con
tact
dieren
t
serv
ers
and
send
our
output
to
dieren
t
hardw
are
{
th
us
ev
en
though
a
program
is
running
on
a
CPU
in
T
oky
o,
it
can
ask
the
serv
er
in
Massac
h
usetts
to
displa
y
its
windo
w
for
it.

When
more
than
one
windo
w
is
on
a
user's
displa
y
,
it
ev
en
tually
b
ecomes
necessary
to
mo
v
e
the
windo
ws
around
and
then
gure
out
whic
h
windo
ws
are
on
top
of
whic
h
other
windo
ws
etc.
If
all
of
the
dra
wing
information
is
k
ept
in
a
serv
er,
it
is
straigh
tforw
ard
to
w
ork
out
this
information.
If
ev
ery
clien
t
drew
where
it
w
an
ted
to,
it
w
ould
b
e
imp
ossible
to
kno
w
whic
h
windo
w
w
as
supp
osed
to
b
e
on
top
of
another.
In
X,
the
windo
w
manager
is
a
dieren
t
program
to
the
serv
er
whic
h
do
es
the
dra
wing
of
graphics
{
but
the
clien
t-serv
er
idea
still
applies,
it
just
has
one
more
piece
to
its
puzzle.
..
Ho
w
to
set
up
X
windo
ws
The
X
windo
ws
system
is
large
and
complex
and
not
particularly
user
friendly
.
When
y
ou
log
in
to
the
system,
X
reads
t
w
o
les
in
y
our
home
directory
whic
h
decide
whic
h
applications
will
b
e
started
what
they
will
lo
ok
lik
e.
The
les
are
called
.Xsession
This
le
is
a
shell
script
whic
h
starts
up
a
n
um
b
er
of
applications
as
bac
kground
pro
cesses
and
exits
b
y
calling
a
windo
w
manager.
Here
is
a
simple
example
le
#!/bin/csh
#
#
.xsession
file
#
#

Chapter
:
The
login
en
vironmen
t

setenv
PATH
/usr/bin:/bin:/local/gn
u/bi
n:/u
sr/
XR
/bi
n
#
#
List
applications
here,
with
&
at
the
end
#
so
they
run
in
the
background
#
xterm
-T
NewTitle
-sl
000
-geometry
	0x++0
-sb
&
xclock
&
xbiff
-geometry
0x0+0+0
&
#
Start
a
window
manager.
Exec
replaces
this
script
with
#
the
fvwm
process,
so
that
it
doesn't
exist
as
a
separate
#
(useless)
process.
exec
/local/bin/fvwm
.Xdefaults
This
le
sp
ecies
all
of
the
resources
whic
h
X
programs
use.
It
can
b
e
used
to
c
hange
the
colours
used
b
y
applications,
or
fon
t
t
yp
es
etc.
The
sub
ject
of
X-rescources
is
a
large
one
and
w
e
don't
ha
v
e
time
for
it
here.
Here
is
a
simple
example,
whic
h
sho
ws
ho
w
y
ou
can
mak
e
y
our
o
v
er-brigh
t
xterm
and
emacs
windo
ws
less
brigh
t
grey
shade.
xterm*background:
LightGrey
Emacs*background:
grey	
Xemacs*background:
grey	
..
X
displa
ys
and
authorit
y
In
the
terminology
used
b
y
X,
ev
ery
clien
t
program
has
to
con
tact
a
display
in
order
to
op
en
a
windo
w.
A
displa
y
is
a
virtual
screen
whic
h
is
created
b
y
the
X
serv
er
on
a
particular
host.
X
can
create
sev
eral
separate
displa
ys
on
a
giv
en
host,
though
most
mac
hines
only
ha
v
e
one.
When
an
X
clien
t
program
w
an
ts
to
op
en
a
windo
w,
it
lo
oks
in
the
UNIX
en
vironmen
t
v
ariable
`DISPLAY'
for
the
IP
address
of
a
host
whic
h
has
an
X
serv
er
it
can
con
tact.
F
or
example,
if
w
e
wrote
setenv
DISPLAY
myhost:0
the
clien
t
w
ould
try
to
con
tact
the
X
serv
er
on
`m
yhost'
and
ask
for
a
windo
w
on
displa
y
n
um
b
er
zero
(the
usual
displa
y).
If
w
e
wrote
setenv
DISPLAY
	..0.:0
the
clien
t
w
ould
try
to
op
en
displa
y
zero
on
the
X
serv
er
at
the
host
with
the
IP
address
`	..0.'.
Clearly
there
m
ust
b
e
some
kind
of
securit
y
mec
hanism
to
prev
en
t
just
an
yb
o
dy
from
op
ening
windo
ws
on
someone's
displa
y
.
X
has
t
w
o
suc
h
mec
hanisms:
xhost
This
mec
hanism
is
no
w
obsolete.
The
`xhost'
command
is
used
to
dene
a
list
of
hosts
whic
h
are
allo
w
ed
to
op
en
windo
ws
on
the
user's
displa
y
.
It
cannot


The
unix
programming
en
vironmen
t
destinguish
b
et
w
een
individual
users.
i.e.
the
command
xhost
yourhost
w
ould
allo
w
anyone
using
y
ourhost
to
access
the
lo
cal
displa
y
.
This
mec
hanism
is
only
presen
t
for
bac
kw
ard
compatibilit
y
with
early
v
ersions
of
X
windo
ws.
Normally
one
should
use
the
command
xhost
-
to
exclude
all
others
from
accessing
the
displa
y
.
Xauthority
The
Xauthorit
y
mec
hanism
has
replaced
the
xhost
sc
heme.
It
pro
vides
a
secu-
rit
y
mec
hanism
whic
h
can
distinguish
individual
users,
not
just
hosts.
In
order
for
a
user
to
op
en
a
windo
w
on
a
displa
y
,
he/she
m
ust
ha
v
e
a
tic
k
et|called
a
"magic
co
okie".
This
is
a
binary
le
called
`.Xauthority'
whic
h
is
created
in
the
user's
home
directory
when
he/she
rst
starts
the
X-windo
ws
system.
An
y-
one
who
do
es
not
ha
v
e
a
recen
t
cop
y
of
this
le
cannot
op
en
windo
ws
or
read
the
displa
y
of
the
user's
terminal.
This
mec
hanism
is
based
on
the
idea
that
the
user's
home
directory
is
a
v
ailable
via
NFS
on
all
hosts
he/she
will
log
on
to,
and
th
us
the
o
wner
of
the
displa
y
will
alw
a
ys
ha
v
e
access
to
the
magic
co
okie,
and
will
therefore
alw
a
ys
b
e
able
to
op
en
windo
ws
on
the
displa
y
.
Other
users
m
ust
obtain
a
cop
y
of
the
le
in
order
to
op
en
windo
ws
there.
The
command
xauth
is
an
in
teractiv
e
utilit
y
used
for
con
trolling
the
con
ten
ts
of
the
`.Xauthority'
le.
See
the
`xauth'
man
ual
page
for
more
information.
.
Multiple
screens
The
windo
w
paradigm
has
b
een
v
ery
successful
in
man
y
w
a
ys,
but
an
y
one
who
has
used
a
windo
w
system
kno
ws
that
the
screen
is
simply
not
big
enough
for
all
the
windo
ws
one
w
ould
lik
e!
Unix
has
sev
eral
solutions
to
this
problem.
One
solution
is
to
attac
h
sev
eral
ph
ysical
screens
to
a
terminal.
The
X
windo
w
system
can
supp
ort
an
y
n
um
b
er
of
ph
ysical
screens
of
dieren
t
t
yp
es.
A
graphical
designer
migh
t
w
an
t
a
high
resolution
colour
screen
for
dra
wing
and
a
blac
k
and
white
screen
for
writing
text,
for
instance.
The
disadv
an
tage
with
this
metho
d
is
the
cost
of
the
hardw
are.
A
c
heap
er
solution
is
to
use
a
windo
w
manager
suc
h
as
`fwvm'
whic
h
creates
a
virtual
screen
of
unlimited
size
on
a
single
monitor.
As
the
mouse
p
oin
ter
reac
hes
the
edge
of
the
true
screen,
the
windo
w
manager
replaces
the
displa
y
with
a
new
"blank
screen"
in
whic
h
to
place
windo
ws.
A
miniaturized
image
of
the
windo
ws
on
a
con
trol
panel
acts
as
a
map
whic
h
mak
es
it
p
ossible
to
nd
the
applications
on
the
virtual
screen.
Y
et
another
p
ossibilit
y
is
to
create
virtual
displa
ys
inside
a
single
windo
w.
In
other
w
ords,
one
can
collapse
sev
eral
shell
windo
ws
in
to
a
single
`xterm'
windo
w
b
y
running
the
program
`screen'.
The
screen
command
allo
ws
y
ou
to
start
sev
eral
shells
in
a
single
windo
w
(using
h
CTRL-a
CTRL-c
i
)
and
to
switc
h
b
et
w
een
them
(b
y
t
yping
h
CTRL-a
CTRL-n
i
).
It
is
only
p
ossible
to
see
one
shell
windo
w
at
a
time,
but
it
is
still
p
ossible
to
cut
and
paste
b
et
w
een
windo
ws
and
one
has
a
considerable
sa
ving
of
space.
The
`screen'
command
also
allo
ws
y
ou
to
susp
end
a
shell
session,
log
out,
log
in
again
later
and
resume
the
session
precisely
where
y
ou
left
o.
Here
is
a
summary
of
some
useful
screen
commands:
screen
Start
the
screen
serv
er.
screen
-r
Resume
a
previously
susp
ended
screen
session
if
p
ossible.

Chapter
:
The
login
en
vironmen
t

CTRL-a
CTRL-c
Start
a
new
shell
on
top
of
the
others
(a
fresh
`screen')
in
the
curren
t
windo
w.
CTRL-a
CTRL-n
Switc
h
to
the
next
`screen'.
CTRL-a
CTRL-a
Switc
h
to
the
last
screen
used.
CTRL-a
a
When
screen
is
running,
CTRL-a
is
used
for
screen
commands
and
cannot
there-
fore
b
e
used
in
its
usual
shell
meaning
of
`jump
to
start
of
line'.
CTRL-a
a
replaces
this.
CTRL-a
CTRL-d
Detac
h
the
screen
session
from
the
curren
t
windo
w
so
that
it
can
b
e
resumed
later.
It
can
b
e
resumed
with
the
`screen
-r'
command.
CTRL-a
?
Help
screen.


The
unix
programming
en
vironmen
t

Chapter
:
Files
and
access


Files
and
access
T
o
prev
en
t
all
users
from
b
eing
able
to
access
all
les
on
the
system,
unix
records
information
ab
out
who
creates
les
and
also
who
is
allo
w
ed
to
access
them
later.
Eac
h
user
has
a
unique
username
or
lo
ginname
together
with
a
unique
user
id
or
uid.
The
user
id
is
a
n
um
b
er,
whereas
the
login
name
is
a
text
string
{
otherwise
the
t
w
o
express
the
same
information.
A
le
b
elongs
to
user
A
if
it
is
owne
d
b
y
user
A.
User
A
then
decides
whether
or
not
other
users
can
read,
write
or
execute
the
le
b
y
setting
the
pr
ote
ction
bits
or
the
p
ermission
of
the
le
using
the
command
chmod.
In
addition
to
user
iden
tities,
there
are
groups
of
users.
The
idea
of
a
group
is
that
sev
eral
named
users
migh
t
w
an
t
to
b
e
able
to
read
and
w
ork
on
a
le,
without
other
users
b
eing
able
to
access
it.
Ev
ery
user
is
a
mem
b
er
of
at
least
one
group,
called
the
lo
gin
gr
oup
and
eac
h
group
has
b
oth
a
textual
name
and
a
n
um
b
er
(gr
oup
id
).
The
uid
and
gid
of
eac
h
user
is
recorded
in
the
le
/etc/passwd
(See
c
hapter
).
Mem
b
ership
of
other
groups
is
recorded
in
the
le
/etc/group
or
on
some
systems
/etc/logingroup.
.
Protection
bits
The
follo
wing
output
is
from
the
command
ls
-lag
executed
on
a
SunOS
t
yp
e
mac
hine.
lrwxrwxrwx

root
wheel

Jun

		
bin
->
usr/bin
-r--r--r--

root
bin
0
Jun

		
boot
drwxr-sr-x

bin
staff

May

:00
dev
drwxr-sr-x
0
bin
staff
0
Jul

0:0
etc
drwxr-sr-x

root
wheel

Jun

		
export
drwx------

root
daemon

Sep

		
home
-rwxr-xr-x

root
wheel
	0	
Jun

		
kadb
lrwxrwxrwx

root
wheel

Jun

		
lib
->
usr/lib
drwxr-xr-x

root
wheel
	
Jun

		
lost+found
drwxr-sr-x

bin
staff

Jul

		
mnt
dr-xr-xr-x

root
wheel

May

:00
net
drwxr-sr-x

root
wheel

Jun

		
pcfs
drwxr-sr-x

bin
staff

Jun

		
sbin
lrwxrwxrwx

root
wheel

Jun

		
sys->kvm/sys
drwxrwxrwx

root
wheel

Jul

	:
tmp
drwxr-xr-x

root
wheel
0
Jun

		
usr
drwxr-sr-x
0
bin
staff

Jul

		
var
-rwxr-xr-x

root
daemon

Jun

		
vmunix
The
rst
column
is
a
textual
represen
tation
of
the
protection
bits
for
eac
h
le.
Column
t
w
o
is
the
n
um
b
er
of
hard
links
to
the
le
(See
exercises
b
elo
w).
The
third
and
fourth
columns
are
the
user
name
and
group
name
and
the
remainder
sho
w
the
le
size
in
b
ytes
and
the
creation
date.
Notice
that
the
directories
/bin
and
/sys
are
sym
b
olic
links
to
other
directories.
There
are
sixteen
protection
bits
for
a
UNIX
le,
but
only
t
w
elv
e
of
them
can
b
e
c
hanged
b
y
users.
These
t
w
elv
e
are
split
in
to
four
groups
of
three.
Eac
h
three-bit
n
um
b
er
corresp
onds
to
one
o
ctal
n
um
b
er.


The
unix
programming
en
vironmen
t
The
leading
four
in
visible
bits
giv
es
information
ab
out
the
t
yp
e
of
le:
is
the
le
a
plain
le,
a
dir
e
ctory
or
a
link.
In
the
output
from
ls
this
is
represen
ted
b
y
a
single
c
haracter:
-,
d
or
l.
The
next
three
bits
set
the
so-called
s-bits
and
t-bit
whic
h
are
explained
b
elo
w.
The
remaining
three
groups
of
three
bits
set
ags
whic
h
indicate
whether
a
le
can
b
e
read
`r',
written
to
`w'
or
executed
`x'
b
y
(i)
the
user
who
created
them,
(ii)
the
other
users
who
are
in
the
group
the
le
is
mark
ed
with,
and
(iii)
an
y
user
at
all.
F
or
example,
the
p
ermission
Type
Owner
Group
Anyone
d
rwx
r-x
---
tells
us
that
the
le
is
a
directory
,
whic
h
can
b
e
read
and
written
to
b
y
the
o
wner,
can
b
e
read
b
y
others
in
its
group,
but
not
b
y
an
y
one
else.
Note
ab
out
dir
e
ctories.
It
is
imp
ossible
to
cd
to
a
dir
e
ctory
unless
the
x
bit
is
set.
That
is,
dir
e
ctories
must
b
e
`exe
cutable'
in
or
der
to
b
e
ac
c
essible.
Here
are
some
examples
of
the
relationship
b
et
w
een
binary
,
o
ctal
and
the
textual
repre-
sen
tation
of
le
mo
des.
Binary
Octal
Text
00

x
00

w
00

r
0

rw-
0

r-x
-

rw-r--r--
It
is
w
ell
w
orth
b
ecoming
familiar
with
the
o
ctal
n
um
b
er
represen
tation
of
these
p
ermissions.
.
c
hmo
d
The
chmod
command
c
hanges
the
p
ermission
or
mo
de
of
a
le.
Only
the
o
wner
of
the
le
or
the
sup
eruser
can
c
hange
the
p
ermission.
Here
are
some
examples
of
its
use.
T
ry
them.
#
make
read/write-able
for
everyone
chmod
a+w
myfile
#
add
the
'execute'
flag
for
directory
chmod
u+x
mydir/
#
open
all
files
for
everyone
chmod

*
#
set
the
s-bit
on
my-dir's
group
chmod
g+s
mydir/
#
descend
recursively
into
directory
opening
all
files
chmod
-R
a+r
dir

Chapter
:
Files
and
access
	
.
Umask
When
a
new
le
gets
created,
the
op
erating
system
m
ust
decide
what
default
protection
bits
to
set
on
that
le.
The
v
ariable
umask
decides
this.
umask
is
normally
set
b
y
eac
h
user
in
his
or
her
.cshrc
le
(see
next
c
hapter).
F
or
example
umask
0
#
safe
umask
0
#
liberal
According
the
UNIX
do
cumen
tation,
the
v
alue
of
umask
is
`XOR'ed
(exclusiv
e
`OR')
with
a
v
alue
of

&
umask
for
plain
les
or

&
umask
for
directories
in
order
to
nd
out
the
standard
protection.
Actually
this
is
not
quite
true:
`umask'
only
remo
v
es
bits,
it
nev
er
sets
bits
whic
h
w
ere
not
already
set
in
.
F
or
instance
umask
Permission
0
00
(plain)
0
00
(dir)
0

(plain)
0

(dir)
The
correct
rule
for
computing
p
ermissions
is
not
X
OR
but
`NOT
AND'.
..
Making
programs
executable
A
unix
program
is
normally
executed
b
y
t
yping
its
pathname.
If
the
x
execute
bit
is
not
set
on
the
le,
this
will
generate
a
`P
ermission
denied'
error.
This
protects
the
system
from
in
terpreting
nonsense
les
as
programs.
T
o
mak
e
a
program
executable
for
someone,
y
ou
m
ust
therefore
ensure
that
they
can
execute
the
le,
using
a
command
lik
e
chmod
u+x
lename
This
command
w
ould
set
execute
p
ermissions
for
the
o
wner
of
the
le;
chmod
ug+x
lename
w
ould
set
execute
p
ermissions
for
the
o
wner
and
for
an
y
users
in
the
same
group
as
the
le.
Note
that
script
programs
m
ust
also
b
e
readable
in
order
to
b
e
executable,
since
the
shell
has
the
in
terpret
them
b
y
reading.
..
c
ho
wn
and
c
hgrp
These
t
w
o
commands
c
hange
the
o
wnership
and
the
group
o
wnership
of
a
le.
Only
the
sup
eruser
can
c
hange
the
o
wnership
of
a
le
on
most
systems.
This
is
to
prev
en
t
users
from
b
eing
able
to
defeat
quota
mec
hanisms.
(On
some
systems,
whic
h
do
not
implemen
t
quotas,
ordinary
users
can
giv
e
a
le
a
w
a
y
to
another
user
but
not
get
it
bac
k
again.)
The
same
applies
to
group
o
wnership.
..
Making
a
group
Normally
users
other
than
ro
ot
cannot
dene
their
o
wn
groups.
This
is
a
w
eakness
in
Unix
from
older
times
whic
h
no
one
seems
to
b
e
in
a
h
urry
to
c
hange.
A
t
Oslo
College,
Computer
Science,
w
e
use
a
lo
cal
solution
whereb
y
users
can
edit
a
le
to
create
their
o
wn
groups.
This
le
is
called
`/iu/nexus/local/iu/etc/iu-
gro
up'.
The
format
of
the
group
le
is:
group-name
::group-n
um
b
er
:comma-separated-list-of-users

0
The
unix
programming
en
vironmen
t
.
s-bit
and
t-bit
(stic
ky
bit)
The
s
and
t
bits
ha
v
e
sp
ecial
uses.
They
are
describ
ed
as
follo
ws.
Octal
Text
Name
000
chmod
u+s
Setuid
bit
000
chmod
g+s
Setgid
bit
000
chmod
+t
Sticky
bit
The
eect
of
these
bits
diers
for
plain
les
and
directories
and
dier
b
et
w
een
dieren
t
v
ersions
of
UNIX.
Y
ou
should
c
hec
k
the
man
ual
page
man
sticky
to
nd
out
ab
out
y
our
system!
The
follo
wing
is
common
b
eha
viour.
F
or
executable
les,
the
setuid
bit
tells
UNIX
that
r
e
gar
d
less
of
who
runs
the
pr
o
gr
am
it
should
b
e
executed
with
the
p
ermissions
and
righ
ts
of
o
wner
of
the
le.
This
is
often
used
to
allo
w
normal
users
limited
access
to
root
privileges.
A
setuid-r
o
ot
program
is
executed
as
root
for
an
y
user.
The
setgid
bit
sets
the
group
execution
righ
ts
of
the
program
in
a
similar
w
a
y
.
In
BSD
unix,
if
the
setgid
bit
is
set
on
a
directory
then
an
y
new
les
created
in
that
directory
assume
the
group
o
wnership
of
the
paren
t
directory
and
not
the
logingroup
of
the
user
who
created
the
le.
This
is
standard
p
olicy
under
system
.
A
directory
for
whic
h
the
stic
ky
bit
is
set
restrict
the
deletion
of
les
within
it.
A
le
or
directory
inside
a
directory
with
the
t-bit
set
can
only
b
e
deleted
or
renamed
b
y
its
o
wner
or
the
sup
eruser.
This
is
useful
for
directories
lik
e
the
mail
sp
o
ol
area
and
/tmp
whic
h
m
ust
b
e
writable
to
ev
ery
one,
but
should
not
allo
w
a
user
to
delete
another
user's
les.
(Ultrix)
If
an
executable
le
is
mark
ed
with
a
stic
ky
bit,
it
is
held
in
the
memory
or
system
sw
ap
area.
It
do
es
not
ha
v
e
to
b
e
fetc
hed
from
disk
eac
h
time
it
is
executed.
This
sa
v
es
time
for
frequen
tly
used
programs
lik
e
ls.
(Solaris
)
If
a
non-executable
le
is
mark
ed
with
the
stic
ky
bit,
it
will
not
b
e
held
in
the
disk
page
cac
he
{
that
is,
it
is
nev
er
copied
from
the
disk
and
held
in
RAM
but
is
written
to
directly
.
This
is
used
to
prev
en
t
certain
les
from
using
up
v
aluable
memory
.
On
some
systems
(e.g.
UL
TRIX),
only
the
sup
eruser
can
set
the
stic
ky
bit.
On
others
(e.g.
SunOS)
an
y
user
can
create
a
stic
ky
directory
.

Chapter
:
C
shell


C
shell
The
C
shell
is
the
command
in
terpreter
whic
h
y
ou
use
to
run
programs
and
utilities.
It
con
tains
a
simple
programming
language
for
writing
tailor-made
commands,
and
allo
ws
y
ou
to
join
together
unix
commands
with
pip
es.
It
is
a
congurable
en
vironmen
t,
and
once
y
ou
kno
w
it
w
ell,
it
is
the
most
ecien
t
w
a
y
of
w
orking
with
unix.
.
.cshrc
and
.login
les
Most
users
run
the
C-shell
`/bin/csh'
as
their
login
en
vironmen
t,
or
these
da
ys,
prefer-
ably
the
`tcsh'
whic
h
is
an
impro
v
ed
v
ersion
of
csh.
When
a
user
logs
in
to
a
UNIX
system
the
C-shell
starts
b
y
reading
some
les
whic
h
congure
the
en
vironmen
t
b
y
dening
v
ariables
lik
e
path.

The
le
`.cshrc'
is
searc
hed
for
in
y
our
home
directory
.
i.e.
`~/.cshrc'.
If
it
is
found,
its
con
ten
ts
are
in
terpreted
b
y
the
C-shell
as
C-shell
instructions,
b
efore
giving
y
ou
the
command
prompt

.

If
and
only
if
this
is
the
lo
gin
shel
l
(not
a
sub-shell
that
y
ou
ha
v
e
started
after
login)
then
the
le
`~/.login'
is
searc
hed
for
and
executed.
With
the
adv
en
t
of
the
X
windo
wing
system,
this
has
c
hanged
sligh
tly
.
Since
the
windo
w
system
tak
es
o
v
er
the
en
tire
login
pro
cedure,
users
nev
er
get
to
run
`login
shells',
since
the
login
shell
is
used
up
b
y
the
X
system.
On
an
X-terminal
or
host
running
X
the
`.login'
le
normally
has
no
eect.
With
some
though
t,
the
`.login'
le
can
b
e
eliminated
en
tirely
,
and
w
e
can
put
ev
ery-
thing
in
to
the
.cshrc
le.
Here
is
a
v
ery
simple
example
`.cshrc'
le.
#
#
.cshrc
-
read
in
by
every
csh
that
starts.
#
#
Set
the
default
file
creation
mask
umask
0
#
Set
the
path
set
path=(
/usr/local/bin
/usr/bin/X
/usr/ucb
/bin
/usr/bin
.
)
#
Exit
here
if
the
shell
is
not
interactive
if
(
$?prompt
==
0
)
exit
#
Set
some
variables
set
noclobber
notify
filec
nobeep
set
history=00
set
prompt="`hostname`%"

Under
HPUX,
t
w
o
other
les
are
also
read
b
y
the
C-shell.
These
are
called
`/etc/csh.login'
and
`/etc/src.csh',
enabling
some
standard
set-up
to
b
e
congured
globally
.
GNU/Lin
ux
has
a
similar
system.
On
solaris
systems
`/etc/.login'
is
read.


The
unix
programming
en
vironmen
t
set
prompt
=
"%m
%h>"
#
tcsh,
prompt
for
foreach
and
while
setenv
PRINTER
myprinter
setenv
LD_LIBRARY_PATH
/usr/lib:/usr/local/lib
:/us
r/op
enw
in/l
ib
#
Aliases
are
shortcuts
to
unix
commands
alias
passwd
yppasswd
alias
dir
'ls
-lg
\!*
|
more'
alias
sys
'ps
aux
|
more'
alias
h
history
It
is
p
ossible
to
mak
e
a
m
uc
h
more
complicated
.cshrc
le
than
this.
The
adv
en
t
of
distributed
computing
and
NFS
(Net
w
ork
le
system)
means
that
y
ou
migh
t
log
in
to
man
y
dieren
t
mac
hines
running
dieren
t
v
ersions
of
unix.
The
command
path
w
ould
ha
v
e
to
b
e
set
dieren
tly
for
eac
h
t
yp
e
of
mac
hine.
.
Dening
v
ariables
with
set,
seten
v
W
e
ha
v
e
already
seen
in
the
examples
ab
o
v
e
ho
w
to
dene
v
ariables
in
C-shell.
Let's
formalize
this.
T
o
dene
a
lo
cal
v
ariable
{
that
is,
one
whic
h
will
not
get
passed
on
to
programs
and
sub-shells
running
under
the
curren
t
shell,
w
e
write
set
local
=
"some
string"
set
myname
=
"`whoami`"
These
v
ariables
are
then
referred
to
b
y
using
the
dollar
`$'
sym
b
ol.
i.e.
The
v
alue
of
the
v
ariable
`local'
is
`$local'.
echo
$local
$myname
Global
v
ariables,
that
is
v
ariables
whic
h
all
sub-shells
inherit
from
the
curren
t
shell
are
dened
using
`setenv'
setenv
GLOBAL
"Some
other
string"
setenv
MYNAME
"`who
am
i`"
Their
v
alues
are
also
referred
to
using
the
`$'
sym
b
ol.
Notice
that
set
uses
an
`='
sign
while
`setenv'
do
es
not.
V
ariables
can
b
e
also
created
without
a
v
alue.
The
shell
uses
this
metho
d
to
switc
h
on
and
o
certain
features,
using
v
ariables
lik
e
`noclobber'
and
`noglob'.
F
or
instance
nexus%
set
flag
nexus%
if
($?flag)
echo
'Flag
is
set!'
Flag
is
set!
nexus%
unset
flag
nexus%
if
(
$?flag
)
echo
'Flag
is
set!'
nexus%
The
op
erator
`$?v
ariable
'
is
`true'
if
v
ariable
exists
and
`false'
if
it
do
es
not.
It
do
es
not
matter
whether
the
v
ariable
holds
an
y
information.
The
commands
`unset'
and
`unsetenv'
can
b
e
used
to
undene
or
delete
v
ariables
when
y
ou
don't
w
an
t
them
an
ymore.

Chapter
:
C
shell

.
Arra
ys
A
useful
facilit
y
in
the
C-shell
is
the
abilit
y
to
mak
e
arra
ys
out
of
strings
and
other
v
ari-
ables.
The
round
paren
theses
`(..)'
do
this.
F
or
example,
lo
ok
at
the
follo
wing
commands.
nexus%
set
array
=
(
a
b
c
d
)
nexus%
echo
$array[]
a
nexus%
echo
$array[]
b
nexus%
echo
$array[$#array]
d
nexus%
set
noarray
=
(
"a
b
c
d"
)
nexus%
echo
$noarray[]
a
b
c
d
nexus%
echo
$noarray[$#noarray]
a
b
c
d
The
rst
command
denes
an
arra
y
con
taining
the
elemen
ts
`a
b
c
d'.
The
elemen
ts
of
the
arra
y
are
referred
to
using
square
brac
k
ets
`[..]'
and
the
rst
elemen
t
is
`$array[]'.
The
last
elemen
t
is
`$array[]'.
NOTE:
this
is
not
the
same
as
in
C
or
C++
wher
e
the
rst
element
of
the
arr
ay
is
the
zer
oth
element!
The
sp
ecial
op
erator
`$#'
returns
the
n
um
b
er
of
elemen
ts
in
an
arra
y
.
This
giv
es
us
a
simple
w
a
y
of
nding
the
end
of
the
arra
y
.
F
or
example
nexus%
echo
$#path

nexus%
echo
"The
last
element
in
path
is
$path[$#path]"
The
last
element
in
path
is
.
T
o
nd
the
next
last
elemen
t
w
e
need
to
b
e
able
to
do
arithmetic.
W
e'll
come
bac
k
to
this
later.
.
Pip
es
and
redirection
in
csh
The
sym
b
ols
<
>
>>
<<
|
&
ha
v
e
a
sp
ecial
meaning
in
the
shell.
By
default,
most
commands
tak
e
their
input
from
the
le
`stdin'
(the
k
eyb
oard)
and
write
their
output
to
the
le
`stdout'
and
their
error
messages
to
the
le
`stderr'
(normally
,
b
oth
of
these
output
les
are
dened
to
b
e
the
curren
t
terminal
device
`/dev/tty',
or
`/dev/console').
`stdin',
`stdout'
and
`stderr',
kno
wn
collectiv
ely
as
`stdio',
can
b
e
redened
or
r
e
di-
r
e
cte
d
so
that
information
is
tak
en
from
or
sen
t
to
a
dieren
t
le.
The
output
direction
can
b
e
c
hanged
with
the
sym
b
ol
`>'.
F
or
example,
echo
testing
>
myfile
pro
duces
a
le
called
`myfile'
whic
h
con
tains
the
string
`testing'.
The
single
`>'
(greater
than)
sign
alw
a
ys
creates
a
new
le,
whereas
the
double
`>>'
app
ends
to
the
end
of
a
le,
if
it
already
exists.
So
the
rst
of
the
commands


The
unix
programming
en
vironmen
t
echo
blah
blah
>>
myfile
echo
Newfile
>
myfile
adds
a
second
line
to
`myfile'
after
`testing',
whereas
the
second
command
writes
o
v
er
`myfile'
and
ends
up
with
just
one
line
`Newle'.
No
w
supp
ose
w
e
mist
yp
e
a
command
ehco
test
>
myfile
The
command
`ehco'
do
es
not
exist
and
so
the
error
message
`ehco:
Command
not
found'
app
ears
on
the
terminal.
This
error
message
w
as
sen
t
to
stderr
{
so
ev
en
though
w
e
redirected
output
to
a
le,
the
error
message
app
eared
on
the
screen
to
tell
us
that
an
error
o
ccurred.
Ev
en
this
can
b
e
c
hanged.
`stderr'
can
also
b
e
redirected
b
y
adding
an
amp
ersand
`&'
c
haracter
to
the
`>'
sym
b
ol.
The
command
ehco
test
>&
myfile
results
in
the
le
`myfile'
b
eing
created,
con
taining
the
error
message
`ehco:
Command
not
found'.
The
input
direction
can
b
e
c
hanged
using
the
`<'
sym
b
ol
for
example
/bin/mail
mark
<
message
w
ould
send
the
le
`message'
to
the
user
`mark'
b
y
electronic
mail.
The
mail
program
tak
es
its
input
from
the
le
instead
of
w
aiting
for
k
eyb
oard
input.
There
are
some
renemen
ts
to
the
redirection
sym
b
ols.
First
of
all,
let
us
in
tro
duce
the
C-shell
v
ariable
`noclobber'.
If
this
v
ariable
is
set
with
a
command
lik
e
set
noclobber
then
les
will
not
b
e
o
v
erwritten
b
y
the
`>'
command.
If
one
tries
to
redirect
output
to
an
existing
le,
the
follo
wing
happ
ens.
unix%
set
noclobber
unix%
touch
blah
#
create
an
empty
file
blah
unix%
echo
test
>
blah
blah:
File
exists.
If
y
ou
are
nerv
ous
ab
out
o
v
erwriting
les,
then
y
ou
can
set
`noclobber'
in
y
our
`.cshrc'
le.
`noclobber'
can
b
e
o
v
erridden
using
the
pling
`!'
sym
b
ol.
So
unix%
set
noclobber
unix%
touch
blah
#
create
an
empty
file
blah
unix%
echo
test
>!
blah
writes
o
v
er
the
le
`blah'
ev
en
though
`noclobber'
is
set.
Here
are
some
other
com
binations
of
redirection
sym
b
ols
`>>'
App
end,
including
`stderr'
`>>!'
App
end,
ignoring
`noclobber'
`>>&!'
App
end
`stdout',
`stderr',
ignore
`noclobber'
`<<'
See
b
elo
w.
The
last
of
these
commands
reads
from
the
standard
input
un
til
it
nds
a
line
whic
h
con
tains
a
w
ord.
It
then
feeds
all
of
this
input
in
to
the
program
concerned.
F
or
example,

Chapter
:
C
shell

nexus%
mail
mark
<<quit
nexus
>
Hello
mark
nexus
>
Nothing
much
to
say...
nexus
>
so
bye
nexus
>
nexus
>
quit
Sending
mail...
Mail
sent!
The
mail
message
con
tains
all
the
lines
up
to,
but
not
including
`mark
er'.
This
metho
d
can
also
b
e
used
to
prin
t
text
v
erbatim
from
a
le
without
using
m
ultiple
ec
ho
commands.
Inside
a
script
one
ma
y
write:
cat
<<
"marker";
MENU
)
choice

)
choice

...
marker
The
cat
command
writes
directly
to
stdout
and
the
input
is
redirected
and
tak
en
directly
from
the
script
le.
A
v
ery
useful
construction
is
the
`pip
e'
facilit
y
.
Using
the
`|'
sym
b
ol
one
can
feed
the
`stdout'
of
one
program
straigh
t
in
to
the
`stdin'
of
another
program.
Similarly
with
`|&'
b
oth
`stdout'
and
`stderr'
can
b
e
pip
ed
in
to
the
input
of
another
program.
This
is
v
ery
con
v
enien
t.
F
or
instance,
lo
ok
up
the
follo
wing
commands
in
the
man
ual
and
try
them.
ps
aux
|
more
echo
'Keep
on
sharpenin
them
there
knives!'
|
mail
henry
vmstat

|
head
ls
-l
/etc
|
tail
Note
that
when
piping
b
oth
standard
input
and
standard
error
to
another
program,
the
t
w
o
les
do
not
mix
synchr
onously.
Often
`stderr'
app
ears
rst.
.
`tee'
and
`script'
Occasionally
y
ou
migh
t
w
an
t
to
ha
v
e
a
cop
y
of
what
y
ou
see
on
y
our
terminal
sen
t
to
a
le.
`tee'
and
`script'
do
this.
F
or
instance,
find
/
-type
l
-print
|
tee
myfile
sends
a
cop
y
of
the
output
of
`find'
to
the
le
`m
yle'.
`tee'
can
split
the
output
in
to
as
man
y
les
as
y
ou
w
an
t:
command
|
tee
le
le
....
Y
ou
can
also
c
ho
ose
to
record
the
output
an
en
tire
shell
session
using
the
`script'
command.
nexus%
script
mysession
Script
started,
file
is
mysession
nexus%
echo
Big
brother
is
scripting
you


The
unix
programming
en
vironmen
t
Big
brother
is
scripting
you
nexus%
exit
exit
Script
done,
file
is
mysession
The
le
`m
ysession'
is
a
text
le
whic
h
con
tains
a
transcript
of
the
session.
.
Command
history
The
history
feature
in
C-shell
means
that
y
ou
do
not
ha
v
e
to
t
yp
e
commands
o
v
er
and
o
v
er
again.
In
the
`tcsh'
v
ersion
of
the
C
shell,
and
the
`bash'
v
ersion
of
the
Bourne
shell,
y
ou
can
use
the
h
UP
ARR
O
W
i
k
ey
to
bro
wse
bac
k
through
the
list
of
commands
y
ou
ha
v
e
t
yp
ed
previously
.
In
the
normal
C-shell
(`csh')
there
are
three
main
commands.
`!!'
Execute
the
last
command
again.
`!-'
Execute
the
third
last
command
again.
`!'
Execute
command
n
um
b
er
.
The
rst
of
these
simply
rep
eats
the
last
command.
The
second
coun
ts
bac
kw
ards
from
the
last
command
to
three
commands-ago.
The
nal
command
giv
es
an
absolute
n
um
b
er.
The
absolute
command
n
um
b
er
can
b
e
seen
b
y
t
yping
`history'.
.
Command/lename
completion
In
the
`tcsh'
extension
of
the
C-shell,
y
ou
can
sa
v
e
hours
w
orth
of
t
yping
errors
b
y
using
the
completion
mec
hanism.
This
feature
is
based
on
the
h
T
AB
i
k
ey
.
The
idea
is
that
if
y
ou
t
yp
e
half
a
lename
and
press
h
T
AB
i
,
the
shell
will
try
to
guess
the
remainder
of
the
lename.
It
do
es
this
b
y
lo
oking
at
the
les
whic
h
matc
h
what
y
ou
ha
v
e
already
t
yp
ed
and
trying
to
ll
in
the
rest.
If
there
are
sev
eral
les
whic
h
matc
h,
the
shell
sounds
the
"b
ell"
or
b
eeps.
Y
ou
can
then
t
yp
e
h
CTRL-D
i
to
obtain
a
list
of
the
p
ossible
alternativ
es.
Here
is
an
example:
supp
ose
y
ou
ha
v
e
just
a
single
le
in
the
curren
t
directory
called
`very_long_filename',
t
yping
more
h
T
AB
i
results
in
the
follo
wing
app
earing
on
the
command
line
more
very_long_filename
The
shell
w
as
able
to
iden
tify
a
unique
le.
No
w
supp
ose
that
y
ou
ha
v
e
t
w
o
les
called
`very_long_filename'
and
`very_big_filename',
t
yping
more
h
T
AB
i
results
in
the
follo
wing
app
earing
on
the
command
line
more
very_
and
the
shell
b
eeps,
indicating
that
the
c
hoice
w
as
not
unique
and
a
decision
is
required.
Next,
y
ou
t
yp
e
h
CTRL-D
i
to
see
whic
h
les
y
ou
ah
v
e
to
c
ho
ose
from
and
the
shell
lists
them
and
returns
y
ou
to
the
command
line,
exactly
where
y
ou
w
ere.
Y
ou
no
w
c
ho
ose
`very_long_filename'
b
y
t
yping
`l'.
This
is
enough
to
uniquely
iden
tify
the
le.
Pressing
the
h
T
AB
i
k
ey
again
results
in

Chapter
:
C
shell

more
very_long_filename
on
the
screen.
As
long
as
y
ou
ha
v
e
written
enough
to
select
a
le
uniquely
,
the
shell
will
b
e
able
to
complete
the
name
for
y
ou.
Completion
also
w
orks
on
shell
commands,
but
it
is
a
little
slo
w
er
since
the
shell
m
ust
serac
h
through
all
the
directories
in
the
command
path
to
complete
commands.
.
Single
and
double
quotes
Tw
o
kinds
of
quotes
can
b
e
used
in
shell
apart
from
the
bac
kw
ard
quotes
w
e
men
tioned
ab
o
v
e.
The
essen
tial
dierence
b
et
w
een
them
is
that
certain
shell
commands
w
ork
inside
double
quotes
but
not
inside
single
quotes.
F
or
example
nexus%
echo
/etc/rc.*
/etc/rc.boot
/etc/rc.ip
/etc/rc.local
nexus%
echo
"/etc/rc.*"
/etc/rc.*
nexus%
echo
"`who
am
i`
--
my
name
is
$user
???"
nexus!mark
ttyp
Jul

0:
--
my
name
is
mark
???
nexus%
echo
'`who
am
i`
--
my
name
is
$user
???'
`who
am
i`
--
my
name
is
$user
???
W
e
see
that
the
single
quotes
prev
en
t
variable
substitution
and
sub-shel
ls.
Wildcards
do
not
w
ork
inside
either
single
or
double
quotes.
.	
Job
con
trol,
break
k
ey
,
`fg',
`bg'
So
far
w
e
ha
v
en't
men
tioned
UNIX's
abilit
y
to
m
ultitask.
In
the
Bourne
shell
(`sh')
there
are
no
facilities
for
con
trolling
sev
eral
user
pro
cesses

.
C-shell
pro
vides
some
commands
for
starting
and
stopping
pro
cesses.
These
originate
from
the
da
ys
b
efore
windo
ws
and
X,
so
some
of
them
ma
y
seem
a
little
old-fashioned.
They
are
still
v
ery
useful
nonetheless.
Let's
b
egin
b
y
lo
oking
at
the
commands
whic
h
are
true
for
an
y
shell.
Most
programs
are
run
in
the
for
e
gr
ound
or
inter
actively.
That
means
that
they
are
connected
to
the
standard
input
and
send
their
output
to
the
standard
output.
A
program
can
b
e
made
to
run
in
the
bac
kground,
if
it
do
es
not
need
to
use
the
standard
I/O.
F
or
example,
a
program
whic
h
generates
output
and
sends
it
to
a
le
could
run
in
the
bac
kground.
In
a
windo
w
en
vironmen
t,
programs
whic
h
create
their
o
wn
windo
ws
can
also
b
e
started
as
bac
kground
pro
cesses,
lea
ving
standard
I/O
in
the
shell
free.
Backgr
ound
pr
o
c
esses
run
indep
endently
of
what
you
ar
e
doing
in
the
for
e
gr
ound.

New
er
v
ersions
of
the
Bourne
shell,
lik
e
the
Korn
shell
and
Bourne-again-shell
do
ha
v
e
these
facilities.


The
unix
programming
en
vironmen
t
.	.
Unix
Pro
cesses
and
BSD
signals
A
bac
kground
pro
cess
is
started
using
the
sp
ecial
c
harcter
`&'
at
the
end
of
the
command
line.
find
/
-name
'*lib*'
-print
>&
output
&
The
nal
`&'
on
the
end
of
this
line
means
that
the
job
will
b
e
run
in
the
bac
kground.
Note
that
this
is
not
confused
with
the
redirection
op
erator
`>&'
since
it
m
ust
b
e
the
last
c
haracter
on
the
line.
The
command
ab
o
v
e
lo
oks
for
an
y
les
in
the
system
con
taining
the
string
`lib'
and
writes
the
list
of
les
to
a
le
called
`output'.
This
migh
t
b
e
a
useful
w
a
y
of
searc
hing
for
missing
libraries
whic
h
y
ou
w
an
t
to
include
in
y
our
en
vironmen
t
v
ariable
`LD_LIBRARY_PATH'.
Searc
hing
the
enire
disk
from
the
ro
ot
directory
`/'
could
tak
e
a
long
time,
so
it
pa
ys
to
run
this
in
the
bac
kground.
If
w
e
w
an
t
to
see
what
pro
cesses
are
running,
w
e
can
use
the
`ps'
command.
`ps'
without
an
y
argumen
ts
lists
all
of
y
our
pro
cesses,
i.e.
all
pro
cesses
o
wned
b
y
the
user
name
y
ou
logged
in
with.
`ps'
tak
es
man
y
options,
for
instance
`ps
auxg'
will
list
all
pro
cesses
in
gruesome
detail.
(The
"g"
is
for
group,
not
gruesome!)
`ps'
reads
the
k
ernel's
pro
cess
tables
directly
.
Pro
cesses
can
b
e
stopp
ed
and
started,
or
killed
one
and
for
all.
The
`kill'
command
do
es
this.
There
are,
in
fact,
t
w
o
v
ersions
of
the
`kill'
command.
One
of
them
is
built
in
to
the
C-shell
and
the
other
is
not.
If
y
ou
use
the
C-shell
then
y
ou
will
nev
er
care
ab
out
the
dierence.
W
e
shall
nonetheless
men
tion
the
sp
ecial
features
of
the
C-shell
built-ins
b
elo
w.
The
kill
command
tak
es
a
n
um
b
er
called
a
signal
as
an
argumen
t
and
another
n
um
b
er
called
the
pr
o
c
ess
identier
or
PID
for
short.
Kill
send
signals
to
pro
cesses.
Some
of
these
are
fatal
and
some
are
for
information
only
.
The
t
w
o
commands
kill
-

kill

are
iden
tical.
They
b
oth
send
signal

to
PID
.
This
is
the
normal
termination
signal
and
it
is
often
enough
to
stop
an
y
pro
cess
from
running.
Programs
can
c
ho
ose
to
ignore
certain
signals
b
y
trapping
signals
with
a
sp
ecial
handler.
One
signal
they
cannot
ignore
is
signal
	.
kill
-	

is
a
sure
w
a
y
of
killing
PID
.
Ev
en
though
the
pro
cess
dies,
it
ma
y
not
b
e
remo
v
ed
from
the
k
ernel's
pro
cess
table
if
it
has
a
paren
t
(see
next
section).
Here
is
the
complete
list
of
unix
signals
whic
h
the
k
ernel
send
to
pro
cesses
in
dieren
t
circumstances.

"SIGHUP",
/*
hangup
*/

"SIGINT",
/*
interrupt
*/

"SIGQUIT",
/*
quit
*/

"SIGILL",
/*
illegal
instruction
(not
reset
when
caught)
*/

"SIGTRAP",
/*
trace
trap
(not
reset
when
caught)
*/

"SIGIOT/SIGABRT",
/*
IOT
instruction
*/

"SIGEMT",
/*
EMT
instruction
*/

"SIGFPE",
/*
floating
point
exception
*/
	
"SIGKILL",
/*
kill
(cannot
be
caught
or
ignored)
*/

Chapter
:
C
shell
	
0
"SIGBUS",
/*
bus
error
*/

"SIGSEGV",
/*
segmentation
violation
*/

"SIGSYS",
/*
bad
argument
to
system
call
*/

"SIGPIPE",
/*
write
on
a
pipe
with
no
one
to
read
it
*/

"SIGALRM",
/*
alarm
clock
*/

"SIGTERM",
/*
software
termination
signal
from
kill
*/

"SIGURG",
/*
urgent
condition
on
IO
channel
*/

"SIGSTOP",
/*
sendable
stop
signal
not
from
tty
*/

"SIGTSTP",
/*
stop
signal
from
tty
*/
	
"SIGCONT",
/*
continue
a
stopped
process
*/
0
"SIGCHLD/SIGCLD",
/*
to
parent
on
child
stop
or
exit
*/

"SIGTTIN",
/*
to
readers
pgrp
upon
background
tty
read
*/

"SIGTTOU",
/*
like
TTIN
for
output
if
(tp->t_local&LTOSTOP)
*/

"SIGIO/SIGPOLL",
/*
input/output
possible
signal
*/

"SIGXCPU",
/*
exceeded
CPU
time
limit
*/

"SIGXFSZ",
/*
exceeded
file
size
limit
*/

"SIGVTALRM",
/*
virtual
time
alarm
*/

"SIGPROF",
/*
profiling
time
alarm
*/

"SIGWINCH",
/*
window
changed
*/
	
"SIGLOST",
/*
resource
lost
(eg,
record-lock
lost)
*/
0
"SIGUSR",
/*
user
defined
signal

*/

"SIGUSR"
W
e
ha
v
e
already
men
tioned

and
	
whic
h
are
the
main
signals
for
users.
Signal
,
or
`HUP'
can
b
e
sen
t
to
certain
programs
b
y
the
sup
eruser.
F
or
instance
kill
-
<inetd>
kill
-HUP
<inetd>
whic
h
forces
`inetd'
to
reread
its
conguration
le.
Sometimes
it
is
useful
to
susp
end
a
pro
cess
temp
orarily
and
then
r
estart
it
later.
kill
-
<PID>
#
suspend
process
<PID>
kill
-	
<PID>
#
resume
process
<PID>
.	.
Child
Pro
cesses
and
zom
bies
When
y
ou
start
a
pro
cess
from
a
shell,
regardless
of
whether
it
is
a
bac
kground
pro
cess
or
a
foreground
pro
cess,
the
new
pro
cess
b
ecomes
a
child
of
the
original
shell.
Remem
b
er
that
the
shell
is
just
a
unix
pro
cess
itself.
Moreo
v
er,
if
one
of
the
c
hildren
starts
a
new
pro
cess
then
it
will
b
e
a
c
hild
of
the
c
hild
(a
grandc
hild?)!
Pro
cesses
therefore
form
hier
achies.
Sev
eral
c
hildren
can
ha
v
e
a
common
p
ar
ent.
If
w
e
kill
a
paren
t,
then
(unless
the
c
hild
has
detac
hed
itself
from
the
paren
t)
all
of
its
c
hildren
die
to
o.
If
a
c
hild
dies,
the
paren
t
is
not
aected.
Sometimes
when
a
c
hild
is
killed,
it
do
es
not
die
but
b
ecomes
"defunct"
or
a
zom
bie
pro
cess.
This
means
that
the
c
hild
has
a
paren
t
whic
h
is
waiting
for
it
to
nish.
If
the
paren
t
has
not
y
et
b
een
informed
that
the
c
hild
has
died,
for
example
b
ecause
it
has
b
een
susp
ended
itself,
then
the
dead
c
hild
is
not
remo
v
ed
from
the
k
ernel's
pro
cess
table.
When
the
paren
t
w
ak
es
up
and
receiv
es
the
message
that
the
c
hild
has
terminated,
the
pro
cess
en
try
for
the
dead
c
hild
can
b
e
remo
v
ed.

0
The
unix
programming
en
vironmen
t
.	.
C-shell
builtins:
`jobs',
`kill',
`fg',`bg',
break
k
ey
No
w
let's
lo
ok
at
some
commands
whic
h
are
built
in
to
the
C-shell
for
starting
and
stopping
pro
cesses.
C-shell
refers
to
user
programs
as
`jobs'
rather
than
pro
cesses
{
but
there
is
no
real
dierence.
The
added
b
on
us
of
the
C-shell
is
that
eac
h
shell
has
a
job
numb
er
in
addition
to
its
PID.
The
job
n
um
b
ers
are
simpler
and
are
priv
ate
for
the
shell,
whereas
the
PIDs
are
assigned
b
y
the
k
ernel
and
are
often
v
ery
large
n
um
b
ers
whic
h
are
dicult
to
to
remem
b
er.
When
a
command
is
executed
in
the
shell,
it
is
assigned
a
job
n
um
b
er.
If
y
ou
nev
er
run
an
y
bac
kground
jobs
then
there
is
only
ev
er
one
job
n
um
b
er:
,
since
ev
ery
job
exits
b
efore
the
next
one
starts.
Ho
w
ev
er,
if
y
ou
run
bac
kground
tasks,
then
y
ou
can
ha
v
e
sev
eral
jobs
"activ
e"
at
an
y
time.
Moreo
v
er,
b
y
susp
ending
jobs,
C-shell
allo
ws
y
ou
to
ha
v
e
sev
eral
in
teractiv
e
programs
running
on
the
same
terminal
{
the
`fg'
and
`bg'
commands
allo
w
y
ou
to
mo
v
e
commands
from
the
bac
kground
to
the
foreground
and
vice-v
ersa.
T
ak
e
a
lo
ok
at
the
follo
wing
shell
session.
nexus%
emacs
myfile
&
[]
		0
nexus%
(
other
commands
...
,
edit
myfile
and
close
emacs
)
[]
Exit
0
emacs
myfile
When
a
bac
kground
job
is
done,
the
shell
prin
ts
a
message
at
a
suitable
momen
t
b
et
w
een
prompts.
[]
Done
emacs
myfile
This
tells
y
ou
that
job
n
um
b
er

nished
normally
.
If
the
job
exits
abnormally
then
the
w
ord
`Done'
ma
y
b
e
replaced
b
y
some
other
message.
F
or
instance,
if
y
ou
kill
the
job,
it
will
sa
y
unix%
kill
%
[]
Terminated
textedit
file
Y
ou
can
list
the
jobs
y
ou
ha
v
e
running
using
the
`jobs'
command.
The
output
lo
oks
something
lik
e
[]
+
Running
textedit
c.tex
[]
Running
textedit
glossary.tex
[]
Running
textedit
net.tex
[]
Running
textedit
overview.tex
[]
Running
textedit
perl.tex
[]
Running
textedit
shell.tex
[]
Running
textedit
sysadm.tex
[	]
Running
textedit
unix.tex
[0]
Running
textedit
x.tex
[]
-
Running
shelltool
[]
Suspended
emacs
myfile

Chapter
:
C
shell

T
o
susp
end
a
program
whic
h
y
ou
are
running
in
the
foreground
y
ou
can
t
yp
e
h
CTRL-z
i
(this
is
lik
e
sending
a
`kill
-'
signal
from
the
k
eyb
oard).

Y
ou
can
susp
end
an
y
n
um
b
er
of
programs
and
then
restart
them
one
at
a
time
using
`fg'
and
`bg'.
If
y
ou
w
an
t
job

to
b
e
restarted
in
the
foreground,
y
ou
w
ould
t
yp
e
fg
%
When
y
ou
ha
v
e
had
enough
of
job
,
y
ou
can
t
yp
e
CTRL-z
to
susp
end
it
and
then
t
yp
e
fg
%
to
activ
ate
job
.
Pro
vided
a
job
do
es
not
w
an
t
to
send
output
to
`stdout',
y
ou
can
restart
an
y
job
in
the
bac
kground,
using
a
command
lik
e.
bg
%
This
metho
d
of
working
was
useful
b
efor
e
windows
wer
e
available.
Using
`fg'
and
`bg',
you
c
an
e
dit
sever
al
les
or
work
on
sever
al
pr
o
gr
ams
without
have
to
quit
to
move
fr
om
one
to
another.
See
also
some
related
commands
for
batc
h
pro
cessing
`at',
`batch'
and
`atq',
`cron'.
NOTE:
h
CTRL-c
i
sends
a
`kill
-'
signal,
whic
h
send
a
standard
in
terrupt
message
to
a
program.
This
is
alw
a
ys
a
safe
w
a
y
to
in
terrupt
a
shell
command.
.0
Scripts
with
argumen
ts
One
of
the
useful
features
of
the
shell
is
that
y
ou
can
use
the
normal
unix
commands
to
mak
e
programs
called
scripts.
T
o
mak
e
a
script,
y
ou
just
create
a
le
con
taining
shell
commands
y
ou
w
an
t
to
execute
and
mak
e
sure
that
the
rst
line
of
the
le
lo
oks
lik
e
the
follo
wing
example.
#!/bin/csh
-f
#
#
A
simple
script:
check
for
user's
mail
#
#
set
path
=
(
/bin
/usr/ucb
)
#
Set
the
local
path
cd
/var/spool/mail
#
Change
dir
foreach
uid
(
*
)
echo
"$uid
has
mail
in
the
intray!
"
#
space
prevents
an
error!
end
The
sequence
`#!/bin/csh'
means
that
the
follo
wing
commands
are
to
b
e
fed
in
to
`/bin/csh'.
The
t
w
o
sym
b
ols
`#!'
m
ust
b
e
the
v
ery
rst
t
w
o
c
haracters
in
the
le.
The
`-f'
option
means
that
y
our
`.cshrc'
le
is
not
read
b
y
the
shell
when
it
starts
up.
The
le
con
taining
this
script
m
ust
b
e
executable
(see
`chmod')
and
m
ust
b
e
in
the
curren
t
path,
lik
e
all
other
programs.

This
do
es
not
seem
to
w
ork
in
solaris?!


The
unix
programming
en
vironmen
t
Lik
e
C
programs,
C-shell
scripts
can
accept
command
line
argumen
ts.
Supp
ose
y
ou
w
an
t
to
mak
e
a
program
to
sa
y
hello
to
some
other
users
who
are
logged
on
to
the
system.
say-hello
mark
sarah
mel
T
o
do
this
y
ou
need
to
kno
w
the
names
that
w
ere
t
yp
ed
on
the
command
line.
These
names
are
copied
in
to
an
arra
y
in
the
C-shell
called
the
ar
gument
ve
ctor,
or
`argv'.
T
o
read
these
argumen
ts,
y
ou
just
treat
`argv'
as
an
arra
y
.
#!/bin/csh
-f
#
#
Say
hello
#
foreach
name
(
$argv
)
echo
Saying
hello
to
$name
echo
"Hello
from
$user!
"
|
write
$name
end
The
elemen
ts
of
the
arra
y
can
b
e
referred
to
as
`argv[]'..`argv[$#argv]'
as
usual.
They
can
also
b
e
referred
to
as
`$'..`$'
upto
the
last
acceptable
n
um
b
er.
This
mak
es
C-shell
compatible
with
the
Bourne
shell
as
far
as
argumen
ts
are
concerned.
One
extra
ourish
in
this
metho
d
is
that
y
ou
can
also
refer
to
the
name
of
the
program
itself
as
`$0'.
F
or
example,
#!/bin/csh
-f
echo
This
is
program
$0
running
for
$user
`$argv'
represen
ts
all
the
argumen
ts.
Y
ou
can
also
use
`$*'
from
the
Bourne
shell.
.
Sub-shells
()
The
C-shell
do
es
not
allo
w
y
ou
to
dene
subroutines
or
functions,
but
y
ou
can
create
a
lo
cal
shell,
with
its
o
wn
priv
ate
v
ariables
b
y
enclosing
commands
in
paren
theses.
#!/bin/csh
cd
/etc
(
cd
/usr/bin;
ls
*
)
>
myfile
pwd
This
program
c
hanges
the
w
orking
directory
to
/etc
and
then
executes
a
subshell
whic
h
inside
the
br
ackets
c
hanges
directory
to
/usr/bin
and
lists
the
les
there.
The
output
of
this
priv
ate
shell
are
sen
t
to
a
le
`m
yle'.
A
t
the
end
w
e
prin
t
out
the
curren
t
w
orking
directory
just
to
sho
w
that
the
`cd'
command
in
brac
k
ets
had
no
eect
on
the
main
program.
Normally
b
oth
paren
theses
m
ust
b
e
on
the
same
line.
If
a
subshell
command
line
gets
to
o
long,
so
that
the
brac
k
ets
are
not
on
the
same
line,
y
ou
ha
v
e
to
use
bac
kslash
c
haracters
to
con
tin
ue
the
lines,

Chapter
:
C
shell

(
command
\
command
\
command
\
)
.
T
ests
and
conditions
No
programming
language
w
ould
b
e
complete
without
tests
and
lo
ops.
C-shell
has
t
w
o
kinds
of
decision
structure:
the
`if..then..else'
and
the
`switch'
structure.
These
are
closely
related
to
their
C
coun
terparts.
The
syn
tax
of
these
is
if
(condition)
command
if
(condition)
then
command
command..
else
command
command..
endif
switch
(string
)
case
one
:
commands
breaksw
case
t
w
o
:
commands
breaksw
...
endsw
In
the
latter
case,
no
commands
should
app
ear
on
the
same
line
as
a
`case'
statemen
t,
or
they
will
b
e
ignored.
Also,
if
the
`breaksw'
commands
are
omitted,
then
con
trol
o
ws
through
all
the
commands
for
case
,
case

etc,
exactly
as
it
do
es
in
the
C
programming
language.
W
e
shall
consider
some
examples
of
these
statemen
ts
in
a
momen
t,
but
rst
it
is
w
orth
listing
some
imp
ortan
t
tests
whic
h
can
b
e
used
in
`if'
questions
to
nd
out
information
ab
out
les.
`-r
le
'
T
rue
if
the
le
exists
and
is
readable
`-w
le
'
T
rue
if
the
le
exists
and
is
writable
`-x
le
'
T
rue
if
the
le
exists
and
is
executable


The
unix
programming
en
vironmen
t
`-e
le
'
T
rue
if
the
le
simply
exists
`-z
le
'
T
rue
if
the
le
exists
and
is
empt
y
`-f
le
'
T
rue
if
the
le
is
a
plain
le
`-d
le
'
T
rue
if
the
le
is
a
directory
W
e
shall
also
ha
v
e
need
of
the
follo
wing
comparision
op
erators.
`=='
is
equal
to
(string
comparison)
`!='
is
not
equal
to
`>'
is
greater
than
`<'
is
less
than
`>='
is
greater
than
or
equal
to
`<='
is
less
than
or
equal
to
`=~'
matc
hes
a
wildcard
`!~'
do
es
not
matc
h
a
wildcard
The
simplest
w
a
y
to
learn
ab
out
these
statemen
ts
is
to
use
them,
so
w
e
shall
no
w
lo
ok
at
some
examples.
#!/bin/csh
-f
#
#
Safe
copy
from
<arg[]>
to
<arg[]>
#
#
if
($#argv
!=
)
then
echo
"Syntax:
copy
<from-file>
<to-file>"
exit
0
endif
if
(
-f
$argv[]
)
then
echo
"File
exists.
Copy
anyway?"
switch
(
$<
)
#
Get
a
line
from
user
case
y:
breaksw
default:
echo
"Doing
nothing!"
exit
0
endsw

Chapter
:
C
shell

endif
echo
-n
"Copying
$argv[]
to
$argv[]..."
cp
$argv[]
$argv[]
echo
done
endif
This
script
tries
to
cop
y
a
le
from
one
lo
cation
to
another.
If
the
user
do
es
not
t
yp
e
exactly
t
w
o
argumen
ts,
the
script
quits
with
a
message
ab
out
the
correct
syn
tax.
Otherwise
it
tests
to
see
whether
a
plain
le
has
the
same
name
as
the
le
the
user
w
an
ted
to
cop
y
to.
If
suc
h
a
le
exists,
it
asks
the
user
if
he/she
w
an
ts
to
con
tin
ue
b
efore
pro
ceding
to
cop
y
.
..
Switc
h
example:
congure
script
Here
is
another
example
whic
h
compiles
a
soft
w
are
pac
k
age.
This
is
a
problem
w
e
shall
return
to
later
See
Section
	.
[Mak
e],
page
	.
The
problem
this
script
tries
to
address
is
the
follo
wing.
There
are
man
y
dieren
t
v
ersions
of
UNIX
and
they
are
not
exactly
compatible
with
one
another.
The
program
this
le
compiles
has
to
w
ork
on
an
y
kind
of
UNIX,
so
it
tries
rst
to
determine
what
kind
of
UNIX
system
the
script
is
b
eing
run
on
b
y
calling
`uname'.
Then
it
denes
a
v
ariable
`MAKE'
whic
h
con
tains
the
path
to
the
`mak
e'
program
whic
h
will
build
softwar
e.
The
mak
e
program
reads
a
le
called
`Mak
ele'
whic
h
con
tains
instructions
for
compiling
the
program,
but
this
le
needs
to
kno
w
the
t
yp
e
of
UNIX,
so
the
script
rst
copies
a
le
`Mak
ele.src'
using
`sed'
replace
a
dumm
y
string
with
the
real
name
of
the
UNIX.
Then
it
calls
mak
e
and
sets
the
correct
p
ermission
on
the
le
using
`chmod'.
#!/bin/csh
-f
########################
####
####
###
####
####
###
###
#
#
#
CONFIGURE
Makefile
AND
BUILD
software
#
#
########################
####
####
###
####
####
###
###
set
NAME
=
(
`uname
-r
-s`
)
switch
($NAME[])
case
SunOS*:
switch
($NAME[])
case
*:
setenv
TYPE
SUN
setenv
MAKE
/bin/make
breaksw
case
*:
setenv
TYPE
SOLARIS


The
unix
programming
en
vironmen
t
setenv
MAKE
/usr/ccs/bin/make
breaksw
endsw
breaksw
case
ULTRIX*:
setenv
TYPE
ULTRIX
setenv
MAKE
/bin/make
breaksw
case
HP-UX*:
setenv
TYPE
HPuUX
setenv
MAKE
/bin/make
breaksw
case
AIX*:
setenv
TYPE
AIX
setenv
MAKE
/bin/make
breaksw
case
OSF*:
setenv
TYPE
OSF
setenv
MAKE
/bin/make
breaksw
case
IRIX*:
setenv
TYPE
IRIX
setenv
MAKE
/bin/make
breaksw
default:
echo
Unknown
architecture
$NAME[]
endsw
#
Generate
Makefile
from
source
file
sed
s/HOSTTYPE/$TYPE/
Makefile.src
>
Makefile
echo
"Making
software.
Type
CTRL-C
to
abort
and
edit
Makefile"
$MAKE
software
#
call
make
to
build
program
chmod

software
#
set
correct
protection
.
Lo
ops
in
csh
The
C-shell
has
three
lo
op
structures:
`repeat',
`while'
and
`foreach'.
W
e
ha
v
e
already
seen
some
examples
of
the
`foreach'
lo
op.
The
structure
of
these
lo
ops
is
as
follo
ws
repeat
n
um
b
er-of-times
command

Chapter
:
C
shell

while
(
test
expression
)
commands
end
foreach
con
trol-v
ariable
(
list-or-arra
y
)
commands
end
The
commands
`break'
and
`continue'
can
b
e
used
to
break
out
of
the
lo
ops
at
an
y
time.
Here
are
some
examples.
repeat

echo
"Yo!"
|
write
mark
This
sends
the
message
"Y
o!"
to
mark's
terminal
t
wice.
repeat

echo
`echo
"Shutdown
time!
Log
out
now"
|
wall
;
sleep
0`
;
halt
This
example
rep
eats
the
command
`ec
ho
Sh
utdo
wn
time...'
v
e
times
at
0
second
in
terv
als,
b
efore
sh
utting
do
wn
the
system.
Only
the
sup
eruser
can
run
this
command!
Note
the
strange
construction
with
`ec
ho
ec
ho'.
This
is
to
force
the
rep
eat
command
to
tak
e
t
w
o
shell
commands
as
an
argumen
t.
(T
ry
to
explain
wh
y
this
w
orks
for
y
ourself.)
.
Input
from
the
user
#
Test
a
user
response
echo
"Answer
y/n
(yes
or
no)"
set
valid
=
false
while
(
$valid
==
false
)
switch
(
$<
)
case
y:
echo
"You
answered
yes"
set
valid
=
true
breaksw
case
n:
echo
"You
answered
no"
set
valid
=
true
breaksw


The
unix
programming
en
vironmen
t
default:
echo
"Invalid
reponse,
try
again"
breaksw
endsw
end
Notice
that
it
w
ould
ha
v
e
b
een
simpler
to
replace
the
t
w
o
lines
set
valid
=
true
breaksw
b
y
a
single
line
`break'.
`breaksw'
jumps
out
of
the
switc
h
construction,
after
whic
h
the
`while'
test
fails.
`break'
jumps
out
of
the
en
tire
while
lo
op.
.
Extracting
parts
of
a
pathname
A
path
name
consists
of
a
n
um
b
er
of
dieren
t
parts:

The
path
to
the
directory
where
a
le
is
held.

The
name
of
the
le
itself.

The
le
extension
(after
a
dot).
By
using
one
of
the
follo
wing
mo
diers,
w
e
can
extract
these
dieren
t
elemen
ts.
`:h'
The
path
to
the
le
`:t'
The
lename
itself
`:e'
The
le
extension
`:r'
The
complete
le-path
min
us
the
le
extension
Here
are
some
examples
and
the
results:
set
f
=
~/progs/c++/test.C
echo
$f:h
/home/mark/progs/c++
echo
$f:t
test.C
echo
$f:e
C
echo
$f:r
/home/mark/progs/c++/test

Chapter
:
C
shell
	
.
Arithmetic
Before
using
these
features
in
a
real
script,
w
e
need
one
more
p
ossibilit
y:
n
umerical
addition,
subtraction
and
m
ultiplication
etc.
T
o
tell
the
C-shell
that
y
ou
w
an
t
to
p
erform
an
op
eration
on
n
um
b
ers
rather
than
strings,
y
ou
use
the
`@'
sym
b
ol
follo
w
ed
b
y
a
space.
Then
the
follo
wing
op
erations
are
p
ossible.
@
var
=

#
Assign
a
numerical
value
to
var
echo
$var
#
Print
the
value
@
var
=
$var
+

#
Add

to
var
@
var
+=

#
Add

to
var
@
var
-=

#
subtract

from
var
@
var
*=

#
Multiply
var
by

@
var
/=

#
Divide
var
by

(integer
division)
@
var
%=

#
Remainder
after
dividing
var
by

@
var++
#
Increment
var
by

@
var--
#
Decrement
var
by

@
array[]
=

#
Numerical
array
@
logic
=
(
$x
>

&&
$x
<
0)
#
AND
@
logic
=
(
$x
>

||
$x
<
0)
#
OR
@
false
=
!
$var
#
Logical
NOT
@
bits
=
(
$x
|
$y
)
#
Bitwise
OR
@
bits
=
(
$x
^
$y
)
#
Bitwise
XOR
@
bits
=
(
$x
&
$y
)
#
Bitwise
AND
@
shifted
=
(
$var
>>

)
#
Bitwise
shift
right
@
back
=
(
$var
<<

)
#
Bitwise
shift
left
These
op
erators
are
precisely
those
found
in
the
C
programming
language.
.
Examples
The
follo
wing
script
uses
the
op
erators
in
the
last
t
w
o
sections
to
tak
e
a
list
of
les
with
a
giv
en
le
extension
(sa
y
`.doc')
and
c
hange
it
for
another
(sa
y
`.tex').
This
is
a
partial
solution
to
the
limitation
of
not
b
eing
able
to
do
m
ultiple
renames
in
shell.
#!/bin/csh
-f
########################
####
####
###
####
####
###
####
####
###
####
#
#
Change
file
extension
for
multiple
files
#
########################
####
####
###
####
####
###
####
####
###
####
if
($#argv
<
)
then

0
The
unix
programming
en
vironmen
t
echo
Syntax:
chext
oldpattern
newextension
echo
"e.g:
chext
*.doc
tex
"
exit
0
endif
mkdir
/tmp/chext.$user
#
Make
a
scratch
area
set
newext="$argv[$#argv]"
#
Last
arg
is
new
ext
set
oldext="$argv[]:e"
echo
"Old
extenstion
was
($oldext)""
echo
"New
extension
($newext)
--
okay?
(y/n)"
switch(
$<
)
case
y:
breaksw
default:
echo
"Nothing
done."
exit
0
endsw
########################
####
####
###
####
####
###
####
####
###
####
#
#
Remove
the
last
file
extension
from
files
########################
####
####
###
####
####
###
####
####
###
####
#
i
=
0
foreach
file
($argv)
i++
if
(
$i
==
$#argv
)
break
cp
$file
/tmp/chext.$user/$file:r
#
temporary
store
end
########################
####
####
###
####
####
###
####
####
###
####
##
#
Add
.newext
file
extension
to
files
########################
####
####
###
####
####
###
####
####
###
####
##
set
array
=
(`ls
/tmp/chext.$user`)
foreach
file
($array)
if
(
-f
$file.$newext
)
then
echo
destination
file
$file.$newext
exists.
No
action
taken.
continue
endif

Chapter
:
C
shell

cp
/tmp/chext.$user/$file
$file.$newext
rm
$file.$oldext
end
rm
-r
/tmp/chext.$user
Here
is
another
example
to
try
to
decipher.
Use
the
man
ual
pages
to
nd
out
ab
out
`awk'.
This
script
can
b
e
written
m
uc
h
more
easily
in
P
erl
or
C,
as
w
e
shall
see
in
the
next
c
hapters.
It
is
also
trivially
implemen
ted
as
a
script
in
the
system
administration
language
cfengine.
#!/bin/csh
-f
########################
####
####
###
####
####
###
####
####
###
##
#
#
KILL
all
processes
owned
by
$argv[]
with
PID
>
$argv[]
#
########################
####
####
###
####
####
###
####
####
###
##
if
("`whoami`"
!=
"root")
then
echo
Permission
denied
exit
0
endif
if
(
$#argv
<

||
$#argv
>

)
then
echo
Usage:
KILL
username
lowest-pid
exit
0
endif
if
(
$argv[]
==
"root")
then
echo
No!
Too
dangerous
--
system
will
crash
exit
0
endif
########################
####
####
###
####
####
###
####
####
###
###
#
Kill
everything
########################
####
####
###
####
####
###
####
####
###
###
if
(
$#argv
==

)
then
set
killarray
=
(
`ps
aux
|
awk
'{
if
($
==
user)
\
{printf
"%s
",$}}'
user=$argv[]`
)
foreach
process
($killarray)
kill
-
$process
kill
-
$process
>
/dev/null


The
unix
programming
en
vironmen
t
kill
-	
$process
>
/dev/null
if
("`kill
-	
$process
|
egrep
-e
'No
such
process'`"
==
"")
then
echo
"Warning
-
$process
would
not
die
-
try
again"
endif
end
########################
####
####
###
####
####
###
####
####
###
####
#
Start
from
a
certain
PID
########################
####
####
###
####
####
###
####
####
###
####
else
if
(
$#argv
==

)
then
set
killarray
=
(
`ps
aux
|
awk
'{
if
($
==
user
&&
$
>
uid)
\
{printf
"%s
",$}}'
user=$argv[]
uid=$argv[]`
)
foreach
process
($killarray)
kill
-
$process
>
/dev/null
kill
-
$process
sleep

kill
-	
$process
>
/dev/null
if
("`kill
-	
$process
|
egrep
-e
'No
such
process'`"
==
"")
then
echo
"Warning
-
$process
would
not
die
-
try
again"
endif
end
endif
This
program
w
ould
b
e
b
etter
written
in
C
or
P
erl.

Chapter
:
Bourne
shell


Bourne
shell
Programmers
who
are
used
to
C
or
C++
often
nd
it
easier
to
program
in
C-shell
b
ecause
there
are
strong
similarities
b
et
w
een
the
t
w
o.
The
Bourne
shell
is
somewhat
dieren
t
in
st
yle,
but
is
structured
in
a
w
a
y
whic
h
mak
es
it
b
etter
suited
to
more
complicated
script
writing,
esp
ecially
for
system
administrators.
Also
it
is
closer
to
the
k
ernels
o
wn
exec
mec
hanism.
The
Bourne
shell
allo
ws
subroutines
and
default
v
alues
for
parameters.
Most
of
the
system
scripts
in
UNIX
are
written
in
the
Bourne
shell.
The
principles
of
the
Bourne
shell
are
largely
the
same
as
those
for
the
C-shell,
so
w
e
shall
skip
fairly
quic
kly
through
the
details.
Historically
,
the
Bourne
shell
came
b
efore
the
C
shell.
.
.prole
The
`.profile'
le
is
the
Bourne
shell's
answ
er
to
`.cshrc'.
This
le
is
read
b
y
in
terac-
tiv
e
`/bin/sh'
shells
on
starting
up.
On
Sun
systems
the
le
`/etc/profile'
is
also
read.
On
`HPUX'
mac
hines,
the
le
`/etc/src.sh'
is
read.
.
V
ariables
and
exp
ort
Lo
cal
and
global
v
ariables
are
b
oth
dened
using
the
syn
tax
VARIABLE="Some
string"
VAR=
It
is
imp
ortan
t
that
there
b
e
no
space
b
et
w
een
the
v
ariable
and
the
equals
sign.
By
default
these
v
ariables
are
lo
c
al.
T
o
mak
e
them
global
(so
that
c
hild
pro
cesses
will
inherit
them)
w
e
use
the
command
export
VARIABLE
This
adds
the
v
ariable
to
the
pro
cess
envir
onment.
It
is
the
analogue
of
making
`en
vironmen
t
v
ariables'
with
setenv
in
C
shell.
The
command
set
-a
c
hanges
the
default
so
that
all
v
ariables,
after
the
command
are
created
glob
al.
Arra
ys
or
lists
are
often
sim
ulated
in
shell
b
y
sandwic
hing
the
colon
`:'
sym
b
ol
b
et
w
een
items
PATH=/bin:/usr/bin:/etc:
/loc
al/b
in:
.
LD_LIBARAY_PATH=/usr/lib
:/us
r/op
enw
in/l
ib:/
loc
al/l
ib
but
there
is
no
real
facilit
y
for
arra
ys
in
the
Bourne
shell.
Note
that
the
UNIX
`cut'
command
can
b
e
used
to
extract
the
elemen
ts
of
the
list.
Lo
ops
can
also
read
suc
h
lists
directly
See
Section
.	
[Lo
ops
in
sh],
page
	.
A
P
erl
script
can
also
b
e
used.
The
v
alue
of
a
v
ariable
is
giv
en
b
y
the
dollar
sym
b
ol
as
in
C-shell.
It
is
also
p
ossible
to
use
curly
br
ac
es
around
the
v
ariable
name
to
`protect'
the
v
ariable
from
in
terfering
text.
F
or
example:
$
animal=worm
$
echo
book$animal


The
unix
programming
en
vironmen
t
bookworm
$
thing=book
$
echo
$thingworm
(nothing..)
$
echo
${thing}worm
bookworm
Default
v
alues
can
b
e
giv
en
to
v
ariables
in
the
Bourne
shell.
The
follo
wing
commands
illustrate
this.
echo
${var-"No
value
set"}
echo
${var="Octopus"}
echo
${var+"Forced
value"}
echo
${var?"No
such
variable"}
The
rst
of
these
prin
ts
out
the
con
ten
ts
of
`$var',
if
it
is
dened.
If
it
is
not
dened
the
v
ariable
is
substituted
for
the
string
"No
v
alue
set".
The
v
alue
of
`var'
is
not
c
hanged
b
y
this
op
eration.
It
is
only
for
con
v
enience.
The
second
command
has
the
same
eect
as
the
rst,
but
here
the
v
alue
of
`$var'
is
actually
c
hanged
to
"Octopus"
if
`$var'
is
not
set.
The
third
v
ersion
is
sligh
tly
p
eculiar.
If
`$var'
is
alr
e
ady
set,
its
v
alue
will
b
e
forced
to
b
e
"F
orced
v
alue",
otherwise
it
is
left
undened.
Finally
the
last
instance
issues
an
error
message
"No
suc
h
v
ariable"
if
`$var'
is
not
dened.
.
Stdin,
stdout
and
stderr
In
the
Bourne
shell,
the
standard
input/output
les
are
referred
to
b
y
n
um
b
ers
rather
than
b
y
names.
stdin
File
n
um
b
er
0
stdout
File
n
um
b
er

stderr
File
n
um
b
er

The
default
routes
for
these
les
can
b
e
c
hanged
b
y
r
e
dir
e
ction.
The
redirection
commands
are
more
complicated
than
in
C-shell,
but
they
are
also
more
exible.
Here
is
a
comparison.
sh
csh
Description
command
>
file
command
>
file
Stdout
to
file
command
>
file
command
>
file
Stdout
to
file
command
>
errs
(No
analogue)
Stderr
only
to
file
errs
command
>
file
>&
command
>&
file
stdout
and
stderr
to
file
command
>
file
>
errs
(No
analogue)
stdout
to
file,
stderr
to
errs

Chapter
:
Bourne
shell

.
Arithmetic
in
sh
Arithmetic
is
p
erformed
en
tirely
`b
y
pro
xy'.
There
are
no
in
ternal
arithmetic
op
erators
as
in
the
C-shell.
T
o
ev
aluate
an
expression
w
e
call
the
`expr'
command
or
the
`bc'
precision
calculator.
Here
are
some
examples
of
`expr'
a=`expr
$a+`
#
increment
a
a=`expr

+
0
\*
`
#
+0*
check
=
`expr
$a
\>
$b`
#
true=,
false=0.
True
if
$a
>
$b
`expr'
is
v
ery
sensitiv
e
to
spaces
and
bac
kslash
c
haracters.
.
Scripts
and
argumen
ts
Scripts
are
created
b
y
making
an
executable
le
whic
h
b
egins
with
the
sequence
of
c
haracters
#!/bin/sh
Although
w
e
didn't
discuss
it
b
efore,
this
construction
is
quite
general:
an
y
executable
le
whic
h
b
egins
with
a
sequence
#!myprogram
-option
will
cause
the
shell
to
attempt
to
execute
myprogam
-option
filename
where
lename
is
the
name
of
the
le.
If
a
script
is
to
accept
argumen
ts
then
these
can
b
e
referred
to
as
`
$
$
$..$	'.
There
is
a
logical
limit
of
nine
argumen
ts
to
a
script,
but
in
practice
it
is
p
ossibile
to
get
around
this
limitation.
`$0'
is
the
name
of
the
script
itself.
Here
is
a
simple
script
in
the
Bourne
shell
whic
h
prin
ts
out
all
its
argumen
ts.
#!/bin/sh
#
#
Print
all
arguments
(version
)
#
for
arg
in
$*
do
echo
Argument
$arg
done
echo
Total
number
of
arguments
was
$#
The
`$*'
sym
b
ol
stands
for
the
en
tire
list
of
argumen
ts
(lik
e
`$argv'
in
C-shell)
and
`$#'
is
the
total
n
um
b
er
of
argumen
ts
(lik
e
`$#argv'
in
C-shell).
Another
w
a
y
of
ac
hieving
the
same
is
to
use
the
`shift'
command.
W
e
shall
meet
this
again
in
the
P
erl
programming
language.
`shift'
tak
es
the
rst
argumen
t
from
the
argumen
t
list
and
deletes
it,
mo
ving
all
of
the
other
argumen
ts
do
wn
one
n
um
b
er
{
this
is
ho
w
w
e
can
handle
long
lists
of
argumen
ts
in
`sh'.


The
unix
programming
en
vironmen
t
#!/bin/sh
#
#
Print
all
arguments
(version
)
#
while
(
true
)
do
arg=$;
shift;
echo
$arg
was
an
argument;
if
[
$#
-eq
0
];
then
break
fi
done
.
Return
co
des
All
programs
whic
h
execute
in
UNIX
return
a
v
alue
through
the
C
`return'
command.
There
is
a
con
v
en
tion
that
a
return
v
alue
of
zero
(0)
means
that
ev
erything
w
en
t
w
ell,
whereas
an
y
other
v
alue
implies
that
some
error
o
ccurred.
The
return
v
alue
is
usually
the
v
alue
returned
in
`errno',
the
extenal
error
v
ariable
in
C.
Shell
scripts
can
test
for
these
v
alues
either
b
y
placing
the
command
directly
inside
an
`if
'
test,
or
b
y
testing
the
v
ariable
`$?'
whic
h
is
alw
a
ys
set
to
the
return
co
de
of
the
last
command.
Some
examples
are
giv
en
follo
wing
the
next
t
w
o
sections.
.
T
ests
and
conditionals
The
Bourne
shell
has
the
usual
arra
y
of
tests.
They
are
written
as
follo
ws.
Notice
that
`test'
is
itself
not
a
part
of
the
shell,
but
is
a
program
whic
h
w
orks
out
conditions
and
pro
vides
a
return
co
de.
See
the
man
ual
page
on
`test'
for
more
details.
test
-f
le
T
rue
if
the
le
is
a
plain
le
test
-d
le
T
rue
if
the
le
is
a
directory
test
-r
le
T
rue
if
the
le
is
readable
test
-w
le
T
rue
if
the
le
is
writable
test
-x
le
T
rue
if
the
le
is
executable
test
-s
le
T
rue
if
the
le
con
tains
something
test
-g
le
T
rue
if
setgid
bit
is
set

Chapter
:
Bourne
shell

test
-u
le
T
rue
if
setuid
bit
is
set
test
s
=
s
T
rue
if
strings
s
and
s
are
equal
test
s
!=
s
T
rue
if
strings
s
and
s
are
unequal
test
x
-eq
y
T
rue
if
the
in
tegers
x
and
y
are
n
umerically
equal
test
x
-ne
y
T
rue
if
in
tegers
are
not
equal
test
x
-gt
y
T
rue
if
x
is
greater
than
y
test
x
-lt
y
T
rue
if
x
is
less
than
y
test
x
-ge
y
T
rue
if
x
>=y
test
x
-le
y
T
rue
if
x
<=
y
!
Logical
NOT
op
erator
-a
Logical
AND
-o
Logical
OR
Note
that
an
alternate
syn
tax
for
writing
these
commands
if
to
use
the
square
brac
k
ets,
instead
of
writing
the
w
ord
test.
[
$x
-lt
$y
]
"=="
test
$x
-lt
$y
The
conditional
structures
ha
v
e
the
follo
wing
syn
tax.
if
unix-command
then
command
else
commands
fi
The
`else'
clause
is,
of
course,
optional.
As
noted
b
efore,
the
rst
unix
command
could
b
e
anything,
since
ev
ery
command
has
a
return
co
de.
The
result
is
TR
UE
if
it
ev
aluates
to
zer
o
and
false
otherwise
(in
con
trast
to
the
con
v
en
tions
in
most
languages).
Multiple
tests
can
b
e
made
using
if
unix-command
then
commands
elif
unix-command
then
commands


The
unix
programming
en
vironmen
t
elif
unix-command
then
commands
else
commands
fi
where
`elif'
means
`else-if
'.
The
equiv
alen
t
of
the
C-sc
ho
ol's
`switch'
statemen
t
is
a
more
P
ascal-lik
e
`case'
struc-
ture.
case
unix-command-or-v
ariable
in
wildcard)
commands
;;
wildcard)
commands
;;
wildcard)
commands
;;
esac
This
structure
uses
the
wildcards
to
matc
h
the
output
of
the
command
or
v
ariable
in
the
rst
line.
The
rst
pattern
whic
h
matc
hes
gets
executed.
.
Input
from
the
user
in
sh
In
shell
y
ou
can
read
the
v
alue
of
a
v
ariable
using
the
`read'
command,
with
syn
tax
read
v
ariable
This
reads
in
a
string
from
the
k
eyb
oard
and
terminates
on
a
newline
c
haracter.
Another
w
a
y
to
do
this
is
to
use
the
`input'
command
to
access
a
particular
logical
device.
The
k
eyb
oard
device
in
the
curren
t
terminal
is
`/dev/tty',
so
that
one
writes
v
ariable
=
`line
<
/dev/tty`
whic
h
fetc
hes
a
single
line
from
the
user.
Here
are
some
examples
of
these
commands.
First
a
program
whic
h
asks
y
es
or
no...
#!/bin/sh
#
#
Yes
or
no
#
echo
"Please
answer
yes
or
no:
"
answer=`line
<
/dev/tty`
case
$answer
in
y*
|
Y*
|
j*
|
J*
)
echo
YES!!
;;
n*
|
N*
)
echo
NO!!
;;
*)
echo
"Can't
you
answer
a
simple
question?"

Chapter
:
Bourne
shell
	
esac
echo
The
end
Notice
the
use
of
pattern
matc
hing
and
the
`|'
`OR'
sym
b
ol.
#!/bin/sh
#
#
Kernel
check
#
if
test
!
-f
/vmunix
#
Check
that
the
kernel
is
there!
then
echo
"This
is
not
BSD
unix...hmmm"
if
[
-f
/hp-ux
]
then
echo
"It's
a
Hewlett
Packard
machine!"
fi
elif
[
-w
/vmunix
]
then
echo
"HEY!!
The
kernel
is
writable
my
me!";
else
echo
"The
kernel
is
write
protected."
echo
"The
system
is
safe
from
me
today."
fi
.	
Lo
ops
in
sh
The
lo
op
structures
in
the
Bourne
shell
ha
v
e
the
follo
wing
syn
tax.
while
unix-command
do
commands
done
The
rst
command
will
most
lik
ely
b
e
a
test
but,
as
b
efore,
it
could
in
principle
b
e
an
y
UNIX
command.
The
`until'
lo
op,
reminiscen
t
of
BCPL,
carries
out
a
task
un
til
its
argumen
t
ev
aluates
to
TR
UE.
until
unix-command
do
commands
done
Finally
the
`for'
structure
has
already
b
een
used
ab
o
v
e.
for
v
ariable
in
list
do
commands
done
Often
w
e
w
an
t
to
b
e
able
to
use
an
arra
y
of
v
alues
as
the
list
whic
h
for
parses,
but
Bourne
shell
has
no
arra
y
v
ariables.
This
problem
is
usually
solv
ed
b
y
making
a
long
string
separated
b
y
,
for
example,
colons.
F
or
example,
the
$PATH
v
ariable
has
the
form

0
The
unix
programming
en
vironmen
t
PATH
=
/usr/bin:/bin:/local/gnu/
bin
Bourne
shell
allo
ws
us
to
split
suc
h
a
string
on
whatev
er
c
haracter
w
e
wish.
Normally
the
split
is
made
on
spaces,
but
the
v
ariable
`IFS'
can
b
e
dened
with
a
replacemen
t.
T
o
mak
e
a
lo
op
o
v
er
all
directories
in
the
command
path
w
e
w
ould
therefore
write
IFS=:
for
name
in
$PATH;
do
commands
done
The
b
est
w
a
y
to
gain
exp
erience
with
these
commands
is
through
some
examples.
#!/bin/sh
#
#
Get
text
from
user
repeatedly
#
echo
"Type
away..."
while
read
TEXT
do
echo
You
typed
$TEXT
if
[
"$TEXT"
=
"quit"
];
then
echo
"(So
I
quit!)"
exit
0
fi
done
echo
"HELP!"
This
v
ery
simple
script
is
a
t
ypical
use
for
a
while-lo
op.
It
gets
text
rep
eatedly
un
til
the
user
t
yp
e
`quit'.
Since
read
nev
er
returns
`false'
unless
an
error
o
ccurs
or
it
detects
an
EOF
(end
of
le)
c
haracter
h
CTRL-D
i
,
it
will
nev
er
exit
without
some
help
from
an
`if
'
test.
If
it
do
es
receiv
e
a
h
CTRL-D
i
signal,
the
script
prin
ts
`HELP!'.
#!/bin/sh
#
#
Watch
in
the
background
for
a
particular
user
#
and
give
alarm
if
he/she
logs
in
#
#
To
be
run
in
the
background,
using
&
#
if
[
$#
-ne

];
then
echo
"Give
the
name
of
the
user
as
an
argument"
>
/dev/tty

Chapter
:
Bourne
shell

exit

fi
echo
"Looking
for
$"
until
users
|
grep
-s
$
do
sleep
0
done
echo
"!!!
WAKE
UP
!!!"
>
/dev/tty
echo
"User
$
just
logged
in"
>
/dev/tty
This
script
uses
`grep'
in
`silen
t
mo
de'
(-s
option).
i.e.
grep
nev
er
writes
an
ything
to
the
terminal.
The
only
thing
w
e
are
in
terested
in
is
the
return
co
de
the
pip
ed
command
pro
duces.
If
`grep'
detects
a
line
con
taining
the
username
w
e
are
in
terested
in,
then
the
result
ev
aluates
to
TR
UE
and
the
sleep-lo
op
exits.
Our
nal
example
is
the
kind
of
script
whic
h
is
useful
for
a
system
administrator.
It
transfers
o
v
er
the
Net
w
ork
Information
Service
database
les
so
that
a
sla
v
e
serv
er
is
up
to
date.
All
w
e
ha
v
e
to
do
is
mak
e
a
list
of
the
les
and
place
it
in
a
`for'
lo
op.
The
names
used
b
elo
w
are
the
actual
names
of
the
NIS
maps,
w
ell
kno
wn
to
system
administrators.
#!/bin/sh
#
#
Update
the
NIS
database
maps
on
a
client
server.
This
program
#
shouldn't
have
to
be
run,
but
sometimes
things
go
wrong
and
we
#
have
to
force
a
download
from
the
main
sever.
#
PATH=/etc/yp:/usr/etc/yp
:$PA
TH
MASTER=myNISserver
for
map
in
auto.direct
auto.master
ethers.byaddr
ethers.byname\
group.bygid
group.byname
hosts.byaddr
hosts.byname\
mail.aliases
netgroup.byhost
netgroup.byuser
netgroup\
netid.byname
networks.byaddr
networks.byname
passwd.byname\
passwd.byuid
priss.byname
protocols.byname
protocols.bynumber\
rpc.bynumber
services.byname
services
usenetgroups.byname;
do
ypxfr
$
-h
$MASTER
$map
done
.0
Pro
cedures
and
traps
One
of
the
w
orth
y
features
of
the
Bourne
shell
is
that
it
allo
ws
y
ou
to
dene
subr
outines
or
pr
o
c
e
dur
es.
Subroutines
w
ork
just
lik
e
subroutines
in
an
y
other
programming
language.
They
are
executed
in
same
shell
(not
as
a
sub-pro
cess).


The
unix
programming
en
vironmen
t
Here
is
an
in
teresting
program
whic
h
demonstrates
t
w
o
useful
things
at
the
same
time.
First
of
all,
it
sho
ws
ho
w
to
mak
e
a
hierac
hical
subroutine
structure
using
the
Bourne
shell.
Secondly
,
it
sho
ws
ho
w
the
`trap'
directiv
e
can
b
e
used
to
trap
signals,
so
that
Bourne
shell
programs
can
exit
safely
when
they
are
killed
or
when
CTRL-C
is
t
yp
ed.
#!/bin/sh
#
#
How
to
make
a
signal
handler
in
Bourne
Shell
#
using
subroutines
#
########################
####
####
###
####
####
###
####
###
#
Level

########################
####
####
###
####
####
###
####
###
ReallyQuit()
{
while
true
do
echo
"Do
you
really
want
to
quit?"
read
answer
case
$answer
in
y*
|
Y*
)
return
0;;
*)
echo
"Resuming..."
return
;;
esac
done
}
########################
####
####
###
####
####
###
####
###
#
Level

########################
####
####
###
####
####
###
####
###
SignalHandler()
{
if
ReallyQuit
#
Call
a
function
then
exit
0
else
return
0
fi
}
########################
####
####
###
####
####
###
####
###
#
Level
0
:
main
program

Chapter
:
Bourne
shell

########################
####
####
###
####
####
###
####
###
trap
SignalHandler


#
Trap
kill
signals

and

echo
"Type
some
lines
of
text..."
while
read
text
do
echo
"$text
-
CTRL-C
to
exit"
done
Note
that
the
logical
tree
structure
of
this
program
is
upside
do
wn
(the
highest
lev
el
comes
at
the
b
ottom).
This
is
b
ecause
all
subroutines
m
ust
b
e
dened
b
efore
they
are
used.
This
example
concludes
our
brief
surv
ey
of
the
Bourne
shell.
.
setuid
and
setgid
scripts
The
sup
eruser
`root'
is
the
only
privileged
user
in
UNIX.
All
other
users
ha
v
e
only
restricted
access
to
the
system.
Usually
this
is
desirable,
but
sometimes
it
is
a
n
uisance.
A
setuid
script
is
a
script
whic
h
has
its
setuid-bit
set.
When
suc
h
a
script
is
executed
b
y
a
user,
it
is
run
with
all
the
righ
ts
and
privileges
of
the
o
wner
of
the
script.
All
of
the
commands
in
the
script
are
executed
as
the
o
wner
of
the
le
and
not
with
the
user-id
of
the
p
erson
who
ran
the
script.
If
the
o
wner
of
the
setuid
script
is
`root'
then
the
commands
in
the
script
are
run
with
r
o
ot
privile
ges
!
Setuid
scripts
are
clearly
a
touc
h
y
securit
y
issue.
When
giving
a
w
a
y
one's
righ
ts
to
another
user
(esp
ecially
those
of
`root')
one
is
tempting
hac
k
ers.
Setuid
scripts
should
b
e
avoide
d.
A
setgid
program
is
almost
the
same,
but
only
the
group
id
is
set
to
that
of
the
o
wner
of
the
le.
Often
the
eect
is
the
same.
An
example
of
a
setuid
program
is
the
`ps'
program.
`ps'
lists
all
of
the
pro
cesses
running
in
the
k
ernel.
In
order
to
do
this
it
needs
p
ermission
to
access
the
priv
ate
data
structures
in
the
k
ernel.
By
making
`ps'
setgid
ro
ot,
it
allo
ws
ordinary
users
to
b
e
able
to
read
as
m
uc
h
as
the
writers
of
`ps'
though
t
t,
but
no
more.
Naturally
,
only
the
sup
eruser
can
mak
e
a
le
setuid
or
setgid
ro
ot.
.
Summary:
Limitations
of
shell
programming
T
o
summarize
the
last
t
w
o
long
and
oppressiv
e
c
hapters
w
e
shall
tak
e
a
step
bac
k
from
the
details
and
lo
ok
at
what
w
e
ha
v
e
ac
hiev
ed.
The
idea
b
ehind
the
shell
is
to
pro
vide
a
user
in
terface,
with
access
to
the
system's
facilities
at
a
simple
lev
el.
In
the
0's
user
in
terfaces
w
ere
not
deisgned
to
b
e
user-friendly
.
The
UNIX
shell
is
not
particularly
use
friendly
,
but
it
is
v
ery
p
o
w
erful.
P
erhaps
it
w
ould
ha
v
e
b
een
enough
to
pro
vide
only
commands
to
allo
w
users
to
write
C
programs.
Since


The
unix
programming
en
vironmen
t
all
of
the
system
functions
are
a
v
ailable
from
C,
that
w
ould
certainly
allo
w
ev
ery
one
to
do
what
an
ything
that
UNIX
can
do.
But
shell
programming
is
m
uc
h
more
imme
diate
than
C.
It
is
an
en
vironmen
t
of
fr
e
quently
use
d
to
ols.
Also
for
quic
k
programming
solutions:
C
is
a
compiled
language,
whereas
the
shell
is
an
in
terpreter.
A
quic
k
shell
program
can
solv
e
man
y
problems
in
no
time
at
all,
without
ha
ving
to
compile
an
ything.
Shell
programming
is
only
useful
for
`quic
k
and
easy'
programs.
T
o
use
it
for
an
ything
serious
is
an
abuse.
Programming
dicult
things
in
shell
is
clumsy
,
and
it
is
dicult
to
get
returned-information
(lik
e
error
messages)
bac
k
in
a
useful
form.
Besides,
shell
scripts
are
slo
w
compared
to
real
programs
since
they
in
v
olv
e
starting
a
new
program
for
eac
h
new
command.
These
diculties
are
solv
ed
partly
b
y
P
erl,
whic
h
w
e
shall
consider
next
{
but
in
the
nal
analysis,
real
programs
of
substance
need
to
b
e
written
in
C.
Con
trary
to
p
opular
b
elief,
this
is
not
more
dicult
than
programming
in
the
shell
{
in
fact,
man
y
things
are
m
uc
h
simpler,
b
ecause
all
of
the
shell
commands
originated
as
C
functions.
The
shell
is
an
extra
la
y
er
of
the
UNIX
onion
whic
h
w
e
ha
v
e
to
battle
our
w
a
y
through
to
get
where
w
e're
going.
Sometimes
it
is
helpful
to
b
e
shielded
from
low
level
details
{
sometimes
it
is
a
hindr
anc
e.
In
the
remaining
c
hapters
w
e
shall
consider
more
in
v
olv
ed
programming
needs.
.
Exercises
.
W
rite
an
impro
v
ed
`which'
command
in
C-shell.
.
Mak
e
a
coun
ter
program
whic
h
records
in
a
le
ho
w
man
y
times
y
ou
log
in
to
y
our
accoun
t.
Y
ou
can
call
this
in
y
our
.cshrc
le.
.
Mak
e
a
Bourne
shell
script
to
kill
all
the
pro
cesses
o
wned
b
y
a
particular
user.
(Note,
that
if
y
ou
are
not
the
sup
eruser,
y
ou
cannot
kill
pro
cesses
o
wned
b
y
other
users.)
.
W
rite
a
script
to
replace
the
`rm'
command
with
something
safer.
Think
ab
out
a
w
a
y
of
implemen
ting
`rm'
so
that
it
is
p
ossible
to
get
deleted
les
bac
k
again
in
case
of
emergencies.
This
is
not
p
ossible
using
the
normal
`rm'
command.
Hin
t:
sa
v
e
les
in
a
hidden
directory
`.deleted'.
Mak
e
y
our
script
delete
les
in
the
`.deleted'
directory
if
they
are
older
than
a
w
eek,
so
that
y
ou
don't
ll
up
the
disk
with
rubbish.
.
Supp
ose
y
ou
ha
v
e
a
bunc
h
of
les
with
a
particular
le-extension:
write
a
script
in
csh
to
c
hange
the
extension
to
something
else.
e.g.
to
c
hange
*.C
in
to
*.c.
Giv
e
the
old
and
new
extensions
as
argumen
ts
to
the
script.
.
W
rite
a
program
in
sh
to
searc
h
for
les
in
the
curren
t
directory
whic
h
con
tain
a
certain
string.
e.g.
searc
h
for
all
les
whic
h
con
tain
the
w
ord
"if".
Hin
t:
use
the
"nd"
command.
.
Use
the
man
ual
pages
to
nd
out
ab
out
the
commands
`at',
`batch'
and
`atq'.
T
est
these
commands
b
y
executing
the
shell
command
`date'
at
some
time
of
y
our
c
hoice.
Use
the
`-m'
option
so
that
the
result
of
the
job
is
mailed
to
y
ou.
.
W
rite
a
script
in
sh
or
csh
to
list
all
of
the
les
bigger
than
a
certain
size
starting
from
the
curren
t
directory
,
and
including
all
sub
directories.
This
kind
of
program
is
useful
for
system
administrators
when
a
disk
b
ecomes
full.

Chapter
:
P
erl


P
erl
So
far,
w
e
ha
v
e
b
een
lo
oking
at
shell
programming
for
p
erforming
fairly
simple
tasks.
No
w
let's
extend
the
idea
of
shell
programming
to
co
v
er
more
complex
tasks
lik
e
systems
programming
and
net
w
ork
comm
unications.
P
erl
is
a
language
whic
h
w
as
designed
to
retain
the
immediateness
of
shell
languages,
but
at
the
same
time
capture
some
of
the
exibilit
y
of
C.
P
erl
is
an
acron
ym
for
Pr
actic
al
extr
action
and
r
ep
ort
language.
In
this
c
hapter,
w
e
shall
not
aim
to
teac
h
P
erl
from
scratc
h
{
the
b
est
w
a
y
to
learn
it
is
to
use
it!
Rather
w
e
shall
concen
trate
on
demonstrating
some
principles.
.
Sed
and
a
wk,
cut
and
paste
One
of
the
reasons
for
using
P
erl
is
that
it
is
extremely
go
o
d
at
textle
handling{one
of
the
most
imp
ortan
t
things
for
UNIX
users,
and
particularly
useful
in
connection
with
CGI
script
pro
cessing
on
the
W
orld
Wide
W
eb.
It
has
simple
built-in
constructs
for
searc
hing
and
replacing
text,
storing
information
in
arra
ys
and
retrieving
them
in
sorted
form.
All
of
the
these
things
ha
v
e
previously
b
een
p
ossible
using
the
UNIX
shell
commands
sed
awk
cut
paste
but
these
commands
w
ere
designed
to
w
ork
primarily
in
the
Bourne
shell
and
are
a
bit
`awk'w
ard
to
use
for
all
but
the
simplest
applications.
`sed'
is
a
stream
editor.
It
tak
es
command
line
instructions,
reads
input
from
the
stream
stdin
and
pro
duces
output
on
stdout
according
to
those
instructions.
`sed'
w
orks
line
b
y
line
from
the
start
of
a
textle.
`awk'
is
a
pattern
matc
hing
and
pro
cessing
language.
It
tak
es
a
textle
and
reads
it
line
b
y
line,
matc
hing
r
e
gular
expr
essions
and
acting
on
them.
`awk'
is
p
o
w
erful
enough
to
ha
v
e
conditional
instructions
lik
e
`if..then..else'
and
uses
C's
`printf'
construction
for
output.
`cut'
T
ak
es
a
line
of
input
and
cuts
it
in
to
elds,
separated
b
y
some
c
haracter.
F
or
instance,
a
normal
line
of
text
is
a
string
of
w
ords
separated
b
y
spaces.
Eac
h
w
ord
is
a
dieren
t
eld.
`cut'
can
b
e
used,
for
instance,
to
pic
k
out
the
third
column
in
a
table.
An
y
c
haracter
can
b
e
sp
ecied
as
the
separator.
`paste'
is
the
logical
opp
osite
of
cut.
It
concatenates
n
les,
and
mak
es
eac
h
line
in
the
le
in
to
a
column
of
a
table.
F
or
instance,
`paste
one
two
three'
w
ould
mak
e
a
table
in
whic
h
the
rst
column
consisted
of
all
lines
in
`one',
the
second
of
all
lines
in
`two'
and
the
third
of
all
lines
in
`three'.
If
one
le
is
longer
than
the
others,
then
some
columns
ha
v
e
blank
spaces.
P
erl
unies
all
of
these
op
erations
and
more.
It
also
mak
es
them
m
uc
h
simpler.


The
unix
programming
en
vironmen
t
.
Program
structure
T
o
summarize
P
erl,
w
e
need
to
kno
w
ab
out
the
structure
of
a
P
erl
program,
the
con-
ditional
constructs
it
has,
its
lo
ops
and
its
v
ariables.
In
the
latest
v
ersions
of
P
erl
(P
erl
),
y
ou
can
write
ob
ject
orien
ted
programs
of
great
complexit
y
.
W
e
shall
not
go
in
to
this
depth,
for
the
simple
reason
that
P
erl's
strength
is
not
as
a
general
programming
language
but
as
a
sp
ecialized
language
for
textle
handling.
The
syn
tax
of
P
erl
is
in
man
y
w
a
ys
lik
e
the
C
programming
language,
but
there
are
imp
ortan
t
dierences.

V
ariables
do
not
ha
v
e
typ
es.
They
are
in
terpreted
in
a
con
text
sensitiv
e
w
a
y
.
The
op
erators
whic
h
acts
up
on
v
ariables
determine
whether
a
v
ariable
is
to
b
e
considered
a
string
or
as
an
in
teger
etc.

Although
there
are
no
t
yp
es,
P
erl
denes
arr
ays
of
dieren
t
kinds.
There
are
three
dieren
t
kinds
of
arra
y
,
lab
elled
b
y
the
sym
b
ols
`$',
`@'
and
`%'.

P
erl
k
eeps
a
n
um
b
er
of
standard
v
ariables
with
sp
ecial
names
e.g.
`$_
@ARGV'
and
`%ENV'.
Sp
ecial
atten
tion
should
b
e
paid
to
these.
They
are
v
ery
imp
ortan
t!

The
shell
rev
erse
ap
ostrophe
notation
`command`
can
b
e
used
to
execute
UNIX
pro-
grams
and
get
the
result
in
to
a
P
erl
v
ariable.
Here
is
a
simple
`structured
hello
w
orld'
program
in
P
erl.
Notice
that
subroutines
are
called
using
the
`&'
sym
b
ol.
There
is
no
sp
ecial
w
a
y
of
marking
the
main
program
{
it
is
simply
that
part
of
the
program
whic
h
starts
at
line
.
#!/local/bin/perl
#
#
Comments
#
&Hello();
&World;
#
end
of
main
sub
Hello
{
print
"Hello";
}
sub
World
{
print
"World\n";
}
The
paren
theses
on
subroutines
are
optional,
if
there
are
no
parameters
passed.
Notice
that
eac
h
line
m
ust
end
in
a
semi-colon.
.
P
erl
v
ariables

Chapter
:
P
erl

..
Scalar
v
ariables
In
P
erl,
v
ariables
do
not
ha
v
e
to
b
e
declared
b
efore
they
are
used.
Whenev
er
y
ou
use
a
new
sym
b
ol,
P
erl
automatically
adds
the
sym
b
ol
to
its
sym
b
ol
table
and
initializes
the
v
ariable
to
the
empt
y
string.
It
is
imp
ortan
t
to
understand
that
there
is
no
practical
dierence
b
et
w
een
zero
and
the
empt
y
string
in
p
erl
{
except
in
the
w
a
y
that
y
ou,
the
user,
c
ho
ose
to
use
it.
P
erl
mak
es
no
distinction
b
et
w
een
strings
and
in
tegers
or
an
y
other
t
yp
es
of
data
{
except
when
it
w
an
ts
to
in
terpret
them.
F
or
instance,
to
compare
t
w
o
v
ariables
as
strings
is
not
the
same
as
comparing
them
as
in
tegers,
ev
en
if
the
string
con
tains
a
textual
represen
tation
of
an
in
teger.
T
ak
e
a
lo
ok
at
the
follo
wing
program.
#!/local/bin/perl
#
#
Nothing!
#
print
"Nothing
==
$nothing\n";
print
"Nothing
is
zero!\n"
if
($nothing
==
0);
if
($nothing
eq
"")
{
print
STDERR
"Nothing
is
really
nothing!\n";
}
$nothing
=
0;
print
"Nothing
is
now
$nothing\n";
The
output
from
this
program
is
Nothing
==
Nothing
is
zero!
Nothing
is
really
nothing!
Nothing
is
now
0
There
are
sev
eral
imp
ortan
t
things
to
note
here.
First
of
all,
w
e
nev
er
declare
the
v
ariable
`nothing'.
When
w
e
try
to
write
its
v
alue,
p
erl
creates
the
name
and
asso
ciates
a
NULL
v
alue
to
it
i.e.
the
empt
y
string.
There
is
no
error.
P
erl
kno
ws
it
is
a
v
ariable
b
ecause
of
the
`$'
sym
b
ol
in
fron
t
of
it.
All
sc
alar
v
ariables
are
iden
tied
b
y
using
the
dollar
sym
b
ol.
Next,
w
e
compare
the
v
alue
of
`$nothing'
to
the
in
teger
`0'
using
the
in
teger
comparison
sym
b
ol
`==',
and
then
w
e
compare
it
to
the
empt
y
string
using
the
string
comparison
sym
b
ol
`eq'.
Both
tests
are
true!
That
means
that
the
empt
y
string
is
in
terpreted
as
ha
ving
a
n
umerical
v
alue
of
zero.
In
fact
any
string
whic
h
do
es
not
form
a
v
alid
in
teger
n
um
b
er
has
a
n
umerical
v
alue
of
zero.
Finally
w
e
can
set
`$nothing'
explicitly
to
a
v
alid
in
teger
string
zero,
whic
h
w
ould
no
w
pass
the
rst
test,
but
fail
the
second.


The
unix
programming
en
vironmen
t
As
extra
spice,
this
program
also
demonstrates
t
w
o
dieren
t
w
a
ys
of
writing
the
`if'
command
in
p
erl.
..
The
default
scalar
v
ariable.
The
sp
ecial
v
ariable
`$_'
is
used
for
man
y
purp
oses
in
P
erl.
It
is
used
as
a
buer
to
con
tain
the
result
of
the
last
op
eration,
the
last
line
read
in
from
a
le
etc.
It
is
so
general
that
man
y
functions
whic
h
act
on
scalar
v
ariables
w
ork
b
y
default
on
`$_'
if
no
other
argumen
t
is
sp
ecied.
F
or
example,
print;
is
the
same
as
print
$_;
..
Arra
y
(v
ector)
v
ariables
The
complemen
t
of
scalar
v
ariables
is
arra
ys.
An
arra
y
,
in
P
erl
is
iden
tied
b
y
the
`@'
sym
b
ol
and,
lik
e
scalar
v
ariables,
is
allo
cated
and
initialized
dynamically
.
@array[0]
=
"This
little
piggy
went
to
market";
@array[]
=
"This
little
piggy
stayed
at
home";
print
"@array[0]
@array[]
@array[]";
The
index
of
an
arra
y
is
alw
a
ys
understo
o
d
to
b
e
a
n
um
b
er,
not
a
string,
so
if
y
ou
use
a
non-n
umerical
string
to
refer
to
an
arra
y
elemen
t,
y
ou
will
alw
a
ys
get
the
zeroth
elemen
t,
since
a
non-n
umerical
string
has
an
in
teger
v
alue
of
zero.
An
imp
ortan
t
arra
y
whic
h
ev
ery
program
denes
is
@ARGV
This
is
the
argumen
t
v
ector
arra
y
,
and
con
tains
the
commands
line
argumen
ts
b
y
analogy
with
the
C-shell
v
ariable
`$argv[]'.
Giv
en
an
arra
y
,
w
e
can
nd
the
last
elemen
t
b
y
using
the
`$#'
op
erator.
F
or
example,
$last_element
=
$ARGV[$#ARGV];
Notice
that
eac
h
elemen
t
in
an
arra
y
is
a
scalar
v
ariable.
The
`$#'
cannot
b
e
in
terpreted
directly
as
the
n
um
b
er
of
elemen
ts
in
the
arra
y
,
as
it
can
in
the
C-shell.
Y
ou
should
exp
erimen
t
with
the
v
alue
of
this
quan
tit
y
{
it
often
necessary
to
add

or

to
its
v
alue
in
order
to
get
the
b
eha
viour
one
is
used
to
in
the
C-shell.
P
erl
do
es
not
supp
ort
m
ultiple-dimension
arra
ys
directly
,
but
it
is
p
ossible
to
sim
ulate
them
y
ourself.
(See
the
P
erl
b
o
ok.)
..
Sp
ecial
arra
y
commands
The
`shift'
command
acts
on
arra
ys
and
returns
and
remo
v
es
the
rst
elemen
t
of
the
arra
y
.
Afterw
ards,
all
of
the
elemen
ts
are
shifted
do
wn
one
place.
So
one
w
a
y
to
read
the
elemen
ts
of
an
arra
y
in
order
is
to
rep
eatedly
call
`shift'.

Chapter
:
P
erl
	
$next_element=shift(@mya
rray
);
Note
that,
if
the
arra
y
argumen
t
is
omitted,
then
`shift'
w
orks
on
`@ARGV'
b
y
default.
Another
useful
function
is
`split',
whic
h
tak
es
a
string
and
turns
it
in
to
an
arra
y
of
strings.
`split'
w
orks
b
y
c
ho
osing
a
c
haracter
(usually
a
space)
to
delimit
the
arra
y
elemen
ts,
so
a
string
con
taining
a
sen
tence
separated
b
y
spaces
w
ould
b
e
turned
in
to
an
arra
y
of
w
ords.
The
syn
tax
is
@array
=
split;
#
works
with
spaces
on
$_
@array
=
split(pattern,string);
#
Breaks
on
pattern
($v,$v...)
=
split(pattern,string);
#
Name
array
elements
with
scalars
In
the
rst
of
these
cases,
it
is
assumed
that
the
v
ariable
`$_'
is
to
b
e
split
on
whitespace
c
haracters.
In
the
second
case,
w
e
decide
on
what
c
haracterthe
split
is
to
tak
e
place
and
on
what
string
the
function
is
to
act.
F
or
instance
@new_array
=
split(":","name:passwd:uid
:gid
:gc
os:h
ome:
she
ll")
;
The
result
is
a
sev
en
elemen
t
arra
y
called
`@new_array',
where
`$new_array[0]'
is
`name'
etc.
In
the
nal
example,
the
left
hand
side
sho
ws
that
w
e
wish
to
capture
elemen
ts
of
the
arra
y
in
a
named
set
of
scalar
v
ariables.
If
the
n
um
b
er
of
v
ariables
on
the
lefthand
side
is
few
er
than
the
n
um
b
er
of
strings
whic
h
are
generated
on
the
righ
t
hand
side,
they
are
discarded.
If
the
n
um
b
er
on
the
left
hand
side
is
greater,
then
the
remainder
v
ariables
are
empt
y
.
..
Asso
ciated
arra
ys
One
of
the
v
ery
nice
features
of
P
erl
is
the
abilit
y
to
use
one
string
as
an
index
to
another
string
in
an
arra
y
.
F
or
example,
w
e
can
mak
e
a
short
encyclopaedia
of
zo
o
animals
b
y
constructing
an
asso
ciativ
e
arra
y
in
whic
h
the
k
eys
(or
indices)
of
the
arra
y
are
the
names
of
animals,
and
the
con
ten
ts
of
the
arra
y
are
the
information
ab
out
them.
$animals{"Penguin"}
=
"A
suspicious
animal,
good
with
cheese
crackers...";
$animals{"dog"}
=
"Plays
stupid,
but
could
be
a
cover...";
if
($index
eq
"fish")
{
$animals{$index}
=
"Often
comes
in
square
boxes.
Very
cold.";
}
An
en
tire
asso
ciated
arra
y
is
written
`%array',
while
the
elemen
ts
are
`$array{$key}'.
P
erl
pro
vides
a
sp
ecial
asso
ciativ
e
arra
y
for
ev
ery
program
called
`%ENV'.
This
con
tains
the
envir
onment
variables
dened
in
the
paren
t
shell
whic
h
is
running
the
P
erl
program.
F
or
example
print
"Username
=
$ENV{"USER"}\n";
$ld
=
"LD_LIBRARY_PATH";
print
"The
link
editor
path
is
$ENV{$ld}\n";
T
o
get
the
curren
t
path
in
to
an
ordinary
arra
y
,
one
could
write,
@path_array=
split(":",$ENV{"PATH"});

0
The
unix
programming
en
vironmen
t
..
Arra
y
example
program
Here
is
an
example
whic
h
prin
ts
out
a
list
of
les
in
a
sp
ecied
directory
,
in
order
of
their
UNIX
protection
bits.
The
le
ast
protected
le
les
come
rst.
#!/local/bin/perl
#
#
Demonstration
of
arrays
and
associated
arrays.
#
Print
out
a
list
of
files,
sorted
by
protection,
#
so
that
the
least
secure
files
come
first.
#
#
e.g.
arrays
<list
of
words>
#
arrays
*.C
#
########################
####
####
###
####
####
###
####
####
###
###
print
"You
typed
in
",$#ARGV+,"
arguments
to
command\n";
if
($#ARGV
<
)
{
print
"That's
not
enough
to
do
anything
with!\n";
}
while
($next_arg
=
shift(@ARGV))
{
if
(
!
(
-f
$next_arg
||
-d
$next_arg))
{
print
"No
such
file:
$next_arg\n";
next;
}
($dev,$ino,$mode,$nlink,$
uid,
$gi
d,$r
dev,
$si
ze)
=
stat($next_arg);
$octalmode
=
sprintf("%o",$mode
&
0);
$assoc_array{$octalmode}
.=
$next_arg.
"
:
size
(".$size."),
mode
(".$octalmode.")\n";
}
print
"In
order:
LEAST
secure
first!\n\n";
foreach
$i
(reverse
sort
keys(%assoc_array))
{
print
$assoc_array{$i};
}

Chapter
:
P
erl

.
Lo
ops
and
conditionals
Here
are
some
of
the
most
commonly
used
decision-making
constructions
and
lo
ops
in
P
erl.
The
follo
wing
is
not
a
comprehensiv
e
list
{
for
that,
y
ou
will
ha
v
e
to
lo
ok
in
the
P
erl
bible:
Pr
o
gr
amming
Perl,
b
y
Larry
W
all
and
Randal
Sc
h
w
artz.
The
basic
pattern
follo
ws
the
C
programming
language
quite
closely
.
In
the
case
of
the
`for'
lo
op,
P
erl
has
b
oth
the
C-lik
e
v
ersion,
called
`for'
and
a
`foreach'
command
whic
h
is
lik
e
the
C-shell
implemen
tation.
if
(expression)
{
block;
}
else
{
block;
}
command
if
(expression);
unless
(expression)
{
block;
}
else
{
block;
}
while
(expression)
{
block;
}
do
{
block;
}
while
(expression);
for
(initializer
;
expression;
statemen
t
)
{
block;
}
foreach
v
ariable
(arra
y
)
{
block;
}


The
unix
programming
en
vironmen
t
In
all
cases,
the
`else'
clauses
ma
y
b
e
omitted.
Strangely
,
p
erl
do
es
not
ha
v
e
a
`switch'
statemen
t,
but
the
P
erl
b
o
ok
describ
es
ho
w
to
mak
e
one
using
the
features
pro
vided.
..
The
for
lo
op
The
for
lo
op
is
exactly
lik
e
that
in
C
or
C++
and
is
used
to
iterate
o
v
er
a
n
umerical
index,
lik
e
this:
for
($i
=
0;
$i
<
0;
$i++)
{
print
$i,
"\n";
}
..
The
foreac
h
lo
op
The
foreac
h
lo
op
is
lik
e
its
coun
terpart
in
the
C
shell.
It
is
used
for
reading
elemen
ts
one
b
y
one
from
a
regular
arra
y
.
F
or
example,
foreach
$i
(
@array
)
{
print
$i,
"\n";
}
..
Iterating
o
v
er
elemen
ts
in
arra
ys
One
of
the
main
uses
for
`for'
t
yp
e
lo
ops
is
to
iterate
o
v
er
successiv
e
v
alues
in
an
arra
y
.
This
can
b
e
done
in
t
w
o
w
a
ys
whic
h
sho
w
the
essen
tial
dierence
b
et
w
een
for
and
foreach.
If
w
e
w
an
t
to
fetc
h
eac
h
v
alue
in
an
arra
y
in
turn,
without
caring
ab
out
n
umerical
indices,
the
it
is
simp
est
to
use
the
foreach
lo
op.
@array
=
split("
","a
b
c
d
e
f
g");
foreach
$var
(
@array
)
{
print
$var,
"\n";
}
This
example
prin
ts
eac
h
letter
on
a
separate
line.
If,
on
the
other
hand,
w
e
are
in
terested
in
the
index,
for
the
purp
oses
of
some
calculation,
then
the
for
lo
op
is
preferable.
@array
=
split("
","a
b
c
d
e
f
g");
for
($i
=
0;
$i
<=
$#array;
$i++)
{

Chapter
:
P
erl

print
$array[$i],
"\n";
}
Notice
that,
unlik
e
the
for-lo
op
idiom
in
C/C++,
the
limit
is
`$i
<=
$#array',
i.e.
`less
than
or
equal
to'
rather
than
`less
than'.
This
is
b
ecause
the
`$#'
op
erator
do
es
not
return
the
n
um
b
er
of
elemen
ts
in
the
arra
y
but
rather
the
last
elemen
t.
Asso
ciated
arra
ys
are
sligh
tly
dieren
t,
since
they
do
not
use
n
umerical
k
eys.
Instead
they
use
a
set
of
strings,
lik
e
in
a
database,
so
that
y
ou
can
use
one
string
to
lo
ok
up
another.
In
order
to
iterate
o
v
er
the
v
alues
in
the
arra
y
w
e
need
to
get
a
list
of
these
strings.
The
keys
command
is
used
for
this.
$assoc{"mark"}
=
"cool";
$assoc{"GNU"}
=
"brave";
$assoc{"zebra"}
=
"stripy";
foreach
$var
(
keys
%assoc
)
{
print
"$var
,
$assoc{$var}
\n";
}
The
order
of
the
k
eys
is
not
dened
in
the
ab
o
v
e
example,
but
y
ou
can
c
ho
ose
to
sort
them
alphab
etically
b
y
writing
foreach
$var
(
sort
keys
%assoc
)
instead.
..
Iterating
o
v
er
lines
in
a
le
Since
P
erl
is
ab
out
le
handling
w
e
are
v
ery
in
terested
in
reading
les.
Unlik
e
C
and
C++,
p
erl
lik
es
to
read
les
line
b
y
line.
The
angle
brac
k
ets
are
used
for
this,
See
Section
.
[Files
in
p
erl],
page
.
Assuming
that
w
e
ha
v
e
some
le
handle
`<file>',
for
instance
`<STDIN>',
w
e
can
alw
a
ys
read
the
le
line
b
y
line
with
a
while-lo
op
lik
e
this.
while
($line
=
<file>)
{
print
$line;
}
Note
that
$line
includes
the
end
of
line
c
haracter
on
the
end
of
eac
h
line.
If
y
ou
w
an
t
to
remo
v
e
it,
y
ou
should
add
a
`c
hop'
command:
while
($line
=
<file>)
{
chop
$line;
print
"line
=
($line)\n";
}


The
unix
programming
en
vironmen
t
.
Files
in
p
erl
Op
ening
les
is
straigh
tforw
ard
in
P
erl.
Files
m
ust
b
e
op
ened
and
closed
using
{
w
ait
for
it
{
the
commands
`open'
and
`close'.
Y
ou
should
b
e
careful
to
close
les
after
y
ou
ha
v
e
nished
with
them
{
esp
ecially
if
y
ou
are
writing
to
a
le.
Files
are
buered
and
often
large
parts
of
a
le
are
not
actually
written
un
til
the
`close'
command
is
receiv
ed.
Three
les
are,
of
course,
alw
a
ys
op
en
for
ev
ery
program,
namely
`STDIN',
`STDOUT'and
`STDERR'.
F
ormally
,
to
op
en
a
le,
w
e
m
ust
obtain
a
le
descriptor
or
le
handle.
This
is
done
using
`open';
open
(file_descrip,"Filename
");
The
angular
brac
k
ets
`<..>'
are
used
to
read
from
the
le.
F
or
example,
$line
=
<file_descrip>;
reads
one
line
from
the
le
asso
ciated
with
`file_descrip'.
Let's
lo
ok
at
some
examples
of
ling
op
ening.
Here
is
ho
w
w
e
can
implemen
t
UNIX's
`cut'
and
`paste'
commands
in
p
erl:
#!/local/bin/perl
#
#
Cut
in
perl
#
#
Cut
second
column
while
(<>)
{
@cut_array
=
split;
print
"@cut_array[]\n";
}
This
is
the
simplest
w
a
y
to
op
en
a
le.
The
empt
y
le
descriptor
`<>'
tells
p
erl
to
tak
e
the
argumen
t
of
the
command
as
a
lename
and
op
en
that
le
for
reading.
This
is
really
short
for
`while($_=<STDIN>)'
with
the
standard
input
redirected
to
the
named
le.
The
`paste'program
can
b
e
written
as
follo
ws:
#!/local/bin/perl
#
#
Paste
in
perl
#
#
Two
files
only,
syntax
:
paste
file
file
#
open
(file,"@ARGV[0]")
||
die
"Can't
open
@ARGV[0]\n";
open
(file,"@ARGV[]")
||
die
"Can't
open
@ARGV[]\n";
while
(($line
=
<file>)
||
($line
=
<file>))

Chapter
:
P
erl

{
chop
$line;
chop
$line;
print
"$line
$line\n";
#
tab
character
between
}
Here
w
e
see
more
formally
ho
w
to
read
from
t
w
o
separate
les
at
the
same
time.
Notice
that,
b
y
putting
the
read
commands
in
to
the
test-expression
for
the
`while'
lo
op,
w
e
are
using
the
fact
that
`<..>'
returns
a
non-zero
(true)
v
alue
unless
w
e
ha
v
e
reac
hed
the
end
of
the
le.
T
o
write
and
app
end
to
les,
w
e
use
the
shell
redirection
sym
b
ols
inside
the
`open'
command.
open(fd,">
filename");
#
open
file
for
writing
open(fd,">>
filename");
#
open
file
for
appending
W
e
can
also
op
en
a
pip
e
from
an
arbitrary
UNIX
command
and
receiv
e
the
output
of
that
command
as
our
input:
open
(fd,"/bin/ps
aux
|
");
..
A
simple
p
erl
program
Let
us
no
w
write
the
simplest
p
erl
program
whic
h
illustrates
the
w
a
y
in
whic
h
p
erl
can
sa
v
e
time.
W
e
shall
write
it
in
three
dieren
t
w
a
ys
to
sho
w
what
the
short
cuts
mean.
Let
us
implemen
t
the
`cat'
command,
whic
h
copies
les
to
the
standard
output.
The
simplest
w
a
y
to
write
this
is
p
erl
is
the
follo
wing:
#!/local/bin/perl
while
(<>)
{
print;
}
Here
w
e
ha
v
e
made
hea
vy
use
of
the
man
y
default
assumptions
whic
h
p
erl
mak
es.
The
program
is
simple,
but
dicult
to
understand
for
no
vices.
First
of
all
w
e
use
the
default
le
handle
<>
whic
h
means,
tak
e
one
line
of
input
from
a
default
le.
This
ob
ject
returns
true
as
long
as
it
has
not
reac
hed
the
end
of
the
le,
so
this
lo
op
con
tin
ues
to
read
lines
un
til
it
reac
hes
the
end
of
le.
The
default
le
is
standard
input,
unless
this
script
is
in
v
ok
ed
with
a
command
line
argumen
t,
in
whic
h
case
the
argumen
t
is
treated
as
a
lename
and
p
erl
attempts
to
op
en
the
argumen
t-lename
for
reading.
The
print
statemen
t
has
no
argumen
t
telling
it
what
to
prin
t,
but
p
erl
tak
es
this
to
mean:
prin
t
the
default
v
ariable
`$_'.
W
e
can
therefore
write
this
more
explicitly
as
follo
ws:
#!/local/bin/perl
open
(HANDLE,"$ARGV[]");


The
unix
programming
en
vironmen
t
while
(<HANDLE>)
{
print
$_;
}
Here
w
e
ha
v
e
simply
lled
in
the
assumptions
explicitly
.
The
command
`<HANDLE>'
no
w
reads
a
single
line
from
the
named
le-handle
in
to
the
default
v
ariable
`$_'.
T
o
mak
e
this
program
more
general,
w
e
can
elimiate
the
defaults
en
tirely
.
#!/local/bin/perl
open
(HANDLE,"$ARGV[]");
while
($line=<HANDLE>)
{
print
$line;
}
..
==
and
`eq'
Be
careful
to
distinguish
b
et
w
een
the
comparison
op
erator
for
in
tegers
`=='
and
the
corresp
onding
op
erator
for
strings
`eq'.
These
do
not
w
ork
in
eac
h
other's
places
so
if
y
ou
get
the
wrong
comparison
op
erator
y
our
program
migh
t
not
w
ork
and
it
is
quite
dicult
to
nd
the
error.
..
c
hop
The
command
`chop'
cuts
o
the
last
c
haracter
of
a
string.
This
is
useful
for
remo
ving
newline
c
haracters
when
reading
les
etc.
The
syn
tax
is
chop;
#
chop
$_;
chop
$scalar;
#
remove
last
character
in
$scalar
.
P
erl
subroutines
Subroutines
are
indicated,
as
in
the
example
ab
o
v
e,
b
y
the
amp
ersand
`&'
sym
b
ol.
When
parameters
are
passed
to
a
P
erl
subroutine,
they
are
handed
o
v
er
as
an
arra
y
called
`@_'.
Whic
h
is
analogous
to
the
`$_'
v
ariable.
Here
is
a
simple
example:
#!/local/bin/perl
$a="silver";
$b="gold";
&PrintArgs($a,$b);
#
end
of
main
sub
PrintArgs

Chapter
:
P
erl

{
($local_a,$local_b)
=
@_;
print
"$local_a,
$local_b\n";
}
.
die
-
exit
on
error
When
a
program
has
to
quit
and
giv
e
a
message,
the
`die'
command
is
normally
used.
If
called
without
an
argumen
t,
P
erl
generates
its
o
wn
message
including
a
line
n
um
b
er
at
whic
h
the
error
o
ccurred.
T
o
include
y
our
o
wn
message,
y
ou
write
die
"My
message....";
If
the
string
is
terminated
with
a
`\n'
newline
c
haracter,
the
line
n
um
b
er
of
the
error
is
not
prin
ted,
otherwise
P
erl
app
ends
the
line
n
um
b
er
to
y
our
string.
When
op
ening
les,
it
is
common
to
see
the
syn
tax:
open
(filehandle,"Filename")
||
die
"Can't
open...";
The
logical
`OR'
sym
b
ol
is
used,
b
ecause
`open'
returns
true
if
all
go
es
w
ell,
in
whic
h
case
the
righ
t
hand
side
is
nev
er
ev
aluated.
If
`open'
is
false,
then
die
is
executed.
Y
ou
can
decide
for
y
ourself
whether
or
not
y
ou
think
this
is
go
o
d
programming
st
yle
{
w
e
men
tion
it
here
b
ecause
it
is
common
practice.
.
The
stat()
idiom
The
unix
library
function
stat()
is
used
to
nd
out
information
ab
out
a
giv
en
le.
This
function
is
a
v
ailable
b
oth
in
C
and
in
P
erl.
In
p
erl,
it
returns
an
arra
y
of
v
alues.
Usually
w
e
are
in
terested
in
kno
wing
the
access
p
ermissions
of
a
le.
stat()
is
called
using
the
syn
tax
@array
=
stat
("lename
");
or
alternativ
ely
,
using
a
named
arra
y
($device,$inode,$mode)
=
stat("lename
");
The
v
alue
returned
in
the
mo
de
v
ariable
is
a
bit-pattern,
See
Section
.
[Protection
bits],
page
.
The
most
useful
w
a
y
of
treating
these
bit
patterns
is
to
use
o
ctal
n
um
b
ers
to
in
terpret
their
meaning.
T
o
nd
out
whether
a
le
is
readable
or
writable
to
a
group
of
users,
w
e
use
a
program-
ming
idiom
whic
h
is
v
ery
common
for
dealing
with
bit
patterns:
rst
w
e
dene
a
mask
whic
h
zero
es
out
all
of
the
bits
in
the
mo
de
string
except
those
whic
h
w
e
are
sp
ecically
in
terested
in.
This
is
done
b
y
dening
a
mask
v
alue
in
whic
h
the
bits
w
e
w
an
t
are
set
to

and
all
others
are
set
to
zero.
Then
w
e
AND
the
mask
with
the
mo
de
string.
If
the
result
is
dieren
t
from
zero
then
w
e
kno
w
that
all
of
the
bits
w
ere
also
set
in
the
mo
de
string.
As
in
C,
the
bit
wise
AND
op
erator
in
p
erl
is
called
`&'.


The
unix
programming
en
vironmen
t
F
or
example,
to
test
whether
a
le
is
writable
to
other
users
in
the
same
group
as
the
le,
w
e
w
ould
write
the
follo
wing.
$mask
=
00;
#
Leading
0
means
octal
number
($device,$inode,$mode)
=
stat("le
");
if
($mode
&
$mask)
{
print
"File
is
writable
by
the
group\n";
}
Here
the

in
the
second
o
ctal
n
um
b
er
means
"write",
the
fact
that
it
is
the
second
o
ctal
n
um
b
er
from
the
righ
t
means
that
it
refers
to
"group".
Th
us
the
result
of
the
if-test
is
only
true
if
that
particular
bit
is
true.
W
e
shall
see
this
idiom
in
action
b
elo
w.
.	
P
erl
example
programs
.	.
The
passwd
program
and
`crypt()'
function
Here
is
a
simple
implemen
tation
of
the
UNIX
`passwd'
program
in
P
erl.
#!/local/bin/perl
#
#
A
perl
version
of
the
passwd
program.
#
#
Note
-
the
real
passwd
program
needs
to
be
much
more
#
secure
than
this
one.
This
is
just
to
demonstrate
the
#
use
of
the
crypt()
function.
#
########################
####
####
###
####
####
###
####
####
###
####
print
"Changing
passwd
for
$ENV{'USER'}
on
$ENV{'HOST'}\n";
system
'stty','-echo';
print
"Old
passwd:
";
$oldpwd
=
<STDIN>;
chop
$oldpwd;
($name,$coded_pwd,$uid,$
gid,
$x,$
y,$
z,$g
cos,
$ho
me,$
shel
l)
=
getpwnam($ENV{"USER"});
if
(crypt($oldpwd,$coded_pwd
)
ne
$coded_pwd)
{
print
"\nPasswd
incorrect\n";
exit
();

Chapter
:
P
erl
	
}
$oldpwd
=
"";
#
Destroy
the
evidence!
print
"\nNew
passwd:
";
$newpwd
=
<STDIN>;
print
"\nRepeat
new
passwd:
";
$rnewpwd
=
<STDIN>;
chop
$newpwd;
chop
$rnewpwd;
if
($newpwd
ne
$rnewpwd)
{
print
"\n
Incorrectly
typed.
Password
unchanged.\n";
exit
();
}
$salt
=
rand();
$new_coded_pwd
=
crypt($newpwd,$salt);
print
"\n\n$name:$new_coded_pwd:
$ui
d:$g
id:$
gco
s:$h
ome:
$sh
ell\
n";
.	.
Example
with
`fork()'
The
follo
wing
example
uses
the
`fork'
function
to
start
a
daemon
whic
h
go
es
in
to
the
bac
kground
and
w
atc
hes
the
system
to
whic
h
pro
cess
is
using
the
greatest
amoun
t
of
CPU
time
eac
h
min
ute.
A
pip
e
is
op
ened
from
the
BSD
`ps'
command.
#!/local/bin/perl
#
#
A
fork()
demo.
This
program
will
sit
in
the
background
and
#
make
a
list
of
the
process
which
uses
the
maximum
CPU
average
#
at

minute
intervals.
On
a
quiet
BSD
like
system
this
will
#
normally
be
the
swapper
(long
term
scheduler).
#
$true
=
;
$logfile="perl.cpu.logfi
le";
print
"Max
CPU
logfile,
forking
daemon...\n";
if
(fork())
{
exit(0);

	0
The
unix
programming
en
vironmen
t
}
while
($true)
{
open
(logfile,">>
$logfile")
||
die
"Can't
open
$logfile\n";
open
(ps,"/bin/ps
aux
|")
||
die
"Couldn't
open
a
pipe
from
ps
!!\n";
$skip_first_line
=
<ps>;
$max_process
=
<ps>;
close(ps);
print
logfile
$max_process;
close(logfile);
sleep
0;
($a,$b,$c,$d,$e,$f,$g,$si
ze)
=
stat($logfile);
if
($size
>
00)
{
print
STDERR
"Log
file
getting
big,
better
quit!\n";
exit(0);
}
}
.	.
Example
reading
databases
Here
is
an
example
program
with
sev
eral
of
the
ab
o
v
e
features
demonstrated
sim
ultane-
ously
.
This
follo
wing
program
lists
all
users
who
ha
v
e
home
directories
on
the
curren
t
host.
If
the
home
area
has
sub-directories,
corresp
onding
to
groups,
then
this
is
sp
ecied
on
the
command
line.
The
w
ord
`home'
causes
the
program
to
prin
t
out
the
home
directories
of
the
users.
#!/local/bin/perl
########################
####
####
###
####
####
###
####
####
###
####
####
#
#
#
allusers
-
list
all
users
on
named
host,
i.e.
all
#
users
who
can
log
into
this
machine.
#
#
Syntax:
allusers
group
#
allusers
mygroup
home
#
allusers
myhost
group
home
#
#
NOTE
:
This
command
returns
only
users
who
are
registered
on
#
the
current
host.
It
will
not
find
users
which
cannot
#
be
validated
in
the
passwd
file,
or
in
the
named
groups
#
in
NIS.
It
assumes
that
the
users
belonging
to
#
different
groups
are
saved
in
subdirectories
of
#
/home/hostname.

Chapter
:
P
erl
	
#
########################
####
####
###
####
####
###
####
####
###
####
####
#
&arguments();
die
"\n"
if
(
!
-d
"/home/$server"
);
$disks
=
`/bin/ls
-d
/home/$server/$group`;
foreach
$home
(split(/\s/,$disks))
{
open
(LS,"cd
$home;
/bin/ls
$home
|")
||
die
"allusers:
Pipe
didn't
open";
while
(<LS>)
{
$exists
=
"";
($user)
=
split;
($exists,$pw,$uid,$gid,$qu
,$c
m,$g
cos,
$di
r)=g
etpw
nam
($us
er);
if
($exists)
{
if
($printhomes)
{
print
"$dir\n";
}
else
{
print
"$user\n";
}
}
}
close(LS);
}
########################
####
####
###
####
####
###
####
####
##
sub
arguments
{
$printhomes
=
0;
$group
=
"*";
$server
=
`/bin/hostname`;
chop
$server;
foreach
$arg
(@ARGV)
{
if
(substr($arg,0,)
eq
"u")
{
$group
=
$arg;
next;

	
The
unix
programming
en
vironmen
t
}
if
($arg
eq
"home")
{
$printhomes
=
;
next;
}
$server=
$arg;
#default
is
to
interpret
as
a
server.
}
}
.0
P
attern
matc
hing
and
extraction
P
erl
has
regular
expression
op
erators
for
iden
tifying
patterns.
The
op
erator
/regular
expression/
returns
true
of
false
dep
ending
on
whether
the
regular
expression
matc
hes
the
con
ten
ts
of
$_.
F
or
example
if
(/perl/)
{
print
"String
contains
perl
as
a
substring";
}
if
(/(Sat|Sun)day/)
{
print
"Weekend
day....";
}
The
eect
is
rather
lik
e
the
grep
command.
T
o
use
this
op
erator
on
other
v
ariables
y
ou
w
ould
write:
$variable
=~
/regexp
/
Regular
expression
can
con
tain
paren
thetic
sub-expressions,
e.g.
if
(/(Sat|Sun)day
(..)th
(.*)/)
{
$first
=
$;
$second
=
$;
$third
=
$;
}
in
whic
h
case
p
erl
places
the
ob
jects
matc
hed
b
y
suc
h
sub-expressions
in
the
v
ariables
$,
$
etc.

Chapter
:
P
erl
	
.
Searc
hing
and
replacing
text
The
`sed'-lik
e
function
for
replacing
all
o
ccurances
of
a
string
is
easily
implemen
ted
in
P
erl
using
while
(<input>)
{
s/$search/$replace/g;
print
output;
}
This
example
replaces
the
string
inside
the
default
v
ariable.
T
o
replace
in
a
general
v
ariable
w
e
use
the
op
erator
`=~',
with
syn
tax:
$variable
=~
s/searc
h/replace
/
Here
is
an
example
of
some
of
this
op
erator
in
use.
The
follo
wing
is
a
program
whic
h
searc
hes
and
replaces
a
string
in
sev
eral
les.
This
is
useful
program
indeed
for
making
a
c
hange
globally
in
a
group
of
les!
The
program
is
called
`le-replace'.
#!/local/bin/perl
########################
####
####
###
####
####
###
####
####
###
####
#
#
#
Look
through
files
for
findstring
and
change
to
newstring
#
in
all
files.
#
########################
####
####
###
####
####
###
####
####
###
####
#
#
#
Define
a
temporary
file
and
check
it
doesn't
exist
#
$outputfile
=
"tmpmarkfind";
unlink
$outputfile;
#
#
Check
command
line
for
list
of
files
#
if
($#ARGV
<
0)
{
die
"Syntax:
file-replace
[file
list]\n";
}
print
"Enter
the
string
you
want
to
find
(Don't
use
quotes):\n\n:";
$findstring=<STDIN>;
chop
$findstring;
print
"Enter
the
string
you
want
to
replace
with
(Don't
use
quotes):\n\n:";
$replacestring=<STDIN>;
chop
$replacestring;
#

	
The
unix
programming
en
vironmen
t
print
"\nFind:
$findstring\n";
print
"Replace:
$replacestring\n";
print
"\nConfirm
(y/n)
";
$y
=
<STDIN>;
chop
$y;
if
(
$y
ne
"y")
{
die
"Aborted
--
nothing
done.\n";
}
else
{
print
"Use
CTRL-C
to
interrupt...\n";
}
#
#
Now
shift
default
array
@ARGV
to
get
arguments

by

#
while
($file
=
shift)
{
if
($file
eq
"file-replace")
{
print
"Findmark
will
not
operate
on
itself!";
next;
}
#
#
Save
existing
mode
of
file
for
later
#
($dev,$ino,$mode)=stat($f
ile)
;
open
(INPUT,$file)
||
warn
"Couldn't
open
$file\n";
open
(OUTPUT,">
$outputfile")
||
warn
"Can't
open
tmp";
$notify
=
;
while
(<INPUT>)
{
if
(/$findstring/
&&
$notify)
{
print
"Fixing
$file...\n";
$notify
=
0;
}
s/$findstring/$replacestri
ng/
g;
print
OUTPUT;
}

Chapter
:
P
erl
	
close
(OUTPUT);
#
#
If
nothing
went
wrong
(if
outfile
not
empty)
#
move
temp
file
to
original
and
reset
the
#
file
mode
saved
above
#
if
(!
-z
$outputfile)
{
rename
($outputfile,$file);
chmod
($mode,$file);
}
else
{
print
"Warning:
file
empty!\n.";
}
}
Similarly
w
e
can
searc
h
for
lines
con
taining
a
string.
Here
is
the
grep
program
written
in
p
erl
#!/local/bin/perl
#
#
grep
as
a
perl
program
#
#
Check
arguments
etc
while
(<>)
{
print
if
(/$ARGV[]/);
}
The
op
erator
`/searc
h-string
/'
returns
true
if
the
searc
h
string
is
a
substring
of
the
default
v
ariable
$_.
T
o
searc
h
an
arbitrary
string,
w
e
write
....
if
(teststring
=~
/searc
h-string
/);
Here
teststring
is
searc
hed
for
o
ccurrances
of
searc
h-string
and
the
result
is
true
if
one
is
found.
In
p
erl
y
ou
can
use
regular
expressions
to
searc
h
for
text
patterns.
Note
ho
w
ev
er
that,
lik
e
all
regular
expression
dialects,
p
erl
has
its
o
wn
con
v
en
tions.
F
or
example
the
dollar
sign
do
es
not
mean
"matc
h
the
end
of
line"
in
p
erl,
instead
one
uses
the
`\n'
sym
b
ol.
Here
is
an
example
program
whic
h
illustrates
the
use
of
regular
expressions
in
p
erl:
#!/local/bin/perl
#
#
Test
regular
expressions
in
perl
#
#
NB
-
careful
with
\
$
*
symbols
etc.
Use
''
quotes
since

	
The
unix
programming
en
vironmen
t
#
the
shell
interprets
these!
#
open
(FILE,"regex_test");
$regex
=
$ARGV[$#ARGV];
print
"Looking
for
$ARGV[$#ARGV]
in
file...\n";
while
(<FILE>)
{
if
(/$regex/)
{
print;
}
}
#
#
Test
like
this:
#
#
regex
'.*'
-
prints
every
line
(matches
everything)
#
regex
'.'
-
all
lines
except
those
containing
only
blanks
#
(.
doesn't
match
ws/white-space)
#
regex
'[a-z]'
-
matches
any
line
containing
lowercase
#
regex
'[^a-z]'
-
matches
any
line
containg
something
which
is
#
not
lowercase
a-z
#
regex
'[A-Za-z]'
-
matches
any
line
containing
letters
of
any
kind
#
regex
'[0-	]'
-
match
any
line
containing
numbers
#
regex
'#.*'
-
line
containing
a
hash
symbol
followed
by
anything
#
regex
'^#.*'
-
line
starting
with
hash
symbol
(first
char)
#
regex
';\n'
-
match
line
ending
in
a
semi-colon
#
T
ry
running
this
program
with
the
test
data
on
the
follo
wing
le
whic
h
is
called
`regex_test'
in
the
example
program.
#
A
line
beginning
with
a
hash
symbol
JUST
UPPERCASE
LETTERS
just
lowercase
letters
Letters
and
numbers


A
line
ending
with
a
semi-colon;

Chapter
:
P
erl
	
Line
with
a
comment
#
COMMENT...
.
Example:
con
v
ert
mail
to
WWW
pages
Here
is
an
example
program
whic
h
y
ou
could
use
to
automatically
turn
a
mail
message
of
the
form
From:
Newswire
To:
Mailhtml
Subject:
Nothing
happened
On
the
th
February
at
kl.
0	:0
nothing
happened.
No
footprints
were
found
leading
to
the
scene
of
a
terrible
murder,
no
evidence
of
a
struggle
....
etc
etc
in
to
an
h
tml-le
for
the
w
orld
wide
w
eb.
The
program
w
orks
b
y
extracting
the
message
b
o
dy
and
sub
ject
from
the
mail
and
writing
h
tml-commands
around
these
to
mak
e
a
w
eb
page.
The
sub
ject
eld
of
the
mail
b
ecomes
the
title.
The
other
headers
get
skipp
ed,
since
the
script
searc
hes
for
lines
con
taining
the
sequence
"colon-space"
or
`:
'.
A
regular
expression
is
used
for
this.
#!/local/bin/perl
#
#
Make
HTML
from
mail
#
&BeginWebPage();
&ReadNewMail();
&EndWebPage();
########################
####
####
###
####
####
###
####
####
###
#
sub
BeginWebPage
{
print
"<HTML>\n";
print
"<BODY>\n";
}
########################
####
####
###
####
####
###
####
####
###
#
sub
EndWebPage
{
print
"</BODY>\n";
print
"</HTML>\n";
}

	
The
unix
programming
en
vironmen
t
########################
####
####
###
####
####
###
####
####
###
#
sub
ReadNewMail
{
while
(<>)
{
if
(/Subject:/)
#
Search
for
subject
line
{
#
Extract
subject
text...
chop;
($left,$right)
=
split(":",$_);
print
"<H>
$right
</H>\n";
next;
}
elsif
(/.*:
.*/)
#
Search
for
-
anything:
anything
{
next;
#
skip
other
headers
}
print;
}
}
.
Generate
WWW
pages
automagically
The
follo
wing
program
scans
through
the
passw
ord
database
and
build
a
standardized
h
tml-page
for
eac
h
user
it
nds
there.
It
lls
in
the
name
of
the
user
in
eac
h
case.
Note
the
use
of
the
`<<'
op
erator
for
extended
input,
already
used
in
the
con
text
of
the
shell,
See
Section
.
[Pip
es
and
redirection],
page
.
This
allo
ws
us
to
format
a
whole
passage
of
text,
inserting
v
ariables
at
strategic
places,
and
a
v
oid
ha
ving
to
the
print
o
v
er
man
y
lines.
#!/local/bin/perl
#
#
Build
a
default
home
page
for
each
user
in
/etc/passwd
#
#
########################
####
####
###
####
####
###
####
####
###
####
####
###
#
Level
0
(main)
########################
####
####
###
####
####
###
####
####
###
####
####
###
$true
=
;
$false
=
0;
#
First
build
an
associated
array
of
users
and
full
names

Chapter
:
P
erl
		
setpwent();
while
($true)
{
($name,$passwd,$uid,$gid,
$quo
ta,
$com
ment
,$f
ulln
ame)
=
getpwent;
$FullName{$name}
=
$fullname;
print
"$name
-
$FullName{$name}\n";
last
if
($name
eq
"");
}
print
"\n";
#
Now
make
a
unique
filename
for
each
page
and
open
a
file
foreach
$user
(sort
keys(%FullName))
{
next
if
($user
eq
"");
print
"Making
page
for
$user\n";
$outputfile
=
"$user.html";
open
(OUT,">
$outputfile")
||
die
"Can't
open
$outputfile\n";
&MakePage;
close
(OUT);
}
########################
####
####
###
####
####
###
####
####
###
####
####
###
#
Level

########################
####
####
###
####
####
###
####
####
###
####
####
###
sub
MakePage
{
print
OUT
<<ENDMARKER;
<HTML>
<BODY>
<HEAD><TITLE>$FullName{$
user
}'s
Home
Page</TITLE></HEAD>
<H>$FullName{$user}'s
Home
Page</H>
Hi
welcome
to
my
home
page.
In
case
you
hadn't
got
it
yet
my
name
is:
$FullName{$user}...
I
study
at
<a
href=http://www.iu.hioslo
.no>
H&o
slas
h;gs
kol
en
i
Oslo</a>.

00
The
unix
programming
en
vironmen
t
</BODY>
</HTML>
ENDMARKER
}
.
Other
supp
orted
functions
P
erl
has
v
ery
man
y
functions
whic
h
come
directly
from
the
C
library
.
T
o
giv
e
a
taster,
a
few
are
listed
here.
The
P
erl
b
o
ok
con
tains
a
comprehensiv
e
description
of
these.
F
ork
The
standard
UNIX
fork
command
for
spa
wning
new
pro
cesses.
So
ckets
Supp
ort
for
net
w
ork
so
c
k
et
comm
unication.
Dir
e
ctories
Directory
op
ening
and
handling
routines.
Datab
ases
Reading
from
the
passw
ord
les
and
the
host
databases
is
supp
orted
through
the
standard
C
functions
`getpasswdbyname'
etc.
dressed
up
to
lo
ok
lik
e
P
erl.
Crypt
The
passw
ord
encryption
function.
R
e
gexp
Regular
expressions
and
pattern
matc
hing,
searc
h
and
replace
functions
as
in
`sed'.
Op
er
ators
P
erl
has
the
full
set
of
C's
logical
op
erators.
File
testing
T
ests
from
the
shell
lik
e
`if
(-f
file)'.
Here
are
some
of
the
most
frequen
tly
used
functions
chmod
Change
the
le
mo
de
of
a
le.
e.g.
chmod
,lename
chdir
Change
the
curren
t
w
orking
directory
.
e.g.
chdir
/etc
stat
Get
info
ab
out
p
ermissions,
o
wnership
and
t
yp
e
of
a
le.
open
Op
en
a
le
for
reading,
`>'
writing,
`|'
as
a
pip
e.
close
Close
an
op
en
le
handle.
system
Execute
a
shell
command
as
a
c
hild
pro
cess.
e.g.
system
"ls";
split
Split
a
string
v
ariable
in
to
an
arra
y
of
elemen
ts,
b
y
searc
hing
for
a
sp
ecial
c
haracter
(space
or
`:'
etc.)
e.g.
@array=split(":",$string)
.
rename
Rename
a
le.
e.g.
rename
old
name
new-name
mkdir
Mak
e
a
new
directory
.
mkdir
newdir
shift
Read
the
rst
elemen
t
of
an
arra
y
and
delete
it,
shifting
all
the
arra
y
elemen
ts
do
wn
b
y
one.
(e.g.
$first=shift(@array);).
chop
Chops
o
the
last
c
haracter
of
a
string.
Often
used
for
deleting
the
end-of-line
c
haracter
when
reading
from
a
le.

Chapter
:
P
erl
0
oct
In
terprets
a
n
um
b
er
as
o
ctal
(con
v
erts
to
decimal).
e.g.
$decimal
=
oct();
kill
Send
a
kill
signal
to
a
list
of
pro
cesses.
e.g.
kill
-	,
pid,pid...
Y
ou
should
explore
P
erl's
p
ossibilities
y
ourself.
P
erl
is
a
go
o
d
alternativ
e
to
the
shell
whic
h
has
m
uc
h
of
the
p
o
w
er
of
C
and
is
therefore
ideal
for
simple
and
more
complex
system
programming
tasks.
If
y
ou
in
tend
to
b
e
a
system
administrator
for
UNIX
systems,
y
ou
could
do
m
uc
h
w
orse
than
to
read
the
P
erl
b
o
ok
and
learn
P
erl
inside
out.
.
Summary
The
Practical
Extraction
and
Rep
ort
Language
is
a
p
o
w
erful
to
ol
whic
h
go
es
b
ey
ond
shell
programming,
but
whic
h
retains
m
uc
h
of
the
immediateness
of
shell
programming
in
a
more
formal
programming
en
vironmen
t.
The
success
of
P
erl
has
led
man
y
programmers
to
use
it
exclusiv
ely
.
In
the
next
section,
I
w
ould
lik
e
to
argue
that
programming
directly
in
C
is
not
m
uc
h
harder.
In
fact
it
has
adv
an
tages
in
the
long
run.
The
p
o
w
er
of
P
erl
is
that
it
is
as
imme
diate
as
shell
program-
ming.
If
y
ou
are
inexp
erienced,
P
erl
is
a
little
easier
than
C
b
ecause
man
y
features
are
ready
programmed
in
to
the
language,
but
with
time
one
also
builds
up
a
rep
ertoire
of
C
functions
whic
h
can
do
the
same
tric
ks.
.
Exercises
.
W
rite
a
progam
whic
h
prin
ts
out
all
of
its
argumen
ts
alphab
etically
together
with
the
rst
and
the
last,
and
the
n
um
b
er
of
argumen
ts.
.
W
rite
a
program
whic
h
prin
ts
out
the
pathname
of
the
home
directory
for
a
giv
en
user.
The
user's
login
name
should
b
e
giv
en
as
an
argumen
t.
.
W
rite
a
program
called
`searc
h-replace'
whic
h
lo
oks
for
a
giv
en
string
in
a
list
of
les
and
replaces
it
with
a
new
string.
Y
ou
should
b
e
able
to
sp
ecify
a
list
of
les
us-
ing
ordinary
unix
wildcards.
e.g.
`search-replace
search-string
replace-string
*.text'.
This
is
a
dangerous
op
eration!
What
if
the
user
t
yp
es
the
strings
incorrectly?
Ho
w
can
y
ou
ma
y
the
program
safer?
.
W
rite
a
program
whic
h
op
ens
a
pip
e
from
`ps'
and
computes
the
total
cpu-time
used
b
y
eac
h
user.
Prin
t
the
results
in
order
of
maxim
um
to
minim
um.
Hin
t:
use
an
asso
ciated
arra
y
to
store
the
information.
.
W
rite
a
program
whic
h
forks
and
go
es
in
to
the
bac
kground.
Mak
e
the
program
send
y
ou
mail
when
some
other
user
of
y
our
c
hoice
logs
in.
Use
sleep
to
c
hec
k
only
ev
ery
few
min
utes.
.
Op
en
a
pip
e
from
`find'
and
collect
statistics
o
v
er
ho
w
man
y
les
there
are
in
all
of
y
our
sub-directories.
.
Pro
ject
W
rite
a
program
whic
h
c
hec
ks
the
`sanit
y'
of
y
our
UNIX
system.
.
Chec
k
that
the
passw
ord
le
/etc/passwd
is
not
writable
b
y
general
users.
.
Chec
k
that
the
pro
cesses
`cron'
and
`sendmail'
are
running.

0
The
unix
programming
en
vironmen
t
.
Chec
k
that,
if
the
le
`/etc/exports'
or
`/etc/dfs/dfstab'
exists,
the
nfsd
daemon
is
running.
.
Chec
k
that
if
the
lesystem
table
`/etc/fstab'
(or
its
equiv
alen
t
on
non-BSD
systems)
con
tains
NFS
moun
ted
lesystems,
the
`biod'
or
`nfsiod'
daemon
is
running.
.
Chec
k
that
the
le
`/etc/resolv.conf'
con
tains
the
correct
domain
name.
It
ma
y
or
ma
y
not
b
e
the
same
as
that
returned
b
y
the
shell
command
`domainname'.
If
it
is
not
the
same,
y
ou
should
prin
t
the
message
`NIS
domain
has
dieren
t
name
to
DNS
domain'.

Chapter
:
WWW
and
CGI
programming
0

WWW
and
CGI
programming
CGI
stands
for
the
Common
Gatew
a
y
In
terface.
It
is
the
name
giv
en
to
scripts
whic
h
can
b
e
executed
from
within
pages
of
the
w
orld
wide
w
eb.
Although
it
is
p
ossible
to
use
an
y
language
in
CGI
programs
(hence
the
w
ord
`common'),
the
usual
c
hoice
is
P
erl,
b
ecause
of
the
ease
with
whic
h
P
erl
can
handle
text.
The
CGI
in
terface
is
prett
y
unin
telligen
t,
in
order
to
b
e
as
general
as
p
ossible,
so
w
e
need
to
do
a
bit
of
w
ork
in
order
to
mak
e
scripts
w
ork.
.
P
ermissions
The
k
ey
thing
ab
out
the
WWW
whic
h
often
causes
a
lot
of
confusion
is
that
the
W
service
runs
with
a
user
ID
of
`nob
o
dy'.
The
purp
ose
of
this
is
to
ensure
that
nob
o
dy
has
the
righ
t
to
read
or
write
les
unless
they
are
op
ened
v
ery
explicitly
b
y
the
user
who
o
wns
them.
In
order
for
les
to
b
e
readable
on
the
WWW,
they
m
ust
ha
v
e
le
mo
de
`'
and
they
m
ust
lie
in
a
directory
whic
h
has
mo
de
`'.
In
order
for
a
CGI
program
to
b
e
executable,
it
m
ust
ha
v
e
p
ermission
`'
and
in
order
for
suc
h
a
program
to
write
to
a
le
in
a
user's
directory
,
it
m
ust
b
e
p
ossible
for
the
le
to
b
e
created
(if
necessary)
and
ev
ery
one
m
ust
b
e
able
to
write
to
it.
That
means
that
les
whic
h
are
written
to
b
y
the
WWW
m
ust
ha
v
e
mo
de
`'
and
m
ust
either
exist
already
or
lie
in
a
directory
with
p
ermission
`'

.
.
Proto
cols
CGI
script
programs
comm
unicate
with
W
bro
wsers
using
a
v
ery
simple
proto
col.
It
go
es
lik
e
this:

A
w
eb
page
sends
data
to
a
script
using
the
`forms'
in
terface.
Those
data
are
concate-
nated
in
to
a
single
line.
The
data
in
separate
elds
of
a
form
are
separated
b
y
`&'
signs.
New
lines
are
replaced
b
y
the
text
`%0D%0A',
whic
h
is
the
DOS
ASCI
I
represen
tation
of
a
newline,
and
spaces
are
replaced
b
y
`+'
sym
b
ols.

A
CGI
script
reads
this
single
line
of
text
on
the
standard
input.

The
CGI
script
replies
to
the
w
eb
bro
wser.
The
rst
line
of
the
reply
must
b
e
a
line
whic
h
is
tells
the
bro
wser
what
mime-t
yp
e
the
data
are
sen
t
in.
Usually
,
a
CGI
script
replies
in
HTML
co
de,
in
whic
h
case
the
rst
line
in
the
reply
m
ust
b
e:
Content-type:
text/html
This
m
ust
b
e
follo
w
ed
b
y
a
blank
line.
.
HTML
co
ding
of
forms
T
o
start
a
CGI
program
from
a
w
eb
page
w
e
use
a
form
whic
h
is
a
part
of
the
HTML
co
de
enclosed
with
the
paren
theses

Y
ou
could
also
set
the
stic
ky
bit
`'
in
order
to
prev
en
t
malicious
users
from
deleting
y
our
le.

0
The
unix
programming
en
vironmen
t
<FORM
method="POST"
ACTION="/cgi-script-alias
/pro
gram
.pl
">
...
</FORM>
The
metho
d
`p
ost'
means
that
the
data
whic
h
get
t
yp
ed
in
to
this
form
will
b
e
pip
ed
in
to
the
CGI
program
via
its
standard
input.
The
`action'
sp
ecies
whic
h
program
y
ou
w
an
t
to
start.
Note
that
y
ou
cannot
simply
use
the
absolute
path
of
the
le,
for
securit
y
reasons.
Y
ou
m
ust
use
something
called
a
`script
alias'
to
tell
the
w
eb
bro
wser
where
to
nd
the
program.
If
y
ou
do
not
ha
v
e
a
script
alias
dened
for
y
ou
p
ersonally
,
then
y
ou
need
to
get
one
from
y
our
system
administrator.
By
using
a
script
alias,
no
one
from
outside
y
our
site
can
see
where
y
our
les
are
lo
cated,
only
that
y
ou
ha
v
e
a
`cgi-bin'
area
somewhere
on
y
our
system.
Within
these
paren
theses,
y
ou
can
arrange
to
collect
dieren
t
kinds
of
input.
The
sim-
plest
kind
of
input
is
just
a
button
whic
h
starts
the
CGI
program.
This
has
the
form
<INPUT
TYPE="submit"
VALUE="Start
my
program">
This
co
de
creates
a
button.
When
y
ou
clic
k
on
it
the
program
in
y
our
`action'
string
gets
started.
More
generally
,
y
ou
will
w
an
t
to
create
input
b
o
xes
where
y
ou
can
t
yp
e
in
data.
T
o
create
a
single
line
input
eld,
y
ou
use
the
follo
wing
syn
tax:
<INPUT
NAME="variable-name"
SIZE=0>
This
creates
a
single
line
text
eld
of
width
0
c
haracters.
This
is
not
the
limit
on
the
length
of
the
string
whic
h
can
b
e
t
yp
ed
in
to
the
eld,
only
a
limit
on
the
amoun
t
whic
h
is
visible
at
an
y
time.
It
is
for
visual
formatting
only
.
The
NAME
eld
is
used
to
iden
tify
the
data
in
the
CGI
script.
The
string
y
ou
en
ter
here
will
b
e
sen
t
to
the
CGI
script
in
the
form
`variable-name=value
of
input...'.
Another
t
yp
e
of
input
is
a
text
area.
This
is
a
larger
b
o
x
where
one
can
t
yp
e
in
text
on
sev
eral
lines.
The
syn
tax
is:
<TEXTAREA
NAME="variable-name"
ROW=0
COLS=0>
whic
h
means:
create
a
text
area
of
ft
y
ro
ws
b
y
ft
y
columns
with
a
prompt
to
the
left
of
the
b
o
x.
Again,
the
size
has
only
to
do
with
the
visual
formatting,
not
to
do
with
limits
on
the
amoun
t
of
text
whic
h
can
b
e
en
tered.
As
an
example,
let's
create
a
WWW
page
with
a
complete
form
whic
h
can
b
e
used
to
mak
e
a
guest
b
o
ok,
or
order
form.
<HTML>
<HEAD>
<TITLE>Example
form</TITLE>
<!--
Comment:
Mark
Burgess,
-Jan-		
-->
<LINK
REV="made"
HREF="mailto:mark@iu.hiosl
o.n
o">
</HEAD>
<BODY>
<CENTER><H>Write
in
my
guest
book...</H></CENTER>
<HR>

Chapter
:
WWW
and
CGI
programming
0
<CENTER><H>Please
leave
a
comment
using
the
form
below.</H><P>
<FORM
method="POST"
ACTION="/cgi-bin-mark/c
omm
ent.
pl">
Your
Name/e-mail:
<INPUT
NAME="variable"
SIZE=0>
<BR><BR>
<P>
<TEXTAREA
NAME="variable"
cols=0
rows=></TEXTAREA>
<P>
<INPUT
TYPE=submit
VALUE="Add
message
to
book">
<INPUT
TYPE=reset
VALUE="Clear
message">
</FORM>
<P>
</BODY>
</HTML>
The
reset
button
clears
the
form.
When
the
submit
button
is
pressed,
the
CGI
program
is
activ
ated.
.
P
erl
and
the
w
eb
..
In
terpreting
data
from
forms
T
o
in
terpret
and
resp
ond
to
the
data
in
a
form,
w
e
m
ust
write
a
program
whic
h
satsies
the
proto
col
ab
o
v
e,
See
Section
.
[Proto
cols],
page
0.
W
e
use
p
erl
as
a
script
langauge.
The
simplest
v
alid
CGI
script
is
the
follo
wing:
#!/local/bin/perl
#
#
Reply
with
proper
protocol
#
print
"Content-type:
text/html\n\n";
#
#
Get
the
data
from
the
form
...
#
$input
=
<STDIN>;
#
#
...
and
echo
them
back
#

0
The
unix
programming
en
vironmen
t
print
$input,
"\n
Done!
\n";
Although
rather
banal,
this
script
is
a
useful
starting
p
oin
t
for
CGI
programming,
b
ecause
it
sho
ws
y
ou
just
ho
w
the
input
arriv
es
at
the
script
from
the
HTML
form.
The
data
arriv
e
all
in
a
single,
enormously
long
line,
full
of
funn
y
c
haracters.
The
rst
job
of
an
y
script
is
to
deco
de
this
line.
Before
lo
oking
at
ho
w
to
deco
de
the
data,
w
e
should
mak
e
an
imp
ortan
t
p
oin
t
ab
out
the
proto
col
line.
If
a
w
eb
bro
wser
do
es
not
get
this
`Con
ten
t-t
yp
e'
line
from
the
CGI
script
it
returns
with
an
error:
00
Server
Error
The
server
encountered
an
internal
error
or
misconfiguration
and
was
unable
to
complete
your
request.
Please
contact
the
server
administrator,
and
inform
them
of
the
time
the
error
occurred,
and
anything
you
might
have
done
that
may
have
caused
the
error.
Error:
HTTPd:
malformed
header
from
script
www/cgi-bin/comment.pl
Before
nishing
y
our
CGI
script,
y
ou
will
probably
ecoun
ter
this
error
sev
eral
times.
A
common
reason
for
getting
the
error
is
a
syn
tax
error
in
y
our
script.
If
y
our
program
con
tains
an
error,
the
rst
thing
a
bro
wser
gets
in
return
is
not
the
`Con
ten
t-t
yp
e'
line,
but
an
error
message.
The
bro
wser
do
es
not
pass
on
this
error
message,
it
just
prin
ts
the
uninformativ
e
message
ab
o
v
e.
If
y
ou
can
get
the
ab
o
v
e
script
to
w
ork,
then
y
ou
are
ready
to
deco
de
the
data
whic
h
are
sen
t
to
the
script.
The
rst
thing
is
to
use
p
erl
to
split
the
long
line
in
to
an
arra
y
of
lines,
b
y
splitting
on
`&'.
W
e
can
also
con
v
ert
all
of
the
`+'
sym
b
ols
bac
k
in
to
spaces.
The
script
no
w
lo
oks
lik
e
this:
#!/local/bin/perl
#
#
Reply
with
proper
protocol
#
print
"Content-type:
text/html\n\n";
#
#
Get
the
data
from
the
form
...
#
$input
=
<STDIN>;
#
#
...
and
echo
them
back

Chapter
:
WWW
and
CGI
programming
0
#
print
"$input\n\n\n";
$input
=~
s/\+/
/g;
#
#
Now
split
the
lines
and
convert
#
@array
=
split('&',$input);
foreach
$var
(
@array
)
{
print
"$var\n";
}
print
"Done!
\n";
W
e
no
w
ha
v
e
a
series
of
elemen
ts
in
our
arra
y
.
The
output
from
this
script
is
something
lik
e
this:
variable=Mark+Burgess&v
aria
ble
=%0
D%0A
I+ju
st+
call
ed+t
o+s
ay+
(wrap)
....%0D%0A...hey+pig%C+
noth
ing%
s
+wor
king
+ou
t+th
e+wa
y+I
+pla
nned
variable=Mark
Burgess
variable=%0D%0AI
just
called
to
say
(wrap)
....%0D%0A...hey
pig%Cnothing%s
working
out
the
way
I
planned
Done!
As
y
ou
can
see,
all
con
trol
c
haracters
are
con
v
erted
in
to
the
form
`%XX'.
W
e
should
no
w
try
to
do
something
with
these.
Since
w
e
are
usually
not
in
terested
in
k
eeping
new
lines,
or
an
y
other
con
trol
co
des,
w
e
can
simply
n
ull-out
these
with
a
line
of
the
form
$input
=~
s/%..//g;
The
regular
expression
`%..'
matc
hes
an
ything
b
eginning
with
a
p
ercen
t
sym
b
ol
follo
w
ed
b
y
t
w
o
c
haracters.
The
resulting
output
is
then
free
of
these
sym
b
ols.
W
e
can
then
separate
the
v
ariable
con
ten
ts
from
their
names
b
y
splitting
the
input.
Here
is
the
complete
co
de:
#!/local/bin/perl
#
#
Reply
with
proper
protocol
#
print
"Content-type:
text/html\n\n";
#
#
Get
the
data
from
the
form
...
#

0
The
unix
programming
en
vironmen
t
$input
=
<STDIN>;
#
#
...
and
echo
them
back
#
print
"$input\n\n\n";
$input
=~
s/%..//g;
$input
=~
s/\+/
/g;
@array
=
split('&',$input);
foreach
$var
(
@array
)
{
print
"$var<br>";
}
print
"<hr>\n";
($name,$variable)
=
split("variable=",$array
[0])
;
($name,$variable)
=
split("variable=",$array
[])
;
print
"<br>var
=
$variable<br>";
print
"<br>var
=
$variable<br>";
print
"<br>Done!
\n";
and
the
output


variable=Mark+Burgess&va
riab
le
=%0D
%0AI
+ju
st+c
alle
d+t
o+sa
y
(wrap)
+....%0D%0A...hey+pig%C+
noth
ing
%s
+wor
kin
g+ou
t+th
e+w
ay+I
+pla
nne
d
variable=Mark
Burgess
variable=I
just
called
to
say
.......hey
pig
nothings
working
(wrap)
out
the
way
I
planned
var
=
Mark
Burgess
var
=
I
just
called
to
say
.......hey
pig
nothings
working
out
(wrap)
the
way
I
planned
Done!

	

Chapter
:
WWW
and
CGI
programming
0	
..
A
complete
guestb
o
ok
example
in
p
erl
Let
us
no
w
use
this
tec
hnique
to
dev
elop
a
guest
b
o
ok
aplication.
Based
on
the
co
de
ab
o
v
e,
analyze
the
follo
wing
co
de.
#!/local/bin/perl
########################
####
####
###
####
####
###
####
####
###
####
####
###
#
#
Guest
book
#
########################
####
####
###
####
####
###
####
####
###
####
####
###
$guestbook_page
=
"/iu/nexus/ud/mark/www/tm
p/c
fgue
st.h
tml
";
$tmp_page
=
"/iu/nexus/ud/mark/www/
tmp/
gues
ts.
tmp"
;
$remote_host
=
$ENV{"REMOTE_HOST"};
print
"Content-type:
text/html\n\n";
print
"<br><hr><br>\n";
print
"Thank
you
for
submitting
your
comment!<br><br>\n";
print
"best
wishes,<br><br>";
print
"-Mark<br><br><br>";
print
"Return
to
<a
href=http://www.iu.hios
lo.
no/~
mark
/me
nu.h
tml>
men
u</a
>\n"
;
$input
=
<STDIN>;
$input
=~
s/%..//g;
$input
=~
s/\+/
/g;
@array
=
split('&',$input);
($skip,$name)
=
split("var=",$array[0]
);
($skip,$message)
=
split("var=",$array[])
;
if
(!
open
(PAGE,
$guestbook_page))
{
print
"Content-type:
text/html\n\n";
print
"couldn't
open
guestbook
page
file!";
}
if
(!
open
(TMP,
"+>$tmp_page"))
{
print
"Content-type:
text/html\n\n";
print
"couldn't
open
temporary
output
file!";
}
while
($line
=
<PAGE>)
{

0
The
unix
programming
en
vironmen
t
if
($line
=~
/<h>Number
of
entries:
(..)/)
{
$entry_no
=
$;
$entry_no++;
$line
=
"<h>Number
of
entries:
$entry_no
</h>\n";
}
if
($line
=~
/<!--
LAST
ENTRY
-->/)
{
$date
=
`date
+"%A,
%b
%d
%Y"`;
print
TMP
"<b>Entry
$date
from
host:
$remote_host</b>\n<p>\n"
;
print
TMP
"From:
$name\n<p>\n";
print
TMP
$message;
print
TMP
"\n<hr>\n";
}
print
TMP
"$line";
}
close
PAGE;
close
TMP;
if
(!
rename
($tmp_page,
$guestbook_page))
{
print
"Oops!
Rename
operation
failed!\n";
}
chmod
(000,
$guestbook_page);
This
script
w
orks
b
y
reading
through
the
old
guest
b
o
ok
le,
op
ening
a
new
cop
y
of
the
guest
b
o
ok
le
and
app
ending
a
new
messages
at
the
end.
The
end
of
the
message
section
(not
coun
ting
the
`</HTML>'
tags)
is
mark
ed
b
y
a
commen
t
line.
<!--
LAST
ENTRY
-->
Note
that
a
pro
visional
guest
b
o
ok
le
has
to
exist
in
the
rst
place.
The
script
writes
to
a
new
le
and
then
sw
aps
the
new
le
for
the
old
one.
The
guest
b
o
ok
le
lo
oks
something
lik
e
this:
<html><head>
<title>Comments</title>
</head>
<body>
<h>My
guest
book</h>
<b>Entry
no.
Wednesday,
Feb

		
from
host:
dax</b>
<p>
From:
Mark.Burgess@iu.hioslo.no
<p>
Just
to
start
the
ball
rolling....

Chapter
:
WWW
and
CGI
programming

<hr>
<b>Entry
no.
Tuesday,
Mar

		
from
host:
enterprise.subspace.net
</b>
<p>
From:
spock@enterprise
<p>
Registering
a
form
of
energy
never
before
encountered.
<!--
LAST
ENTRY
-->
</body>
<address><a
href="http://www.iu.hio
slo
.no/
~mar
k">
Mark
Burgess</a>
-
Mark.Burgess@iu.hioslo.no
</ad
dre
ss>
</html>
The
directory
in
whic
h
this
le
lies
needs
to
b
e
writable
to
the
user
nob
o
dy
(the
WWW
user)
and
the
les
within
need
to
b
e
deletable
b
y
nob
o
dy
but
no
one
else.
Some
users
try
to
mak
e
guest
b
o
ok
scripts
setuid-themselv
es
in
order
to
o
v
ercome
the
problem
that
h
ttp
d
runs
with
uid
nob
o
dy
,
but
this
op
ens
man
y
securit
y
issues.
In
short
it
is
asking
for
trouble.
Unfortunately
an
ordinary
user
cannot
use
chown
in
order
to
giv
e
access
only
to
the
WWW
user
nob
o
dy
,
so
this
approac
h
needs
the
co
op
eration
of
the
system
administrator.
Nev
ertheless
this
is
the
most
secure
approac
h.
T
ry
to
w
ork
through
this
example
step
for
step.
.
PHP
and
the
w
eb
The
PHP

language
mak
es
the
whole
business
of
w
eb
programming
rather
simpler
than
p
erl.
It
hides
the
business
of
translating
v
ariables
from
forms
in
to
new
v
ariables
in
a
CGI
program
and
it
ev
en
allo
ws
y
ou
to
em
b
ed
activ
e
co
de
in
to
y
ou
HTML
pages.
PHP
has
sp
ecial
supp
ort
for
querying
data
in
an
SQL
database
lik
e
MySQL
or
Oracle.
PHP
do
cumen
tation
liv
es
at
http://www.php.net.
..
Em
b
edded
PHP
PHP
co
de
can
b
e
em
b
edded
inside
HTML
pages
pro
vided
y
our
WWW
serv
er
is
cong-
urered
with
PHP
supp
ort.
PHP
co
de
liv
es
inside
a
tag
with
the
general
form
<?php
co
de...
?>
F
or
example,
w
e
could
use
this
to
imp
ort
one
le
in
to
another
and
prin
t
out
a
table
of
n
um
b
ers:
<html>
<body>
<?php


The
unix
programming
en
vironmen
t
include
"file.html"
for
($i
=
0;
$i
<
0;
$i++)
{
print
"Counting
$i<br>";
}
?>
</body>
</html>
This
mak
es
it
easy
to
generate
WWW
pages
with
a
xed
visual
la
y
out:
<?php
#
#
Standard
layout
#
#
Set
$title,
$comment
and
$contents
########################
####
####
###
####
####
###
####
####
###
####
####
###
####
##
print
"<body>\n";
print
"<img
src=img/header.gif>";
print
"<h>"$title</h>";
print
"<em>$comment</em>";
print
"<blockquote>\n";
include
$contents;
print
("</blockquote>\n");
print
("</body>\n");
print
("</html>\n");
V
ariables
are
easily
set
b
y
calling
PHP
co
de
in
the
form
of
a
CGI
program
from
a
form.
..
PHP
and
forms
PHP
is
particularly
go
o
d
at
dealing
with
forms,
as
a
CGI
scripting
langauge.
Consider
the
follo
wing
form:
<html>
<body>
<form
action="/cgi-bin-scriptali
as/
spit
itou
t.p
hp"
method="post">
Name:
<input
type="text"
name="personal[name]"><b
r>
Email:
<input
type="text"
name="personal[email]"><
br>
Preferred
language:
<select
multiple
name="language[]">

Chapter
:
WWW
and
CGI
programming

<option
value="English">English
<option
value="Norwegian">Norwe
gian
<option
value="Gobbledigook">Go
bble
dig
ook
</select>
<input
type=image
src="image.gif"
name="sub">
</form>
</body>
</html>
This
pro
duces
a
page
in
to
whic
h
one
t
yp
es
a
name
and
email
address
and
c
ho
oses
a
language
from
a
list
of
three
p
ossible
c
hoices.
When
the
user
clic
ks
on
a
button
mark
ed
b
y
the
le
`image.gif'
the
form
is
p
osted.
Here
is
a
program
whic
h
unra
v
els
the
data
sen
t
to
the
CGI
program:
#!/local/bin/php
<?php
#
#
A
CGI
program
which
handles
a
form
#
Variables
a
translated
automatically
#
$title
=
"This
page
title";
$comment
=
"This
pages
talks
about
the
following.....";
########################
####
####
###
####
####
###
####
####
###
####
####
###
####
##
echo
"<body>";
echo
"<h>$title</h>";
echo
"<em>$comment</em>";
echo
"<blockquote>\n";
###
echo
"Your
name
is
$personal[name]<br><br>
";
echo
"Your
email
is
$personal[email]<br><br>"
;
echo
"Language
options:
";
echo
"<table>
";
for
($i
=
0;
strlen($language[$i])
>
0;
$i++)
{
echo
"<tr><td
bgcolor=#ff0000>Variable
language[$i]
=
$language[$i]</td></tr>";
}
if
($language[0]
==
"Norwegian")
{
echo
"Hei
alle
sammen<p>";


The
unix
programming
en
vironmen
t
}
else
{
echo
"Greetings
everyone,
this
page
will
be
in
English<p>";
}
echo
"</table>
";
###
echo
("</blockquote>\n");
echo
("</body>\n");
echo
("</html>\n");
?>

Chapter
	:
C
programming

	
C
programming
This
se
ction
is
not
me
ant
to
te
ach
you
C.
It
is
a
guide
to
using
C
in
UNIX
and
it
is
assume
d
that
you
have
a
working
know
le
dge
of
the
language.
Se
e
the
GNU
C-T
utorial
for
an
intr
o
duction
to
b
asics.
	.
Shell
or
C?
In
the
preceding
c
hapters
w
e
ha
v
e
b
een
lo
oking
at
w
a
ys
to
get
simple
programming
tasks
done.
The
immediateness
of
the
script
languages
is
a
great
adv
an
tage
when
w
e
just
w
an
t
to
get
a
job
done
as
quic
kly
as
p
ossible.
Scripts
lend
themselv
es
to
simple
system
administration
tasks
lik
e
le
pro
cessing,
but
they
do
not
easily
lend
themselv
es
to
more
serious
programs.
Although
some
system
administrators
ha
v
e
gro
wn
to
the
idea
that
shell
programming
is
easier,
I
w
ould
argue
that
this
is
not
really
true.
First
of
all,
most
of
the
UNIX
shell
commands
are
just
wrapp
er
programs
for
C
function
calls.
Wh
y
use
the
wrapp
er
when
y
ou
can
use
the
real
thing?
Secondly
,
the
C
function
calls
return
data
in
p
oin
ters
and
structures
whic
h
are
v
ery
easy
to
manipulate,
whereas
piping
the
output
of
shell
programs
in
to
others
can
b
e
a
v
ery
messy
and
a
wkw
ard
w
a
y
of
w
orking.
Here
are
some
of
the
reasons
wh
y
w
e
also
need
a
more
traditional
programming
language
lik
e
C.
.
The
shell
languages
do
not
allo
w
us
to
create
an
acceptable
user-in
terface,
lik
e
X-
windo
ws,
or
the
curses
(cursor
manipulation)
library
.
They
are
mainly
in
tended
for
le-pro
cessing.
(Though
recen
tly
the
Tk
library
has
pro
vided
a
w
a
y
of
creating
user
in
terfaces
in
Tcl
and
P
erl.)
.
Shell
commands
read
their
input
line-b
y-line.
Not
all
input
is
generated
in
this
simple
w
a
y
{
w
e
also
need
to
b
e
able
to
read
through
lines
i.e.
the
concept
of
a
data
str
e
am.
.
More
adv
anced
data
structures
are
needed
for
most
applications,
suc
h
as
link
ed
lists
and
binary
trees,
acyclic
graphs
etc.
.
Compilers
help
to
sort
out
simple
t
yp
ographical
and
logical
errors
b
y
compile-time
c
hec
king
source
co
de.
.
Compiled
co
de
is
faster
than
in
terpreted
co
de.
.
Man
y
to
ols
ha
v
e
b
een
written
to
help
in
the
programming
of
C
co
de
(db
x,
lex,
y
acc
etc.).
	.
C
program
structure
	..
The
form
of
a
C
program
A
C
program
consists
of
a
set
of
function,
b
eginning
with
the
main
program:
main
()
/*
This
is
a
comment
*/
{
Commands
...


The
unix
programming
en
vironmen
t
}
The
source
co
de
of
a
C
program
can
b
e
divided
in
to
sev
eral
text
les.
C
compiles
all
functions
separately;
the
link
er
ld
joins
them
all
up
at
the
end.
This
means
that
w
e
can
plan
out
a
strategy
for
writing
large
programs
in
a
clear
and
ecien
t
manner.
NOTE:
C++
st
yle
commen
ts
`//...'
are
not
allo
w
ed
b
y
most
C
compilers.
	..
Macros
and
declarations
Most
Unix
systems
no
w
ha
v
e
ANSI
C
compatible
compilers,
but
this
has
not
alw
a
ys
b
een
the
case.
Most
UNIX
programs
written
in
a
v
ersion
of
C
whic
h
is
older
than
the
ANSI
standard,
so
y
ou
will
need
an
appreciation
of
old
Kernighan
and
Ritc
hie
C
con
v
en
tions
for
C
programming.
See
for
example
m
y
C
b
o
ok.
An
ob
vious
dierence
b
et
w
een
ANSI
C
and
K&R
C
is
that
the
C++
additions
to
the
language
are
not
included.
Here
are
some
useful
p
oin
ts
to
remem
b
er.

K&R
C
do
es
not
allo
w
`const'
data,
it
uses
the
C
prepro
cessor
with
`#define'
instead.
i.e.
in
tead
of
const
int
blah
=
;
use
#define
blah

Remem
b
er
that
the
hash
sym
b
ol
`#'
m
ust
b
e
the
rst
c
haracter
on
a
line
under
UNIX.

K&R
C
do
esn't
use
function
protot
yp
es
or
declarations
of
the
form:
void
function
(char
*string,
int
a,
int
b)
{
}
Instead
one
writes:
void
function
(string,
a,
b)
char
*string;
int
a,b;
{
}
	..
Sev
eral
les
Most
unix
programs
are
v
ery
large
and
are
split
up
in
to
man
y
les.
Remem
b
er,
when
y
ou
split
up
programs
in
to
sev
eral
les,
y
ou
m
ust
declare
v
ariables
as
`extern'
in
le
A
if

Chapter
	:
C
programming

they
are
really
declared
in
le
B.
in
whic
h
y
ou
w
an
t
to
use
them.
This
tells
the
compiler
that
it
should
not
try
to
create
lo
cal
storage
for
the
v
ariable,
b
ecause
this
w
as
already
done
in
another
le.
	.
A
note
ab
out
UNIX
system
calls
and
standards
Most
of
the
system
calls
in
UNIX
return
data
in
the
form
of
`struct'
v
ariables.
Some-
times
these
are
structures
used
b
y
the
op
erating
system
itself
{
in
other
cases
they
are
just
put
together
so
that
programmers
can
handle
a
pac
k
et
of
data
in
a
con
v
enien
t
w
a
y
.
If
in
doubt,
y
ou
can
nd
the
denitions
of
these
structures
in
the
relev
an
t
include
les
under
`/usr/include'.
Since
UNIX
comes
in
man
y
a
v
ours
the
system
calls
are
not
alw
a
ys
compatible
and
ma
y
ha
v
e
dieren
t
options
and
argumen
ts.
Because
of
this
there
is
a
n
um
b
er
of
standardizing
organizations
for
UNIX.
One
of
them
is
POSIX
whic
h
is
an
organization
run
b
y
the
ma
jor
UNIX
v
endors.
Programs
written
for
UNIX
are
no
w
exp
ected
to
b
e
POSIX
complian
t.
This
is
not
something
y
ou
need
to
think
ab
out
at
the
lev
el
of
this
course,
but
y
ou
should
certainly
remem
b
er
that
there
exist
programming
standards
and
that
these
should
b
e
adhered
to.
The
aim
is
to
w
ork
to
w
ards
a
single
standard
UNIX.
	.
Compiling:
`cc',
`ld'
and
`a.out'
The
C
compiler
on
the
unix
system
is
traditionally
called
`cc'
and
has
alw
a
ys
b
een
a
traditional
part
of
ev
ery
Unix
en
vironmen
t.
Recen
tly
sev
eral
Unix
v
endors
ha
v
e
stopp
ed
including
the
C
compiler
as
a
part
of
their
op
erating
systems
and
instead
sell
a
compiler
separately
.
F
ortunately
there
is
a
public
domain
F
ree
Soft
w
are
v
ersion
of
the
compiler
called
`gcc'
(the
GNU
C
compiler).
W
e
shall
use
this
in
all
the
examples.
T
o
compile
a
program
consisting
of
sev
eral
les
of
co
de,
w
e
rst
compile
all
of
the
separate
pieces
without
trying
to
link
them.
There
are
therefore
t
w
o
stages:
rst
w
e
turn
`.c'
les
in
to
`.o'
les.
This
compiles
co
de
but
do
es
not
x
an
y
address
references.
Then
w
e
link
all
`.o'
les
in
to
the
nal
executable,
including
an
y
libraries
whic
h
are
used.
Let's
supp
ose
w
e
ha
v
e
les
`a.c',
`b.c'
and
`c.c'.
W
e
write:
gcc
-c
a.c
b.c
c.c
This
creates
les
`a.o',
`b.o'
and
`c.o'.
Next
w
e
link
them
in
to
one
le
called
`m
yprog'.
gcc
-o
myprog
a.o
b.o
c.o
If
the
naming
option
`-o
myprog'
is
not
used,
the
link
`ld'
uses
the
default
name
a.out
for
the
executable
le.
	..
Libraries
and
`LD_LIBRARY_PATH'
The
resulting
le
is
called
`myprog'
and
includes
references
only
to
the
standard
li-
brary
`libc'.
If
w
e
wish
to
link
in
the
math
library
`libm'
or
the
cursor
mo
v
emen
t
library
`libcurses'
{
or
in
general,
a
library
called
`libBLAH'
,
w
e
need
to
use
the
`-l'
directiv
e.


The
unix
programming
en
vironmen
t
gcc
-o
myprog
files.o
-lm
-lcurses
-lBLAH
The
compiler
lo
oks
for
a
suitable
library
in
all
of
the
directories
listed
in
the
en
vironmen
t
v
ariable
`LD_LIBRARY_PATH'.
Alternativ
ely
w
e
can
add
a
directory
to
the
searc
h
path
b
y
using
the
`-L'.
option:
gcc
-o
myprog
files.o
-L/usr/local/lib
-lm
-lcurses
-lBLAH
	..
Include
les
Normally
the
compiler
lo
oks
for
include
les
only
in
the
directory
`/usr/include'.
W
e
can
add
further
paths
to
searc
h
using
the
`-I'
option.
gcc
-o
myprog
file.c
-I/usr/local/include
-I/usr/local/X/include
Previously
,
Unix
libraries
ha
v
e
b
een
in
`a.out'
co
de
format,
but
recen
t
releases
of
unix
ha
v
e
gone
o
v
er
to
a
more
ecien
t
and
exible
format
called
ELF
(executable
and
linking
format).
	..
Shared
and
static
libraries
Libraries
are
collections
of
C
functions
whic
h
the
op
erating
system
creators
ha
v
e
written
for
our
con
v
enience.
The
source
co
de
for
suc
h
a
library
is
just
the
source
for
a
collection
of
functions
{
there
is
no
main
program.
There
are
t
w
o
kinds
of
library
used
b
y
mo
dern
op
erating
systems:
ar
chive
libr
aries
or
static
libraries
and
shared
libraries
or
dynamical
libraries.
An
arc
hiv
e
library
has
a
name
of
the
form
libname.a
When
an
arc
hiv
e
library
is
link
ed
to
a
program,
it
is
app
ended
lo
c
k,
sto
c
k
and
barrel
to
the
program
co
de.
This
uses
a
lot
of
disk
space
and
mak
es
the
size
of
the
compiled
program
v
ery
large.
Shared
libraries
(shared
ob
jects
`so'
or
shared
arc
hiv
es
`sa'
generally
ha
v
e
names
of
the
form)
libname.so
libname.sa
often
with
v
ersion
n
um
b
ers
app
ended.
When
a
program
is
link
ed
with
a
shared
library
the
co
de
is
not
app
ended
to
the
program.
Instead
p
oin
ters
to
the
shared
ob
jects
are
created
and
the
library
is
loaded
at
run
time,
th
us
a
v
oiding
the
problem
of
ha
ving
to
store
the
library
eectiv
ely
m
ultiple
times
on
the
disk.
T
o
mak
e
an
arc
hiv
e
library
w
e
compile
all
of
the
functions
w
e
wish
to
include
in
the
library

Chapter
	:
C
programming
	
gcc
-c
function.c
function.c
...
and
then
join
the
les
using
the
`ar'
command.
ar
rcv
libMYLIB.a
function.o
ar
rcv
libMYLIB.a
function.o
T
o
mak
e
a
shared
library
one
pro
vides
an
option
to
the
link
er
program.
The
exact
metho
d
is
dieren
t
in
dieren
t
op
erating
systems,
so
y
ou
should
lo
ok
at
the
man
ual
page
for
ld
on
y
our
system.
Under
SunOS

w
e
tak
e
the
ob
ject
les
`*.o'
and
run
ld
-o
libMYLIB.so..
-assert
pure-text
*.o
Under
HPUX,
w
e
write
ld
-b
-o
libMYLIB.so..
*.o
With
the
GNU
link
er,
y
ou
write
ld
-shared
-o
libMYLIB.so..
*.o
NOTE:
when
y
ou
add
a
shared
library
to
the
system
under
SunOS
or
GNU/Lin
ux
y
ou
m
ust
run
the
command
`ldconfig',
making
sure
that
the
path
to
the
library
is
in-
cluded
in
`LD_LIBRARY_PATH'.
SunOS
and
GNU/Lin
ux
use
a
cac
he
le
`/etc/ld.so.cache'
to
k
eep
curren
t
v
ersions
of
libraries.
GNU/Lin
ux
also
uses
a
conguration
le
called
`/etc/ld.so.conf'.
	..
Kno
wing
ab
out
imp
ortan
t
paths:
directory
structure
It
is
imp
ortan
t
to
understand
ho
w
the
C
compiler
nds
the
les
it
needs.
W
e
ha
v
e
already
men
tioned
the
`-I'
and
`-L'
options
to
the
compilation
command
line.
In
general,
all
system
include
les
can
b
e
found
in
the
directory
`/usr/include'
and
sub
directories
of
this
directory
.
All
system
libraries
can
b
e
found
in
`/usr/lib'.
Man
y
pac
k
ages
build
their
o
wn
libraries
and
k
eep
the
relev
an
t
les
in
separate
directories
so
that
if
the
system
gets
reinstalled,
they
do
not
get
deleted.
This
is
true
for
example
of
the
X-windo
ws
system.
The
include
and
library
les
for
this
are
t
ypically
k
ept
in
directo-
ries
whic
h
lo
ok
something
lik
e
`/usr/local/XR/include'
and
`/usr/XR/lib'.
That
means
that
w
e
need
to
giv
e
all
of
this
information
to
the
compiler.
Compiling
a
program
b
ecomes
a
complicated
task
in
man
y
cases
so
w
e
need
some
kind
of
script
to
help
us
p
erform
the
task.
The
Unix
to
ol
make
w
as
designed
for
this
purp
ose.
	.
Mak
e
No
w
ada
ys
compilers
are
often
sold
with
fancy
user
en
vironmen
ts
driv
en
b
y
men
us
whic
h
mak
e
it
easier
to
compile
programs.
Unix
has
similar
en
vironmen
ts
but
all
of
them
use

0
The
unix
programming
en
vironmen
t
shell-based
command
line
compilation
b
eneath
the
surface.
That
is
b
ecause
UNIX
pro-
grammers
are
used
to
writing
large
and
complex
programs
whic
h
o
ccup
y
man
y
directories
and
sub
directories.
Eac
h
directory
has
to
b
e
adapted
or
congured
to
t
the
particular
a
v
our
of
Unix
system
it
is
b
eing
compiled
up
on.
In
teractiv
e
user
en
vironmen
ts
are
v
ery
p
o
or
at
p
erforming
this
kind
of
service.
UNIX
solv
es
the
problem
of
compiling
enormous
tr
e
es
of
soft
w
are
(suc
h
as
the
unix
system
itself
!)
b
y
using
a
compilation
language
called
`make'.
Suc
h
language
les
can
b
e
generated
automatically
b
y
scripts,
allo
wing
v
ery
complex
programs
to
congure
and
compile
themselv
es
from
a
single
con
trol
script.
	..
Compiling
large
pro
jects
T
yping
lines
lik
e
cc
-c
file.c
file.c
...
cc
-o
target
file.o
....
rep
eatedly
to
compile
a
complicated
program
can
b
e
a
real
n
uisance.
One
p
ossibilit
y
w
ould
therefore
b
e
to
k
eep
all
the
commands
in
a
script.
This
could
w
aste
a
lot
of
time
though.
Supp
ose
y
ou
are
w
orking
on
a
big
pro
ject
whic
h
consists
of
man
y
lines
of
source
co
de
{
but
are
editing
only
one
le.
Y
ou
really
only
w
an
t
to
recompile
the
le
y
ou
are
w
orking
on
and
then
relink
the
resulting
ob
ject
le
with
all
of
the
other
ob
ject
les.
Recompiling
the
other
les
whic
h
hadn't
c
hanged
w
ould
b
e
a
w
aste
of
time.
But
that
w
ould
mean
that
y
ou
w
ould
ha
v
e
to
c
hange
the
script
eac
h
time
y
ou
c
hange
what
y
ou
need
to
compile.
A
b
etter
solution
is
to
use
the
`make'
command.
`make'
w
as
designed
for
precisely
this
purp
ose.
T
o
use
`make',
w
e
create
a
le
called
`Makefile'
in
the
same
directory
as
our
program.
`make'
is
a
quite
general
program
for
building
soft
w
are.
It
is
not
sp
ecically
tied
to
the
C
programming
language|
it
can
b
e
used
in
an
y
programming
language.
A
`make'
conguration
le,
called
a
`Makefile',
con
tains
rules
whic
h
describ
e
ho
w
to
compile
or
build
all
of
the
pieces
of
a
program.
F
or
example,
ev
en
without
telling
it
sp
eci-
cally
,
make
kno
ws
that
in
order
to
go
from
`prog.c'
to
`prog.o'
the
command
`cc
-c
prog.c'
m
ust
b
e
executed.
A
Mak
ele
w
orks
b
y
making
suc
h
asso
ciations.
The
Mak
ele
con
tains
a
list
of
all
of
the
les
whic
h
comp
ose
the
program
and
rules
as
to
ho
w
to
get
to
the
nished
pro
duct
from
the
source.
The
idea
is
that,
to
compile
a
program,
w
e
just
ha
v
e
to
t
yp
e
make.
`make'
then
reads
the
Mak
ele
and
compiles
all
of
the
parts
whic
h
need
compiling.
It
do
es
not
recompile
les
whic
h
ha
v
e
not
c
hanged
since
the
last
compilation!
Ho
w
do
es
it
do
this?
`make'
w
orks
b
y
comparing
the
time-stamp
on
the
le
it
needs
to
create
with
the
time-stamp
on
the
le
whic
h
is
to
b
e
compiled.
If
the
compiled
v
ersion
exists
and
is
new
er
than
its
source
then
the
source
do
es
not
need
to
b
e
recompiled.
T
o
mak
e
this
idea
w
ork
in
practice,
`make'
has
to
kno
w
ho
w
to
go
through
the
steps
of
compiling
a
program.
Some
default
rules
are
dened
in
a
global
conguration
le,
e.g.
/usr/include/make/defaul
t.mk
Let's
consider
an
example
of
what
happ
ens
for
the
the
three
les
`a.c',
`b.c'
and
`c.c'
in
the
example
ab
o
v
e
{
and
let's
not
w
orry
ab
out
what
the
Mak
ele
lo
oks
lik
e
y
et.

Chapter
	:
C
programming

The
rst
time
w
e
compile,
only
the
`.c'
les
exist.
When
w
e
t
yp
e
`make',
the
program
lo
oks
at
its
rules
and
nds
that
it
has
to
mak
e
a
le
called
`m
yprog'.
T
o
mak
e
this
it
needs
to
execute
the
command
gcc
-o
myprog
a.o
b.o
c.o
So
it
lo
oks
for
`a.o'
etc
and
do
esn't
nd
them.
It
no
w
go
es
to
a
kind
of
subroutine
and
lo
oks
to
see
if
it
has
an
y
rules
for
making
les
called
`.o'
and
it
disco
v
ers
that
these
are
made
b
y
compiling
with
the
`gcc
-c'
option.
Since
the
les
do
not
exist,
it
do
es
this.
No
w
the
les
`a.o
b.o
c.o'
exist
and
it
jumps
bac
k
to
the
original
problem
of
trying
to
mak
e
`m
yprog'.
All
the
les
it
needs
no
w
exist
and
so
it
executes
the
command
and
builds
`m
yprog'.
If
w
e
no
w
edit
`a.c',
and
t
yp
e
`make'
once
again
{
it
go
es
through
the
same
pro
cedure
as
b
efore
but
no
w
it
nds
all
of
the
les.
So
it
compares
the
dates
on
the
les
{
if
the
source
is
new
er
than
the
result,
it
recompiles.
By
using
this
recursiv
e
metho
d,
`make'
only
compiles
those
parts
of
a
program
whic
h
need
compiling.
	..
Mak
eles
T
o
write
a
Mak
ele,
w
e
ha
v
e
to
tell
`make'
ab
out
dep
endencies.
The
dep
endencies
of
a
le
are
all
of
those
les
whic
h
are
required
to
build
it.
Th
us,
the
dep
endencies
of
`m
yprog'
are
`a.o',
`b.o'
and
`c.o'.
The
dep
endencies
of
`a.o'
are
simply
`a.c',
the
dep
endencies
of
`b.o'
are
`b.c'
and
so
on.
A
Mak
ele
consists
of
rules
of
the
form:
target
:
dependencies
h
T
AB
i
rule;
The
target
is
the
thing
w
e
w
an
t
to
build,
the
dep
endenices
are
lik
e
subroutines
to
b
e
executed
rst
if
they
do
not
exist.
Finally
the
rule
is
to
b
e
executed
if
all
if
the
dep
endenices
exist;
it
tak
es
the
dep
endencies
and
turns
them
in
to
the
target.
There
are
t
w
o
imp
ortan
t
things
to
remem
b
er:

The
le
names
m
ust
start
on
the
rst
c
haracter
of
a
line.

There
m
ust
b
e
a
h
T
AB
i
c
haracter
at
the
b
eginning
of
ev
ery
rule
or
action.
If
there
are
spaces
instead
of
tabs,
or
no
tab
at
all,
`make'
will
signal
an
error.
This
bizarre
feature
can
cause
a
lot
of
confusion.
Let's
lo
ok
at
an
example
Mak
ele
for
a
program
whic
h
consists
of
t
w
o
course
les
`main.c'
and
`other.c'
and
whic
h
mak
es
use
of
a
library
called
`libdb'
whic
h
lies
in
the
directory
`/usr/local/lib'.
Our
aim
is
to
build
a
program
called
database:
#
#
Simple
Makefile
for
`database'
#
#
First
define
a
macro


The
unix
programming
en
vironmen
t
OBJ
=
main.o
other.o
CC
=
gcc
CFLAGS
=
-I/usr/local/include
LDFLAGS
=
-L/usr/local/lib
-ldb
INSTALLDIR
=
/usr/local/bin
#
#
Rules
start
here.
Note
that
the
$@
variable
becomes
the
name
of
the
#
executable
file.
In
this
case
it
is
taken
from
the
${OBJ}
variable
#
database:
${OBJ}
${CC}
-o
$@
${OBJ}
${LDFLAGS}
#
#
If
a
header
file
changes,
normally
we
need
to
recompile
everything.
#
There
is
no
way
that
make
can
know
this
unless
we
write
a
rule
which
#
forces
it
to
rebuild
all
.o
files
if
the
header
file
changes...
#
${OBJ}:
${HEADERS}
#
#
As
well
as
special
rules
for
special
files
we
can
also
define
a
#
"suffix
rule".
This
is
a
rule
which
tells
us
how
to
build
all
files
#
of
a
certain
type.
Here
is
a
rule
to
get
.o
files
from
.c
files.
#
The
$<
variable
is
like
$?
but
is
only
used
in
suffix
rules.
#
.c.o:
${CC}
-c
${CFLAGS}
$<
########################
####
####
###
####
####
###
####
####
###
####
####
###
###
#
Clean
up
########################
####
####
###
####
####
###
####
####
###
####
####
###
###
#
#
Make
can
also
perform
ordinary
shell
command
jobs
#
"make
tidy"
here
performs
a
cleanup
operation
#
clean:
rm
-f
${OBJ}
rm
-f
y.tab.c
lex.yy.c
y.tab.h
rm
-f
y.tab
lex.yy
rm
-f
*%
*~
*.o
rm
-f
mconfig.tab.c
mconfig.tab.h
a.out

Chapter
	:
C
programming

rm
-f
man.dvi
man.aux
man.log
man.toc
rm
-f
cfengine.tar.gz
cfengine.tar
cfengine.tar.Z
make
tidy
rm
-f
cfengine
install:
${INSTALLDIR}/database
cp
database
${INSTALLDIR}/database
The
Mak
ele
ab
o
v
e
can
b
e
in
v
ok
ed
in
sev
eral
w
a
ys.
make
make
database
make
clean
make
install
If
w
e
simple
t
yp
e
`make'
i.e.
the
rst
of
these
c
hoices,
`make'
tak
es
the
rst
of
the
rules
it
nds
as
the
ob
ject
to
build.
In
this
case
the
rule
is
`database',
so
the
rst
t
w
o
forms
ab
o
v
e
are
equiv
alen
t.
On
the
other
hand,
if
w
e
t
yp
e
make
clean
then
execution
starts
at
the
rule
for
`clean',
whic
h
is
normally
used
to
remo
v
e
all
les
except
the
original
source
co
de.
Mak
e
`install'
causes
the
compiled
program
to
b
e
installed
at
its
in
tended
destination.
`make'
uses
some
sp
ecial
v
ariables
(whic
h
resem
ble
the
sp
ecial
v
ariables
used
in
P
erl
{
but
don't
confuse
them).
The
most
useful
one
is
`$@'
whic
h
represen
ts
the
curren
t
tar
get
{
or
the
ob
ject
whic
h
`make'
w
ould
lik
e
to
compile.
i.e.
as
`make'
c
hec
ks
eac
h
le
it
w
ould
lik
e
to
compile,
`$@'
is
set
to
the
curren
t
lename.
$@
This
ev
aluates
to
the
curren
t
target
i.e.
the
name
of
the
ob
ject
y
ou
are
curren
tly
trying
to
build.
It
is
normal
to
use
this
as
the
nal
name
of
the
program
when
compiling
$?
This
is
used
only
outside
of
sux
rules
and
means
the
name
of
all
the
les
whic
h
m
ust
b
e
compiled
in
order
to
build
the
curren
t
target.
target:
file.o
file.o
h
T
AB
i
cc
-o
$@
$?
$<
This
is
only
used
in
sux
rules.
It
has
the
same
meaning
as
`$?'
but
only
in
sux
rules.
It
stands
for
the
pre-requisite,
or
the
le
whic
h
m
ust
b
e
compiled
in
order
to
mak
e
a
giv
en
ob
ject.
Note
that,
b
ecause
`make'
has
some
default
rules
dened
in
its
conguration
le,
a
single-
le
C
program
can
b
e
compiled
v
ery
easily
b
y
t
yping
make
filename.c
This
is
equiv
alen
t
to
cc
-c
filename.c
cc
-o
filename
filename.o


The
unix
programming
en
vironmen
t
	..
New
sux
rules
for
C++
Standard
rules
for
C++
are
not
often
built
in
to
UNIX
systems
at
the
time
of
writing,
but
w
e
can
create
them
in
our
o
wn
Mak
eles
v
ery
easily
.
Here
w
e
shall
use
the
GNU
compiler
g++'s
con
v
en
tions
for
C++
les.
Here
is
a
sample
Mak
ele
for
using
C++.
Note
that
the
`.SUFFIXES'
command
m
ust
b
e
used
to
declare
new
endings
or
le
extensions.
########################
####
####
###
####
####
###
####
####
###
####
####
#
#
#
This
is
the
Makefile
for
g++
#
########################
####
####
###
####
####
###
####
####
###
####
####
#
OBJ
=
cpp-prog.o
X.o
Y.o
Z.o
CCPLUS
=
g++
.SUFFIXES:
.C
.o
.h
#
#
Program
Rules
#
filesys:
${OBJ}
$(CCPLUS)
-o
filesys
$(OBJ)
#
#
Extra
dependencies
on
the
header
file
#
(if
the
header
file
changes,
we
need
to
rebuild
*.o)
#
cpp-prog.o:
filesys.h
X.o:
filesys.h
Y.o:
filesys.h
Z.o:
filesys.h
#
#
Suffix
rules
#
.C.o:
$(CCPLUS)
-c
$<
The
general
rule
here
tells
make
that
a
`.o'
le
can
b
e
created
from
a
`.C'
le
b
y
executing
the
command
`$(CCPLUS)
-c'.
(This
is
iden
tical
to
the
C
case,
exept
for
the
name
of
the
compiler).
The
extra
dep
endencies
tell
make
that,
if
w
e
c
hange
the
header
le
`filesys.h',
then
w
e
m
ust
recompile
all
the
les
whic
h
read
in
`filesys.h',
since
this
could
aect
all

Chapter
	:
C
programming

of
these.
Finally
,
the
highest
lev
el
rule
sa
ys
that
to
mak
e
`filesys'
from
the
`.o'
les,
w
e
ha
v
e
to
run
`$(CCPLUS)
-o
filesys
*.o'.
	.
The
argv,
argc
and
envp
param
ters
When
w
e
write
C
programs
whic
h
reads
command
line
argumen
ts,
they
are
fed
to
us
as
an
arra
y
of
strings
called
the
argumen
t
v
ector.
The
mec
hanisms
for
the
C-shell
and
P
erl
are
deriv
ed
from
the
C
argumen
t
v
ector.
T
o
read
in
the
command
line,
w
e
write
main
(argc,argv,envp)
int
argc;
char
*argv[],
*envp[];
{
printf
("The
first
argument
was
%s\n",argv[]);
}
Argumen
t
zero
is
the
name
of
the
program
itself
and
`argv[argc-]'
is
the
last
argumen
t.
The
ab
o
v
e
denitions
are
in
Kernighan
and
Ritc
hie
C
st
yle.
In
ANSI
C,
the
argumen
ts
can
b
e
declared
using
protot
yp
e:
main
(int
argc,
char
**argv)
{
}
The
arra
y
of
strings
`envp[]'
is
a
list
of
v
alues
of
the
envir
onment
variables
of
the
system,
formatted
b
y
NAME=value
This
giv
es
C
programmers
access
to
the
shell's
global
en
vironmen
t.
	.
En
vironmen
t
v
ariables
in
C
In
addition
to
the
`envp'
v
ector,
it
is
p
ossible
to
access
the
en
vironmen
t
v
ariables
through
the
call
`getenv()'.
This
is
used
as
follo
ws;
supp
ose
w
e
w
an
t
to
access
the
shell
en
vironmen
t
v
ariable
`$HOME'.
char
*string;
string
=
getenv("HOME");
`string'
is
no
w
a
p
oin
ter
to
static
but
public
data.
Y
ou
should
not
use
`string'
as
if
it
w
ere
y
ou're
o
wn
prop
ert
y
b
ecause
it
will
b
e
used
again
b
y
the
system.
Cop
y
it's
con
ten
ts
to
another
string
b
efore
using
the
data.
char
buffer[00];
strcpy
(buffer,string);


The
unix
programming
en
vironmen
t
	.
Files
and
directories
All
of
the
regular
C
functions
from
the
standard
library
are
a
v
ailable
to
Unix
program-
mers.
The
standard
functions
only
address
the
issue
of
reading
and
writing
to
les
ho
w
ev
er,
they
do
not
deal
with
op
erating
system
sp
ecic
attributes
suc
h
as
le
p
ermissions
and
le
t
yp
es.
Nor
is
there
a
mec
hanisms
for
obtaining
lists
of
les
within
a
directory
.
The
reason
for
these
omissions
is
that
they
are
op
erating
system
dep
enden
t.
T
o
nd
out
ab
out
these
other
attributes
POSIX
describ
es
some
standard
Unix
system
calls.
	..
op
endir,
readdir
Files
and
directories
are
handled
b
y
functions
dened
in
the
header
le
`dirent.h'.
In
earlier
UNIX
systems
the
le
`dir.h'
w
as
used
{
and
the
denitions
w
ere
sligh
tly
dieren
t,
but
not
m
uc
h.
T
o
get
a
list
of
les
in
a
directory
w
e
m
ust
op
en
the
directory
and
read
from
it
{
just
lik
e
a
le.
(A
directory
is
just
a
le
whic
h
con
tains
data
on
its
en
tries).
The
commands
are
opendir
closedir
readdir
See
the
man
ual
pages
for
diren
t.
These
functions
return
p
oin
ters
to
a
dirent
structure
whic
h
is
dened
in
the
le
`/usr/include/dirent.h'.
Here
is
an
example
ls
command
whic
h
lists
the
con
ten
ts
of
the
directory
`/etc'.
This
header
denes
a
structure
struct
dirent
{
off_t
d_off;
/*
offset
of
next
disk
dir
entry
*/
unsigned
long
d_fileno;
/*
file
number
of
entry
*/
unsigned
short
d_reclen;
/*
length
of
this
record
*/
unsigned
short
d_namlen;
/*
length
of
string
in
d_name
*/
char
d_name[+];
/*
name
(up
to
MAXNAMLEN
+
)
*/
};
whic
h
can
b
e
used
to
obtain
information
from
the
directory
no
des.
#include
<stdio.h>
#include
<dirent.h>
main
()
{
DIR
*dirh;
struct
dirent
*dirp;
static
char
mydir[0]
=
"/etc";
if
((dirh
=
opendir(mydir))
==
NULL)
{
perror("opendir");
return;
}

Chapter
	:
C
programming

for
(dirp
=
readdir(dirh);
dirp
!=
NULL;
dirp
=
readdir(dirh))
{
printf("Got
dir
entry:
%s\n",dirp->d_name);
}
closedir(dirh);
}
Notice
that
reading
from
a
directory
is
lik
e
reading
from
a
le
with
fgets(),
but
the
en
tries
are
lenames
rather
than
lines
of
text.
	..
stat()
T
o
determine
the
le
prop
erties
or
statistics
w
e
use
the
function
call
`stat()'
or
its
corollory
`lstat()'.
Both
these
functions
nd
out
information
ab
out
les
(p
ermissions,
o
wner,
let
yp
e
etc).
The
only
dierence
b
et
w
een
them
is
the
w
a
y
in
whic
h
they
treat
sym
b
olic
links.
If
`stat'
is
used
on
a
sym
b
olic
link,
it
stats
the
le
the
link
p
oin
ts
to
rather
than
the
link
itself.
If
`lstat'
is
used,
the
data
refer
to
the
link.
Th
us,
to
detect
a
link,
w
e
m
ust
use
`lstat',
See
Section
	..
[lstat
and
readlink],
page
.
The
data
in
the
`stat'
structure
are
dened
in
the
le
`/usr/include/sys/stat.h'.
Here
are
the
most
imp
ortan
t
structures.
struct
stat
{
dev_t
st_dev;
/*
device
number*/
ino_t
st_ino;
/*
file
inode
*/
mode_t
st_mode;
/*
permission
*/
short
st_nlink;
/*
Number
of
hardlinks
to
file
*/
uid_t
st_uid;
/*
user
id
*/
gid_t
st_gid;
/*
group
id
*/
dev_t
st_rdev;
off_t
st_size;
/*
size
in
bytes
*/
time_t
st_atime;
/*
time
file
last
accessed
*/
time_t
st_mtime;
/*
time
file
contents
last
modified
*/
time_t
st_ctime;
/*
time
last
attribute
change
*/
long
st_blksize;
long
st_blocks;
};
	..
lstat
and
readlink
The
function
`stat()'
treats
sym
b
olic
links
as
though
they
w
ere
the
les
they
p
oin
t
to.
In
other
w
ords,
if
w
e
use
`stat()'
to
read
a
sym
b
olic
link,
w
e
end
up
reading
the
le
the
link
p
oin
ts
to
and
not
the
link
itself|
w
e
nev
er
see
sym
b
olic
links.
T
o
a
v
oid
this
problem,
there
is
a
dieren
t
v
ersion
of
the
stat
function
called
`lstat()'
whic
h
is
iden
tical
to
`stat()'


The
unix
programming
en
vironmen
t
except
that
it
treats
links
as
links
and
not
as
the
les
they
p
oin
t
to.
This
means
that
w
e
can
test
whether
a
le
is
a
sym
b
olic
link,
only
if
w
e
use
`lstat()'.
(See
the
next
paragraph.)
Once
w
e
ha
v
e
iden
tied
a
le
to
b
e
a
sym
b
olic
link,
w
e
use
the
`readlink()'
function
to
obtain
the
name
of
the
le
the
link
p
oin
ts
to.
#define
bufsize

char
buffer[bufsize];
readlink("/path/to/file"
,buf
fer,
buf
size
);
The
result
is
returned
in
the
string
buer.
	.	
stat()
test
macros
As
w
e
ha
v
e
already
men
tioned,
the
Unix
mo
de
bits
con
tain
not
only
information
ab
out
what
p
ermissions
a
le
has,
but
also
bits
describing
the
t
yp
e
of
le
{
whether
it
is
a
directory
or
a
link
etc.
There
are
macros
dened
in
UNIX
to
extract
this
information
from
the
`st_mode'
mem
b
er
of
the
`stat'
structure.
They
are
dened
in
the
`stat.h'
headerle.
Here
are
some
examples.
#define
S_ISBLK(m)
/*
is
block
device
*/
#define
S_ISCHR(m)
/*
is
character
device
*/
#define
S_ISDIR(m)
/*
is
directory
*/
#define
S_ISFIFO(m)
/*
is
fifo
pipe/socket
*/
#define
S_ISREG(m)
/*
is
regular
(normal)
file
*/
#define
S_ISLNK(m)
/*
is
symbolic
link
*/
/*
Not
POSIX
*/
#define
S_ISSOCK(m)
/*
is
a
lock
*/
#define
S_IRWXU
/*
rwx,
owner
*/
#define
S_IRUSR
/*
read
permission,
owner
*/
#define
S_IWUSR
/*
write
permission,
owner
*/
#define
S_IXUSR
/*
execute/search
permission,
owner
*/
#define
S_IRWXG
/*
rwx,
group
*/
#define
S_IRGRP
/*
read
permission,
group
*/
#define
S_IWGRP
/*
write
permission,
grougroup
*/
#define
S_IXGRP
/*
execute/search
permission,
group
*/
#define
S_IRWXO
/*
rwx,
other
*/
#define
S_IROTH
/*
read
permission,
other
*/
#define
S_IWOTH
/*
write
permission,
other
*/
#define
S_IXOTH
/*
execute/search
permission,
other
*/
These
return
true
or
false
when
acting
on
the
mo
de
mem
b
er.
Here
is
an
example
See
Section
	.	.
[readdir
example],
page
	.
struct
stat
statvar;

Chapter
	:
C
programming
	
stat("file",&statvar);
/*
test
return
values
*/
if
(S_ISDIR(statvar.st_mode)
)
{
printf("Is
a
directory!");
}
	.	.
Example
ling
program
The
follo
wing
example
program
demonstrates
the
use
of
the
directory
functions
in
dirent
and
the
stat
function
call.
/***********************
****
****
***
****
****
***
****
****
***
****
****
***
*/
/*
*/
/*
Reading
directories
and
`statting'
files
*/
/*
*/
/***********************
****
****
***
****
****
***
****
****
***
****
****
***
*/
#include
<stdio.h>
#include
<dirent.h>
#include
<sys/types.h>
#include
<sys/stat.h>
#define
DIRNAME
"/."
#define
bufsize

/***********************
****
****
***
****
****
***
****
****
***
****
****
***
*/
main
()
{
DIR
*dirh;
struct
dirent
*dirp;
struct
stat
statbuf;
char
*pathname[bufsize];
char
*linkname[bufsize];
if
((dirh
=
opendir(DIRNAME))
==
NULL)
{
perror("opendir");
exit();
}
for
(dirp
=
readdir(dirh);
dirp
!=
NULL;
dirp
=
readdir(dirh))
{
if
(strcmp(".",dirp->d_name)
==
0
||
strcmp("..",dirp->d_name)
==
0)

0
The
unix
programming
en
vironmen
t
{
continue;
}
if
(strcmp("lost+found",dirp-
>d_
name
)
==
0)
{
continue;
}
sprintf(pathname,"%s/%s",
DIRN
AME
,dir
p->d
_na
me);
if
(lstat(pathname,&statbuf)
==
-)
/*
see
man
stat
*/
{
perror("stat");
continue;
}
if
(S_ISREG(statbuf.st_mode))
{
printf("%s
is
a
regular
file\n",pathname);
};
if
(S_ISDIR(statbuf.st_mode))
{
printf("%s
is
a
directory\n",pathname);
}
if
(S_ISLNK(statbuf.st_mode))
{
bzero(linkname,bufsize);
/*
clear
string
*/
readlink(pathname,linkname
,bu
fsiz
e);
printf("%s
is
a
link
to
%s\n",pathname,linkname)
;
}
printf("The
mode
of
%s
is
%o\n\n",pathname,statbuf.
st_
mode
&
0);
}
closedir(dirh);
}
	.0
Pro
cess
con
trol,
fork(),
exec(),
popen()
and
system
There
is
a
n
um
b
er
of
w
a
ys
in
whic
h
pro
cesses
can
in
teract
with
one
another
and
in
whic
h
w
e
can
con
trol
their
b
eha
viour.
W
e
shall
not
go
in
to
great
detail
in
this
course,
only
pro
vide
examples
for
reference.
The
UNIX
`fork()'
function
is
used
to
create
c
hild
pro
cesses.
This
is
the
basis
of
all
`hea
vyw
eigh
t'
m
ultitasking
under
unix.
Here
is
a
simple
example
of
fork
in
whic
h
w
e
start
a
c
hild
pro
cess
from
within
a
program
and
w
ait
for
it
to
nish.
Note
that
the
co
de
for
the

Chapter
	:
C
programming

paren
t
and
the
c
hild
is
is
the
same
le.
The
only
thing
that
distinguishes
paren
t
from
c
hild
is
the
v
alue
returned
b
y
the
fork
function.
When
`fork()'
is
called,
it
duplicates
the
en
tire
curren
t
pro
cess
so
that
t
w
o
parallel
pro
cesses
are
then
running.
The
only
dierence
b
et
w
een
these
is
that
the
c
hild
pro
cess
(the
cop
y)
gets
a
return
v
alue
of
zero
from
`fork()',
whereas
the
paren
t
gets
a
return
v
alue
equal
to
the
pro
cess
iden
tier
(pid)
of
the
c
hild.
This
v
alue
can
b
e
used
b
y
the
paren
t
to
send
messages
or
to
w
ait
for
the
c
hild.
Here
w
e
sho
w
a
simple
example
in
whic
h
the
`wait(NULL)'
command
is
used
to
w
ait
for
the
last
c
hild
spa
wned
b
y
the
paren
t.
/***********************
****
****
***
****
****
***
****
****
***
****
**/
/*
*/
/*
A
brief
demo
of
the
UNIX
process
duplicator
fork().
*/
/*
*/
/***********************
****
****
***
****
****
***
****
****
***
****
**/
#include
<stdio.h>
/***********************
****
****
***
****
****
***
****
****
***
****
***/
main
()
{
int
pid,
cid;
pid
=
getpid();
printf
("Fork
demo!
I
am
the
parent
(pid
=
%d)\n",pid);
if
(!
fork())
{
cid
=
getpid();
printf
("I
am
the
child
(cid
=
%d)
of
(pid=%d)\n",cid,pid);
ChildProcess();
exit(0);
}
printf("Parent
waiting
here
for
the
child...\n");
wait(NULL);
printf("Child
finished,
parent
quitting
too!\n");
}
/***********************
****
****
***
****
****
***
****
****
***
****
**/
ChildProcess()
{
int
i;


The
unix
programming
en
vironmen
t
for
(i
=
0;
i
<
0;
i++)
{
printf
("%d...\n",i);
sleep();
}
}
Another
p
ossibilit
y
is
that
w
e
migh
t
w
an
t
to
execute
a
program
and
w
ait
to
nd
out
what
the
result
of
the
program
is
b
efore
con
tin
uing.
There
are
t
w
o
w
a
ys
to
do
this.
The
rst
is
a
v
ariation
on
the
theme
ab
o
v
e
and
uses
fork().
Let's
create
a
function
whic
h
runs
a
shell
command
from
within
a
C
program,
and
determines
its
return
v
alue.
W
e
mak
e
the
result
a
b
o
olean
(in
teger)
v
alue,
so
that
the
function
returns
`true'
if
the
shell
command
exits
normally
,
See
Section
.
[Return
co
des],
page
.
if
(ShellCommandReturnsZero(
shel
l-command
))
{
printf
("Command
%s
went
ok\n",shell-command
);
}
T
o
do
this
w
e
rst
ha
v
e
to
fork
a
new
pro
cess
and
then
use
one
of
the
exec
commands
to
load
a
new
co
de
image
on
top
of
the
new
pro
cess.
shell
commands
from
C
This
sounds
complicated,
but
it
is
necessary
b
ecause
of
the
w
a
y
unix
handles
pro
cesses.
If
w
e
had
no
use
for
the
return
v
alue,
w
e
could
simply
execute
a
shell
command
using
the
system("shell
command")
function,
(whic
h
do
es
all
this
for
us)
but
when
system()
exits,
w
e
can
only
tell
if
the
command
w
as
executed
successfully
or
unsuccessfully|w
e
learn
nothing
ab
out
what
actually
failed
(the
shell
or
command
whic
h
w
as
executed
under
the
shell?)
If
w
e
require
detailed
information
ab
out
what
happ
ened
to
the
c
hild
pro
cess
then
w
e
need
to
do
the
follo
wing.
#include
<sys/types.h>
#include
<sys/wait.h>
/*
Send
complete
command
as
a
string
*/
/*
including
all
arguments
*/
ShellCommandReturnsZero(
comm
)
char
*comm;
{
int
status,
i,
argc;
pid_t
pid;
char
arg[maxshellargs][bufsize
];
char
**argv;
/*
Build
argument
array
for
execv
call*/
for
(i
=
0;
i
<
maxshellargs;
i++)

Chapter
	:
C
programming

{
bzero
(arg[i],bufsize);
}
argc
=
SplitCommand(comm,arg);
if
((pid
=
fork())
<
0)
{
FatalError("Failed
to
fork
new
process");
}
else
if
(pid
==
0)
/*
child
*/
{
argv
=
malloc((argc+)*sizeof(ch
ar
*));
for
(i
=
0;
i
<
argc;
i++)
{
argv[i]
=
arg[i];
}
argv[i]
=
(char
*)
NULL;
if
(execv(arg[0],argv)
==
-)
{
yyerror("script
failed");
perror("execvp");
exit();
}
}
else
/*
parent
*/
{
if
(wait(&status)
!=
pid)
{
printf("Wait
for
child
failed\n");
perror("wait");
return
false;
}
else
{
if
(WIFSIGNALED(status))
{
printf("Script
%s
returned:
%s\n",comm,WTERMSIG(stat
us))
;
return
false;
}
if
(!
WIFEXITED(status))
{
return
false;
}


The
unix
programming
en
vironmen
t
if
(WEXITSTATUS(status)
==
0)
{
return
true;
}
else
{
return
false;
}
}
}
}
/***********************
****
****
***
****
****
***
****
****
***
****
****
***
/
SplitCommand(comm,arg)
char
*comm,
arg[maxshellargs][bufsi
ze];
{
char
*sp;
int
i
=
0,
j;
char
buff[bufsize];
for
(sp
=
comm;
*sp
!=
NULL;
sp++)
{
bzero(buff,bufsize);
if
(i
>=
maxshellargs-)
{
yyerror("Too
many
arguments
in
embedded
script");
FatalError("Use
a
wrapper");
}
while
(*sp
==
'
'
||
*sp
==
'\t')
{
sp++;
}
switch
(*sp)
{
case
'\"':
sscanf
(++sp,"%[^\"]",buff);
break;
case
'\'':
sscanf
(++sp,"%[^\']",buff);
break;
default:
sscanf
(sp,"%s",buff);
break;
}
for
(j
=
0;
j
<
bufsize;
j++)

Chapter
	:
C
programming

{
arg[i][j]
=
buff[j];
}
sp
+=
strlen(arg[i]);
i++;
}
return
(i);
}
In
this
example,
the
script
w
aits
for
the
exit
signal
from
the
c
hild
pro
cess
b
efore
con
tin
uing.
The
return
v
alue
from
the
c
hild
is
a
v
ailable
from
the
w
ait
function
with
the
help
of
a
set
of
macros
dened
in
`/usr/include/sys/wait.h'.
The
v
alue
is
giv
en
b
y
WTERMSIG(status).
In
the
nal
example,
w
e
can
op
en
a
pip
e
to
a
pro
cess
directly
in
a
C
program
as
though
it
w
ere
a
le,
b
y
using
the
function
popen().
Pip
es
ma
y
b
e
op
ened
for
reading
or
for
writing,
in
exactly
the
same
w
a
y
as
a
le
is
op
ened.
The
c
hild
pro
cess
is
automatically
sync
hronized
with
the
paren
t
using
this
metho
d.
Here
is
a
program
whic
h
op
ens
a
unix
command
for
reading
(b
oth
stdout
and
stderr)
from
the
c
hild
pro
cess
are
pip
ed
in
to
the
program.
Notice
that
the
syn
tax
used
in
this
call
is
that
used
b
y
the
Bourne
shell,
since
this
is
build
deeply
in
to
the
unix
execution
design.
#define
bufsize
0
FILE
*pp;
char
VBUFF[bufsize];
...
if
((pp
=
popen(
"/sbin/mount
-va
<&","r"))
==
NULL)
{
printf("Failed
to
open
pipe\n");
return
errorcode;
}
while
(!feof(pp))
{
fgets(VBUFF,bufsize,pp);
/*
Just
write
the
output
to
stdout
*/
printf
("Pipe
read:
%s\n",VBUFF);
}
pclose(pp);


The
unix
programming
en
vironmen
t
	.
A
more
secure
popen()
One
problem
with
the
popen()
system
call
is
that
it
uses
a
shell
to
execute
the
command
it
obtains
a
pip
e
to.
In
the
past
this
has
b
een
used
to
allo
w
Unix
securit
y
breac
hes,
using
a
so-called
IFS
attac
k
whic
h
can
tric
k
the
shell
in
to
executing
a
program
with
the
name
of
the
rst
no
de
in
the
directory
of
the
executable.
F
or
instance,if
the
pip
e
w
as
to
op
en
the
program
`/bin/ps',
this
coudl
b
e
tric
k
ed
in
to
executing
a
program
in
the
curren
t
w
orking
directory
of
the
pro
cess
called
`bin'
with
argumen
t
`ps'.
The
solution
is
not
to
use
a
shell
at
all,
but
to
replace
popen()
with
a
v
ersion
whic
h
calls
exec()
directly
.
Here
is
a
safe
v
ersion
from
the
source
co
de
of
cfengine:
#define
bufsize
0	
#define
maxshellargs
0
pid_t
*CHILD;
int
MAXFD
=
0;
/*
Max
number
of
simultaneous
pipes
*/
/***********************
****
****
***
****
****
***
****
****
***
****
***/
FILE
*cfpopen(command,
type)
char
*command,
*type;
{
char
arg[maxshellargs][bufsiz
e];
int
i,
argc,
pd[];
char
**argv;
pid_t
pid;
FILE
*pp
=
NULL;
if
((*type
!=
'r'
&&
*type
!=
'w')
||
(type[]
!=
'\0'))
{
errno
=
EINVAL;
return
NULL;
}
if
(CHILD
==
NULL)
/*
first
time
*/
{
if
((CHILD
=
calloc(MAXFD,sizeof(pid_t)
))
==
NULL)
{
return
NULL;
}
}
if
(pipe(pd)
<
0)
/*
Create
a
pair
of
descriptors
to
this
process
*/
{
return
NULL;
}
if
((pid
=
fork())
==
-)

Chapter
	:
C
programming

{
return
NULL;
}
if
(pid
==
0)
{
switch
(*type)
{
case
'r':
close(pd[0]);
/*
Don't
need
output
from
parent
*/
if
(pd[]
!=
)
{
dup(pd[],);
/*
Attach
pp=pd[]
to
our
stdout
*/
dup(pd[],);
/*
Merge
stdout/stderr
*/
close(pd[]);
}
break;
case
'w':
close(pd[]);
if
(pd[0]
!=
0)
{
dup(pd[0],0);
close(pd[0]);
}
}
for
(i
=
0;
i
<
MAXFD;
i++)
{
if
(CHILD[i]
>
0)
{
close(CHILD[i]);
}
argc
=
SplitCommand(command,arg)
;
argv
=
(char
**)
malloc((argc+)*sizeof(cha
r
*));
if
(argv
==
NULL)
{
FatalError("Out
of
memory");
}
for
(i
=
0;
i
<
argc;
i++)
{


The
unix
programming
en
vironmen
t
argv[i]
=
arg[i];
}
argv[i]
=
(char
*)
NULL;
if
(execv(arg[0],argv)
==
-)
{
sprintf(OUTPUT,"Couldn't
run
%s",arg[0]);
CfLog(cferror,OUTPUT,"exe
cv")
;
}
_exit();
}
}
else
{
switch
(*type)
{
case
'r':
close(pd[]);
if
((pp
=
fdopen(pd[0],type))
==
NULL)
{
return
NULL;
}
break;
case
'w':
close(pd[0]);
if
((pp
=
fdopen(pd[],type))
==
NULL)
{
return
NULL;
}
}
CHILD[fileno(pp)]
=
pid;
return
pp;
}
}
/***********************
****
****
***
****
****
***
****
****
***
****
***/
cfpclose(pp)
FILE
*pp;

Chapter
	:
C
programming
	
{
int
fd,
status;
pid_t
pid;
Debug("cfpclose(pp)\n");
if
(CHILD
==
NULL)
/*
popen
hasn't
been
called
*/
{
return
-;
}
fd
=
fileno(pp);
if
((pid
=
CHILD[fd])
==
0)
{
return
-;
}
CHILD[fd]
=
0;
if
(fclose(pp)
==
EOF)
{
return
-;
}
Debug("cfpopen
-
Waiting
for
process
%d\n",pid);
#ifdef
HAVE_WAITPID
while(waitpid(pid,&statu
s,0)
<
0)
{
if
(errno
!=
EINTR)
{
return
-;
}
}
return
status;
#else
if
(wait(&status)
!=
pid)
{
return
-;
}
else
{
if
(WIFSIGNALED(status))
{

0
The
unix
programming
en
vironmen
t
return
-;
}
if
(!
WIFEXITED(status))
{
return
-;
}
return
(WEXITSTATUS(status));
}
#endif
}
/***********************
****
****
***
****
****
***
****
****
***
****
****
***
/
/*
Command
exec
aids
*/
/***********************
****
****
***
****
****
***
****
****
***
****
****
***
/
SplitCommand(comm,arg)
char
*comm,
arg[maxshellargs][bufsi
ze];
{
char
*sp;
int
i
=
0,
j;
char
buff[bufsize];
for
(sp
=
comm;
sp
<
comm+strlen(comm);
sp++)
{
bzero(buff,bufsize);
if
(i
>=
maxshellargs-)
{
CfLog(cferror,"Too
many
arguments
in
embedded
script","");
FatalError("Use
a
wrapper");
}
while
(*sp
==
'
'
||
*sp
==
'\t')
{
sp++;
}
switch
(*sp)
{
case
'\0':
return(i-);
case
'\"':
sscanf
(++sp,"%[^\"]",arg[i]);
break;
case
'\'':
sscanf
(++sp,"%[^\']",arg[i]);
break;
case
'`':
sscanf
(++sp,"%[^`]",arg[i]);

Chapter
	:
C
programming

break;
default:
sscanf
(sp,"%s",arg[i]);
break;
}
sp
+=
strlen(arg[i]);
i++;
}
return
(i);
}
	.
T
raps
and
signals
Pro
cesses
can
receiv
e
signals
from
the
UNIX
k
ernel
at
an
y
time.
Some
of
these
signals
terminate
the
execution
of
the
program.
This
can
cause
problems
if
the
program
is
in
the
middle
of
critical
activit
y
suc
h
as
writing
to
a
le.
F
or
that
reason
w
e
can
trap
signals
and
pro
vide
our
o
wn
routine
for
handling
them
in
a
sp
ecial
w
a
y
.
A
signal
handler
is
made
b
y
calling
the
function
`signal()'
for
eac
h
signal
and
b
y
sp
ecifying
a
p
oin
ter
to
a
function
whic
h
will
b
e
called
in
the
ev
en
t
of
a
signal.
F
or
example:
main
()
{
int
HandleSignal();
signal(SIGTERM,HandleSig
nal)
;
}
HandleSignal()
{
/*
Tidy
up
and
exit
cleanly
*/
exit(0);
}
`SIGTERM'
is
the
usual
signal
sen
t
b
y
the
command
`kill'.
There
are
man
y
other
signals
whic
h
can
b
e
sen
t
to
programs.
Here
is
list.
Y
ou
ha
v
e
to
decide
for
y
ourself
whether
or
not
y
ou
w
an
t
to
pro
vide
y
our
o
wn
signal
handling
function.
T
o
ignore
a
signal,
y
ou
write
signal(SIGt
yp
e,SIG_IGN);
T
o
remo
v
e
a
signal
handler
and
re-activ
ate
a
signal,
y
ou
write
signal(SIGt
yp
e,SIG_DFL);


The
unix
programming
en
vironmen
t
	.
Regular
expressions
A
regular
expression
is
a
pattern
for
matc
hing
strings
of
text.
W
e
ha
v
e
met
regular
expressions
earlier
in
connection
with
the
shell
and
P
erl.
Naturally
these
earlier
encoun
ters
ha
v
e
their
ro
ots
in
C
functions
for
handling
expressions.
A
regular
expression
is
used
b
y
rst
`compiling'
it
in
to
a
con
v
enien
t
data
structure.
Then
a
matc
hing
function
is
used
to
compare
the
expression
with
a
test
string.
In
this
example
program
w
e
sho
w
ho
w
a
regular
expression
t
yp
ed
in
as
an
argumen
t
to
the
program
is
found
within
strings
of
input
en
tered
on
the
k
eyb
oard.
#include
<stdio.h>
#include
<regex.h>
main
(argc,argv)
int
argc;
char
**argv;
{
char
buffer[0];
regex_t
rx;
regmatch_t
match;
size_t
nmatch
=
;
if
(regcomp(&rx,
argv[],
REG_EXTENDED)
!=
0)
{
perror("regcomp");
return;
}
while
(!feof(stdin))
{
fgets(buffer,0,stdin)
;
if
(regexec(&rx,buffer,,&ma
tch
,0)
==
0)
{
printf("Matched:(%s)
at
%d
to
%d",buffer,match.rm_so,m
atch
.rm
_eo)
;
}
}
regfree(&rx);
}
Here
is
an
example
of
its
use.
The
output
of
the
program
is
in
italics
%
a.out
xyz
this
is
a
string

Chapter
	:
C
programming

another
string
an
xyz
string
Matche
d:
(an
xyz
string
)
at

to

another
xyz
zyxxyz
string
Matche
d:
(another
xyz
xyz
string
)
at

to

%
a.out
'xyz|abc'
This
is
a
string
An
abc
string
Matche
d:
(A
n
ab
c
string
)
at

to

Or
an
xyz
string
Matche
d:
(Or
an
xyz
string
)
at

to
	
If
y
ou
don't
w
an
t
the
matc
h
data
set
&pm
to
NULL.
T
o
get
an
exact
matc
h
rather
than
a
substring
c
hec
k
that
the
b
ounds
are
0
and
strlen(argv[])-.
	.
DES
encryption
Encryption
with
the
SSLea
y
library
,
compile
with
command
gcc
crypto.c
-I/usr/local/ssl/include
-L/usr/local/ssl/lib
-lcrypto
Example
of
normal
triple
DES
encryption
whic
h
w
orks
only
on
an
-b
yte
buer:
/***********************
****
****
***
****
****
***
****
****
***
****
****
***
****
****
**/
/*
*/
/*
File:
crypto.c
*/
/*
*/
/*
Compile
with:
gcc
program.c
-lcrypto
(SSLeay)
*/
/*
*/
/***********************
****
****
***
****
****
***
****
****
***
****
****
***
****
****
**/
#include
<stdio.h>
#include
<des.h>
#define
bufsize
0
/*
Note
how
this
truncates
to

characters
*/
main
()
{
char
in[bufsize],out[bufsize],
bac
k[bu
fsiz
e];
des_cblock
key,key,key,seed
=
{0xFE,0xDC,0xBA,0x	,0x,
0x
,0x
,0
x0}
;
des_key_schedule
ks,ks,ks;


The
unix
programming
en
vironmen
t
strcpy(in,"







	
a
b
c
d
e
f
g
h
i
j
k");
des_random_seed(seed);
des_random_key(key);
des_random_key(key);
des_random_key(key);
des_set_key((C_Block
*)key,ks);
des_set_key((C_Block
*)key,ks);
des_set_key((C_Block
*)key,ks);
des_ecb_encrypt((C_Bloc
k
*)in,(C_Block
*)out,ks,ks,ks,DES_ENC
RYP
T);
printf("Encrypted
[%s]
into
[%s]\n",in,out);
des_ecb_encrypt((C_Bloc
k
*)out,(C_Block
*)back,ks,ks,ks,DES_D
ECR
YPT)
;
printf("and
back
to..
[%s]\n",back);
}
T
riple
DES,
c
haining
mo
de,
for
longer
strings
(whic
h
m
ust
b
e
a
m
ultiple
of

b
ytes):
/***********************
****
****
***
****
****
***
****
****
***
****
****
***
****
****
**/
/*
*/
/*
File:
crypto.c
*/
/*
*/
/*
Compile
with:
gcc
program.c
-lcrypto
(SSLeay)
*/
/*
*/
/***********************
****
****
***
****
****
***
****
****
***
****
****
***
****
****
**/
#include
<stdio.h>
#include
<des.h>
#define
bufsize
0
/*
This
can
be
used
on
arbitrary
length
buffers
*/
main
()
{
char
in[bufsize],out[bufsize],
bac
k[bu
fsiz
e],
work
vec[
buf
size
];
des_cblock
key,key,key,seed
=
{0xFE,0xDC,0xBA,0x	,0x,
0x
,0x
,0
x0}
;
des_key_schedule
ks,ks,ks;
strcpy(in,"







	
a
b
c
d
e
f
g
h
i
j
k
l
m
n
o
p
q
r
s
t
u
v
w
x
y
z");
des_random_seed(seed);
des_random_key(key);

Chapter
	:
C
programming

des_random_key(key);
des_random_key(key);
des_set_key((C_Block
*)key,ks);
des_set_key((C_Block
*)key,ks);
des_set_key((C_Block
*)key,ks);
/*
This
work
vector
can
be
intialized
t
anything
...*/
memset(workvec,0,bufsize
);
des_ede_cbc_encrypt((C_
Bloc
k
*)in,(C_Block
*)out,(long)strlen(in),
ks,ks,ks,(C_Block
*)workvec,DES_ENCRYPT);
printf("Encypted
[%s]
into
[something]\n",in);
/*
..
but
this
must
be
initialized
the
same
as
above
*/
memset(workvec,0,bufsize
);
/*
Note
that
the
length
is
the
original
length,
not
strlen(out)
*/
des_ede_cbc_encrypt((C_
Bloc
k
*)out,(C_Block
*)back,(long)strlen(in)
,
ks,ks,ks,(C_Block
*)workvec,DES_DECRYPT);
printf("and
back
to..
[%s]\n",back);
}
	.
Device
con
trol:
io
ctl
The
C
function
`ioctl'
(I/O
con
trol)
is
used
to
send
sp
ecial
con
trol
commands
to
devices
lik
e
the
disk
and
the
net
w
ork
in
terface.
The
syn
tax
of
the
function
is
int
ioctl(fd,
request,
arg)
int
fd,
request;
long
arg;
The
rst
parameter
is
normally
as
device
handle
or
so
c
k
et
descriptor.
The
second
is
a
con
trol
parameter.
Lists
of
v
alid
con
trol
parameters
are
normally
dened
in
the
system
`include'
les
for
a
particular
device.
They
are
device
and
system
dep
enden
t
so
y
ou
need
a
lo
cal
man
ual
and
som
detectiv
e
w
ork
to
nd
out
what
they
are.
The
nal
parameter
is
a
p
oin
ter
to
a
v
ariable
whic
h
receiv
es
return
data
from
the
device.
`ioctl'
commands
are
device
sp
ecic,
b
y
their
nature.
The
commands
for
the
ethernet
in
terface
device
are
only
partially
standardized,
for
example.
W
e
could
read
the
ethernet
device
(whic
h
is
called
`le0'
on
a
Sun
w
orkstation),
using
the
follo
wing
command:


The
unix
programming
en
vironmen
t
#
include
<sys/socket.h>
/*
Typical
includes
for
internet
*/
#
include
<sys/ioctl.h>
#
include
<net/if.h>
#
include
<netinet/in.h>
#
include
<arpa/inet.h>
#
include
<netdb.h>
#
include
<sys/protosw.h>
#
include
<net/route.h>
struct
ifreq
IFR;
int
sk;
struct
sockaddr_in
sin;
strcpy(IFR.ifr_name,"le0
");
IFR.ifr_addr.sa_family
=
AF_INET;
if
((sk
=
socket(AF_INET,SOCK_DGRAM
,IPP
ROTO
_IP
))
==
-)
{
perror("socket");
exit();
}
if
(ioctl(sk,SIOCGIFFLAGS,
(caddr_t)
&IFR)
==
-)
{
perror
("ioctl");
exit();
}
W
e
shall
not
go
in
to
the
further
details
of
`ioctl',
but
simply
note
its
role
in
system
programming.
	.
Database
example
(Berk
eley
db)
DBT
key,value;
DB
*dbp;
DBC
*dbcp;
db_recno_t
recno;
if
((errno
=
db_open(CHECKSUMDB,DB_BTRE
E,
DB_CREATE,
0,
NULL,
NULL,
&dbp))
!=
0)
{
sprintf(OUTPUT,"cfd:
couldn't
open
checksum
database
%s\n",CHECKSUMDB);
CfLog(cferror,OUTPUT,"db_
open
");
return
false;
}
bzero(&value,sizeof(valu
e));
bzero(&key,sizeof(key));

Chapter
	:
C
programming

key.data
=
filename;
key.size
=
strlen(filename)+;
value.data
=
dbvalue;
value.size
=
sizeof(dbvalue);
if
((errno
=
dbp->del(dbp,NULL,&key,0))
!=
0)
{
CfLog(cferror,"","db_stor
e");
}
key.data
=
filename;
key.size
=
strlen(filename)+;
if
((errno
=
dbp->put(dbp,NULL,&key,&va
lue,
0))
!=
0)
{
CfLog(cferror,"put
failed","db->put");
}
if
((errno
=
dbp->get(dbp,NULL,&key,&va
lue,
0))
==
0)
{
/*
Not
found
...
*/
return;
}
dbp->close(dbp,0);
	.
T
ext
parsing
to
ols:
`lex'
and
`yacc'
This
se
ction
is
a
taster
only.
Y
ou
only
ne
e
d
to
know
what
lex
and
yac
c
ar
e,
not
how
they
work.
`lex'
and
`yacc'
are
t
w
o
to
ols
for
the
C
programmer
who
wishes
to
mak
e
a
text
parser.
A
text
parser
is
a
program
whic
h
reads
a
text
le
and
in
terprets
the
sym
b
ols
in
it.
Ev
ery
programming
language
m
ust
include
a
text
parser,
for
instance.
The
`yacc'
(y
et
another
compiler
compiler)
program
generates
C
co
de
whic
h
parses
a
textle,
giv
en
a
description
of
the
syn
tax
rules
for
the
le.
In
other
w
ords,
w
e
dene
the
logical
structure
of
the
text
le,
according
to
the
w
a
y
w
e
wish
to
in
terpret
it
and
giv
e
the
rules
to
`yacc'.
`yacc'
pro
duces
C
co
de
from
this
whic
h
do
es
the
job.
`lex'
is
a
`lexer'.
It
is
normally
used
together
with
`yacc'.
`lex'
tokenizes
or
iden
ties
sym
b
ols
in
a
le.
What
that
means
is
that
it
reads
in
a
le
and
matc
hes
typ
es
of
string
in
the
le
whic
h
are
dened
in
terms
of
regular
expressions
b
y
the
programmer,
and
returns
sym
b
olic
v
alues
for
those
strings.
Although
`lex'
can
b
e
used
b
y
indep
enden
tly
of
`yacc',
it
is
normally
used
to
iden
tify
the
dieren
t
typ
es
of
string
whic
h
dene
the
syn
tax
of
a
le.
F
or
example,
supp
ose
`yacc'
w
as
parsing
a
C
program.
On
the
b
eginning
of
a
line,
it
migh
t
exp
ect
to
nd
either
a
v
ariable
name
or
a
prepro
cessor
sym
b
ol.
A
v
ariable
name
is
just
a
string
consisting
of
c
haracters
from
the
set
`0-	a-Z_',
whereas
a
prepro
cessor
command
alw
a
ys
starts
with
the


The
unix
programming
en
vironmen
t
c
haracter
`#'.
`yacc'
passes
con
trol
to
`lex'
whic
h
reads
the
le
and
matc
hes
the
rst
ob
ject
on
the
line.
If
it
nds
a
v
ariable,
it
returns
to
`yacc'
a
token
whic
h
is
a
n
um
b
er
or
v
alue
corresp
onding
to
`v
ariable'.
Similarly
,
if
it
nds
a
prepro
cessor
command,
it
returns
a
tok
en
for
that.
If
it
do
esn't
matc
h
either
t
yp
e
it
returns
something
else
and
`yacc'
signals
a
syn
tax
error.
Here
is
a
`yacc'
le
whic
h
parses
a
le
consisting
of
lines
of
the
form
a+b,
where
$a$
and
$b$
are
n
um
b
ers
{
an
y
other
syn
tax
is
incorrect.
W
e
could
ha
v
e
used
this
later
in
the
example
program
for
the
clien
t-serv
er
example,
See
Section
0.
[So
c
k
ets],
page
.
Y
ou
can
learn
more
ab
out
lex
and
y
acc
in
"L
ex
and
Y
ac
c",
J.
L
evine,
T.
Mason
and
D.
Br
own,
O'R
eil
ly
and
Asso
c.
%{
/***********************
****
****
***
****
****
***
****
****
***
****
****
***
/
/*
*/
/*
PARSER
for
a
+
b
protocol
*/
/*
*/
/*
The
section
between
the
single
%'s
gets
copied
verbatim
into
*/
/*
the
resulting
C
code
yacc
generates
--
including
this
comment!
*/
/*
*/
/***********************
****
****
***
****
****
***
****
****
***
****
****
***
/
#include
<stdio.h>
extern
char
*yytext;
%}
%token
NUMBER
PLUS
%%
specification:
{
yyerror("Warning:
invalid
statement");}
|
statement;
statement:
NUMBER
PLUS
NUMBER;
The
lexer
to
go
with
this
parser
generates
the
tok
ens
NUMBER
and
PLUS
used
b
y
`yacc':
%{
/***********************
****
****
***
****
****
***
****
****
***
****
****
***
/
/*
*/
/*
LEXER
for
a
+
b
protocol
*/
/*
*/
/*
Returns
token
types
NUMBER
and
PLUS
to
yacc,
one
at
a
time
*/
/*
*/
/***********************
****
****
***
****
****
***
****
****
***
****
****
***
/
#include
"y.tab.h"
/*
yacc
produces
this
--
need
this
line!
*/

Chapter
	:
C
programming
	
%}
number
[0-	]+
plus
[+]
%%
number
{
return
NUMBER;
}
plus
{
return
PLUS;
}
.
{
return
yytext[0];
}
%%
/*
EOF
*/
The
main
program
whic
h
uses
`yacc'
and
`lex'
lo
oks
lik
e
this:
extern
FILE
*yyin;
main
()
{
if
((yyin
=
fopen("My_Input_File","
r"))
==
NULL)
/*
Open
file
*/
{
printf("Can't
open
file\n");
exit
();
}
while
(!feof(yyin))
{
yyparse();
}
fclose
(yyin);
}

0
The
unix
programming
en
vironmen
t
	.
Exercises
.
W
rite
a
daemon
program
with
a
signal
handler
whic
h
mak
es
a
log
of
the
hea
viest
(maxim
um
cpu)
pro
cess
running,
ev
ery
v
e
min
utes.
The
program
should
exit
if
the
log
le
b
ecomes
greater
than
-kb
ytes.
.
Rewrite
in
C
the
p
erl
program
whic
h
lists
all
the
les
in
the
curren
t
directory
con
taining
a
certain
string.
.
W
rite
a
v
ersion
of
`more'
whic
h
prin
ts
con
trol
c
haracters
safely
.
See
the
`cat
-e'
com-
mand.
.
W
rite
a
Mak
ele
to
create
a
shared
library
from
a
n
um
b
er
of
ob
ject
les.

Chapter
0:
Net
w
ork
Programming

0
Net
w
ork
Programming
Clien
t-serv
er
comm
unication
is
the
basis
of
mo
dern
op
erating
system
tec
hnology
.
The
Unix
so
c
k
et
mec
hanism
mak
es
stream-based
comm
unication
virtually
transparen
t.
0.
So
c
k
et
streams
Analogous
to
lestreams
are
so
ckets
or
TCP/IP
network
c
onne
ctions.
A
so
c
k
et
is
a
t
w
o-
w
a
y
(read/write)
pseudo-le
no
de.
An
op
en
so
c
k
et
stream
is
lik
e
an
op
en
le-descriptor.
Berk
eley
so
c
k
ets
are
part
of
the
standard
C
library
.
There
are
t
w
o
main
kinds
of
so
c
k
et:
TCP/IP
so
c
k
ets
and
Unix
domain
so
c
k
ets.
Unix
so
c
k
ets
can
b
e
used
to
pro
vide
lo
cal
in
terpro
cess
comm
unication
using
a
lestream
com-
m
unication
proto
col.
TCP/IP
so
c
k
ets
op
en
le
descriptors
across
the
net
w
ork.
A
TCP/IP
so
c
k
et
is
a
le
stream
asso
ciated
with
an
IP
address
and
a
p
ort
n
um
b
er.
W
e
write
to
a
so
c
k
et
descriptor
just
as
with
a
le
descriptor,
either
with
write()
or
using
send().
When
sending
binary
data
o
v
er
a
net
w
ork
w
e
ha
v
e
to
b
e
careful
ab
out
mac
hine
lev
el
represen
tations
of
data.
Op
erating
systems
(actually
the
hardw
are
they
run
on)
fall
in
to
t
w
o
categories
kno
wn
as
big
endian
and
little
endian.
The
names
refer
to
the
byte-or
der
of
n
umerical
represen
tations.
The
names
indicate
ho
w
large
in
tegers
(whic
h
require
sa
y

bits
or
more)
are
stored
in
memory
.
Little
endian
systems
store
the
least
signican
t
b
yte
rst,
while
big
endian
systems
store
the
most
signican
t
b
yte
rst.
F
or
example,
the
represen
tation
of
the
n
um
b
er
,,
has
either
of
these
forms.
-------------------------
----
----
--
Big
|

|

|

|

|
-------------------------
----
----
--
-------------------------
----
----
--
Little
|

|

|

|

|
-------------------------
----
----
--
Ob
viously
if
w
e
are
transferring
data
from
one
host
to
another,
b
oth
hosts
ha
v
e
to
agree
on
the
data
represen
tation
otherwise
there
w
ould
b
e
disastrous
consequences.
This
means
that
there
has
to
b
e
a
common
standard
of
network
byte
or
dering.
F
or
example,
Solaris
(SP
AR
C
hardw
are)
uses
net
w
ork
b
yte
ordering
(big
endian),
while
GNU/Lin
ux
(In
tel
hardw
are)
uses
the
opp
osite
(little
endian).
This
means
that
In
tel
systems
ha
v
e
to
con
v
ert
the
format
ev
ery
time
something
is
transmitted
o
v
er
the
net
w
ork.
Unix
systems
pro
vide
generic
functions
for
con
v
erting
b
et
w
een
host-b
yteorder
and
net
w
ork-b
yteorder
for
small
and
long
in
teger
data:
htonl,
htons,
ntohl,
ntohs
Here
w
e
list
t
w
o
example
programs
whic
h
sho
w
ho
w
to
mak
e
a
clien
t-serv
er
pair.
The
serv
er
en
ters
a
lo
op,
and
listens
for
connections
from
an
y
clien
ts
(the
generic
address
`INADDR_ANY'
is
a
wildcard
for
an
y
address
on
the
curren
t
lo
cal
net
w
ork
segmen
t).
The
clien
t
program
sends
requests
to
the
serv
er
as
a
proto
col
in
the
form
of
a
string
of
the
t
yp
e
`a
+
b'.
Normally


The
unix
programming
en
vironmen
t
`a'
and
`b'
are
n
um
b
ers,
in
whic
h
case
the
serv
er
returns
their
sum
to
the
clien
t.
If
the
message
has
the
sp
ecial
form
`halt
+
*',
where
the
star
is
arbitrary
,
then
the
serv
er
sh
uts
do
wn.
An
y
other
form
of
message
results
in
an
error,
whic
h
the
serv
er
signals
to
the
clien
t.
The
basic
structure
of
the
clien
t-serv
er
comp
onen
ts
in
terms
of
system
calls
is
this:
Client:
socket()
Create
a
so
c
k
et
connect()
Con
tact
a
serv
er
so
c
k
et
(IP
+
p
ort)
while
(?)
{
send()
Send
to
serv
er
recv()
Receiv
e
from
serv
er
}
Server:
socket()
Create
a
so
c
k
et
bind()
Asso
ciates
the
so
c
k
et
with
a
xed
address
listen()
Create
a
listen
queue
while()
{
reply=accept()
Accept
a
connection
request
recv()
Receiv
e
from
clien
t
send()
Send
to
clien
t
}
/***********************
****
****
***
****
****
***
****
****
***
****
****
***
***/
/*
*/
/*
The
client
part
of
a
client-server
pair.
This
simply
takes
two
*/
/*
numbers
and
adds
them
together,
returning
the
result
to
the
client
*/
/*
*/
/*
Compiled
with:
*/
/*
cc
server.c
*/
/*
*/
/*
User
types:
*/
/*

+

*/
/*
a
+
b
*/
/*
halt
+
server
*/
/***********************
****
****
***
****
****
***
****
****
***
****
****
***
***/
#include
<stdio.h>
#include
<sys/types.h>
#include
<sys/socket.h>
#include
<netinet/in.h>
#include
<netdb.h>

Chapter
0:
Net
w
ork
Programming

#define
PORT
	000
/*
Arbitrary
non-reserved
port
*/
#define
HOST
"nexus.iu.hioslo.no"
#define
bufsize
0
/***********************
****
****
***
****
****
***
****
****
***
****
****
***
***/
/*
Main
*/
/***********************
****
****
***
****
****
***
****
****
***
****
****
***
***/
main
(argc,argv)
int
argc;
char
*argv[];
{
struct
sockaddr_in
cin;
struct
hostent
*hp;
char
buffer[bufsize];
int
sd;
if
(argc
!=
)
{
printf("syntax:
client
a
+
b\n");
exit();
}
if
((hp
=
gethostbyname(HOST))
==
NULL)
{
perror("gethostbyname:
");
exit();
}
memset(&cin,0,sizeof(cin
));
/*
Another
way
to
zero
memory
*/
cin.sin_family
=
AF_INET;
cin.sin_addr.s_addr
=
((struct
in_addr
*)(hp->h_addr))->s_addr;
cin.sin_port
=
htons(PORT);
printf("Trying
to
connect
to
%s
=
%s\n",HOST,inet_ntoa(ci
n.si
n_ad
dr)
);
if
((sd
=
socket(AF_INET,SOCK_STREA
M,0)
)
==
-)
{
perror("socket");
exit();
}
if
(connect(sd,&cin,sizeof(c
in))
==
-)
{
perror("connect");


The
unix
programming
en
vironmen
t
exit();
}
sprintf(buffer,"%s
+
%s",argv[],argv[]);
if
(send(sd,buffer,strlen(bu
ffer
),0
)
==
-)
{
perror
("send");
exit();
}
if
(recv(sd,buffer,bufsize,0
)
==
-)
{
perror("recv");
exit
();
}
printf
("Server
responded
with
%s\n",buffer);
close
(sd);
unlink("./socket");
}
/***********************
****
****
***
****
****
***
****
****
***
****
****
***
***/
/*
*/
/*
The
server
part
of
a
client-server
pair.
This
simply
takes
two
*/
/*
numbers
and
adds
them
together,
returning
the
result
to
the
client
*/
/*
*/
/*
Compiled
with:
*/
/*
cc
server.c
*/
/*
*/
/***********************
****
****
***
****
****
***
****
****
***
****
****
***
***/
#include
<stdio.h>
#include
<sys/types.h>
#include
<sys/socket.h>
#include
<netinet/in.h>
#include
<netdb.h>
#define
PORT
	000
#define
bufsize
0
#define
queuesize

#define
true

#define
false
0
/***********************
****
****
***
****
****
***
****
****
***
****
****
***
***/
/*
Main
*/
/***********************
****
****
***
****
****
***
****
****
***
****
****
***
***/

Chapter
0:
Net
w
ork
Programming

main
()
{
struct
sockaddr_in
cin;
struct
sockaddr_in
sin;
struct
hostent
*hp;
char
buffer[bufsize];
int
sd,
sd_client,
addrlen;
memset(&sin,0,sizeof(sin
));
/*
Another
way
to
zero
memory
*/
sin.sin_family
=
AF_INET;
sin.sin_addr.s_addr
=
INADDR_ANY;
/*
Broadcast
address
*/
sin.sin_port
=
htons(PORT);
if
((sd
=
socket(AF_INET,SOCK_STREA
M,0)
)
==
-)
{
perror("socket");
exit();
}
if
(bind(sd,&sin,sizeof(sin)
)
==
-)
/*
Must
have
this
on
server
*/
{
perror("bind");
exit();
}
if
(listen(sd,queuesize)
==
-)
{
perror("listen");
exit();
}
while
(true)
{
if
((sd_client
=
accept(sd,&cin,&addrlen)
)
==
-)
{
perror("accept");
exit();
}
if
(recv(sd_client,buffer,siz
eof
(buf
fer)
,0)
==
-)
{
perror("recv");
exit();
}
if
(!DoService(buffer))


The
unix
programming
en
vironmen
t
{
break;
}
if
(send(sd_client,buffer,str
len
(buf
fer)
,0)
==
-)
{
perror("send");
exit();
}
close
(sd_client);
}
close
(sd);
printf("Server
closing
down...\n");
}
/***********************
****
****
***
****
****
***
****
****
***
****
**/
DoService(buffer)
char
*buffer;
/*
This
is
the
protocol
section.
Here
we
must
*/
/*
check
that
the
incoming
data
are
sensible
*/
{
int
a=0,b=0;
printf("Received:
%s\n",buffer);
sscanf(buffer,"%d
+
%d\n",&a,&b);
if
(a
>
0
&&
b>
0)
{
sprintf(buffer,"%d
+
%d
=
%d",a,b,a+b);
return
true;
}
else
{
if
(strncmp("halt",buffer,)
==
0)
{
sprintf(buffer,"Server
closing
down!");
return
false;
}
else
{
sprintf(buffer,"Invalid
protocol");
return
true;
}

Chapter
0:
Net
w
ork
Programming

}
}
In
the
example
w
e
use
`streams'
to
implemen
t
a
t
ypical
input/output
b
eha
viour
for
C.
A
stream
in
terface
is
a
so-called
reliable
proto
col.
There
are
other
kinds
of
so
c
k
ets
to
o,
called
unr
e
aliable,
or
UDP
so
c
k
ets.
F
eatures
to
notice
on
the
serv
er
are
that
w
e
m
ust
bind
to
a
sp
ecic
address.
The
clien
t
is
alw
a
ys
implicitly
b
ound
to
an
address
since
a
so
c
k
et
connection
alw
a
ys
originates
from
the
mac
hine
on
whic
h
the
clien
t
is
running.
On
the
serv
er
ho
w
ev
er
w
e
w
an
t
to
kno
w
whic
h
addresses
w
e
shall
b
e
receiving
requests
from.
In
the
ab
o
v
e
example
w
e
use
the
generic
wildcard
address
`INADDR_ANY'
whic
h
means
that
an
y
host
can
connect
to
the
serv
er.
Had
w
e
b
een
more
sp
ecic,
w
e
could
ha
v
e
limited
comm
unication
to
t
w
o
mac
hines
only
.
By
calling
`listen()'
w
e
set
up
a
queue
for
incoming
connections.
Rather
than
forking
a
separate
pro
cess
to
handle
eac
h
request
w
e
set
up
a
queue
of
a
certain
depth.
If
w
e
exceed
this
depth
then
new
clien
ts
rt
ying
to
connect
will
b
e
refused
connection.
The
`accept'
call
is
the
mec
hanism
whic
h
extracts
a
`reply
handle'
from
the
so
c
k
et.
Using
the
handle
obtained
from
this
call
w
e
can
reply
to
the
clien
t
without
ha
ving
to
op
en
a
sp
ecial
so
c
k
et
explicitly
.
An
impro
v
ed
serv
er
side
connection
can
b
e
setup,
reading
the
service
name
from
`/etc/services'
and
setting
reusable
so
c
k
et
options
to
a
v
oid
busy
signals,
lik
e
this:
struct
sockaddr_in
cin,
sin;
struct
servent
*server;
int
sd,
addrlen
=
sizeof(cin);
int
portnumber,
yes=;
if
((server
=
getservbyname(service-name,"tcp"))
==
NULL)
{
CfLog(cferror,"Couldn't
get
cfengine
service","getservbyname")
;
exit
();
}
bzero(&cin,sizeof(cin));
/*
Service
returns
network
byte
order
*/
sin.sin_port
=
(unsigned
short)(server->s_port);
sin.sin_addr.s_addr
=
INADDR_ANY;
sin.sin_family
=
AF_INET;
if
((sd
=
socket(AF_INET,SOCK_STREAM
,0))
==
-)
{
CfLog(cferror,"Couldn't
open
socket","socket");
exit
();
}
if
(setsockopt
(sd,
SOL_SOCKET,
SO_REUSEADDR,


The
unix
programming
en
vironmen
t
(char
*)
&yes,
sizeof
(int))
==
-)
{
CfLog(cferror,"Couldn't
set
socket
options","sockopt");
exit
();
}
if
(bind(sd,(struct
sockaddr
*)&sin,sizeof(sin))
==
-)
{
}
/*
etc
*/
0.
Multithreading
a
serv
er
All
the
argumen
ts
m
ust
b
e
collected
in
to
a
struct,
since
only
one
argumen
t
p
oin
ter
can
b
e
sen
t
to
the
pthread
functions.
#include
<pthread.h>
SpawnCfGetFile(args)
struct
cfd_thread_arg
*args;
{
pthread_t
tid;
void
*CfGetFile();
pthread_attr_init(&PTHRE
ADDE
FAUL
TS)
;
pthread_attr_setdetachst
ate(
&PTH
REA
DDEF
AULT
S,P
THRE
AD_C
REA
TE_D
ETAC
HED
);
if
(pthread_create(&tid,&PTH
READ
DEF
AULT
S,Cf
Get
File
,arg
s)
!=
0)
{
CfLog(cferror,"pthread_cr
eate
failed","create");
CfGetFile(args);
}
pthread_attr_destroy(&PT
HREA
DDEF
AUL
TS);
}
/***********************
****
****
***
****
****
***
****
****
***
****
***/
void
*CfGetFile(args)
struct
cfd_thread_arg
*args;
{
pthread_mutex_t
mutex;

Chapter
0:
Net
w
ork
Programming
	
if
(pthread_mutex_lock(&mute
x)
!=
0)
{
CfLog(cferror,"pthread_mu
tex_
loc
k
failed","pthread_mutex_l
ock"
);
free(args->replyfile);
/*
from
strdup
in
each
thread
*/
DeleteConn(args->connect)
;
free((char
*)args);
return
NULL;
}
ACTIVE_THREADS++;
/*
Global
variable
*/
if
(pthread_mutex_unlock(&mu
tex)
!=
0)
{
CfLog(cferror,"pthread_mu
tex_
unl
ock
failed","unlock");
}
/*
send
data
*/
if
(pthread_mutex_lock(&mute
x)
!=
0)
{
CfLog(cferror,"pthread_mu
tex_
loc
k
failed","pthread_mutex_l
ock"
);
return;
}
ACTIVE_THREADS--;
if
(pthread_mutex_unlock(&mu
tex)
!=
0)
{
CfLog(cferror,"pthread_mu
tex_
unl
ock
failed","unlock");
}
#endif
return
NULL;
}
0.
System
databases
The
C
library
calls
whic
h
query
the
databases
are,
amongst
others,
getpwnam
get
passw
ord
data
b
y
name
getpwuid
get
passw
ord
data
b
y
uid
getgrnam
get
group
data
b
y
name
gethostent
get
en
try
in
hosts
database
getnetgrent
get
en
try
in
netgroups
database
getservbyname
get
serviv
e
b
y
name
getservbyport
get
service
b
y
p
ort

0
The
unix
programming
en
vironmen
t
get
protobyname
get
proto
col
b
y
name
F
or
a
complete
list
and
ho
w
to
use
these,
see
the
UNIX
man
ual.
The
follo
wing
example
sho
ws
ho
w
to
read
the
passw
ord
le
of
the
system.
The
functions
used
here
can
b
e
used
regardless
of
whether
the
net
w
ork
information
service
(NIS)
is
in
use.
The
data
are
returned
in
a
structure
whic
h
is
dened
in
`/usr/include/pwd.h'.
/***********************
****
****
***
****
****
***
****
****
***
****
****
**/
/*
*/
/*
Read
the
passwd
file
by
name
and
sequentially
*/
/*
*/
/***********************
****
****
***
****
****
***
****
****
***
****
****
**/
#include
<unistd.h>
#include
<pwd.h>
main
()
{
uid_t
uid;
struct
passwd
*pw;
uid
=
getuid();
pw
=
getpwuid(uid);
printf
("Your
login
name
is
%s\n",pw->pw_name);
printf
("Now
here
comes
the
whole
file!\n\n");
setpwent();
while
(getpwent())
{
printf
("%s:%s:%s\n",pw->pw_name
,pw-
>pw_
gec
os,p
w->p
w_d
ir);
}
endpwent();
}
0.
DNS
-
The
Domain
Name
Service
The
second
net
w
ork
database
service
is
that
whic
h
con
v
erts
host
and
domain
names
in
to
IP
n
um
b
ers
and
vice
v
ersa.
This
is
the
domain
name
service,
usually
implemen
ted
b
y
the
BIND
(Berk
eley
In
ternet
Name
Domain)
soft
w
are.
The
information
here
concerns
v
ersion
.	
of
this
soft
w
are.

Chapter
0:
Net
w
ork
Programming

0..
gethostb
yname()
This
is
p
erhaps
the
most
imp
ortan
t
function
form
hostname
lo
okup.
`gethostbyname()'
gets
its
information
either
from
les,
NIS
or
DNS.
Its
b
eha
viour
is
congured
b
y
the
les
men
tioned
ab
o
v
e,
See
Section
0.
[DNS],
page
0.
It
is
used
to
lo
ok
up
the
IP
address
of
a
named
host
(including
domain
name
if
DNS
is
used).
On
the
congurable
systems
describ
ed
ab
o
v
e,
the
full
list
of
serv
ers
is
queried
un
til
a
reply
is
obtained.
The
order
in
whic
h
the
dieren
t
services
are
queried
is
imp
ortan
t
here
since
DNS
returns
a
ful
ly
qualie
d
name
(host
name
plus
domain
name)
whereas
NIS
and
the
`/etc/hosts'
le
database
return
only
a
hostname.
gethostb
yname
returns
data
in
the
form
of
a
p
oin
ter
to
a
static
data
structure.
The
syn
tax
is
#include
<netdb.h>
struct
hostent
*hp;
hp
=
gethostbyname("myhost.d
omai
n.c
ount
ry")
The
resulting
structure
v
aries
on
dieren
t
implemen
tations
of
UNIX,
but
the
`old
BSD
standard'
is
of
the
form:
struct
hostent
{
char
*h_name;
/*
official
name
of
host
*/
char
**h_aliases;
/*
alias
list
*/
int
h_addrtype;
/*
host
address
type
*/
int
h_length;
/*
length
of
address
*/
char
**h_addr_list;
/*
list
of
addresses
from
name
server
*/
};
#define
h_addr
h_addr_list[0]
/*
address,
for
backward
compatiblity
*/
The
structure
con
tains
a
list
of
addresses
and
or
aliases
from
the
nameserv
er.
The
in
teresting
quan
tit
y
is
usually
extracted
b
y
means
of
the
macro
`h_addr'
whcih
giv
es
the
rst
v
alue
in
the
address
list,
though
ocially
one
should
examine
the
whole
list
no
w.
This
v
alue
is
a
p
oin
ter
whic
h
can
b
e
con
v
erted
in
to
a
text
form
b
y
the
follo
wing
hideous
t
yp
e
transformation:
#include
<sys/types.h>
#include
<sys/socket.h>
#include
<netinet/in.h>
struct
sockaddr_in
sin;
cin.sin_addr.s_addr
=
((struct
in_addr
*)(hp->h_addr))->s_addr;
printf("IP
address
=
%s\n",inet_ntoa(cin.sin_a
ddr)
);


The
unix
programming
en
vironmen
t
See
the
clien
t
program
in
the
rst
section
of
this
c
hapter
for
an
example
of
its
use.
0.
C
supp
ort
for
NFS
The
supp
ort
for
NFS
moun
ting
in
the
standard
C
library
is
through
t
w
o
sources.
NFS
is
based
on
the
Sun's
RPC
system,
so
the
basic
calls
are
only
instances
of
standard
RPC
proto
cols.
The
C
functions
in
the
standard
input/output
library
can
b
e
used
to
access
NFS
lesys-
tems.
Since
NFS
imitates
the
UNIX
lesystem
as
closely
as
p
ossible,
NFS
lesystems
can
b
e
moun
ted
in
exactly
the
same
w
a
y
as
ordinary
lesystems.
Unfortunately
,
the
C
functions
whic
h
p
erform
the
moun
t
op
eration
in
UNIX
and
depressingly
non-standard.
They
dier
on
almost
ev
ery
implemen
tation
of
UNIX.
The
basic
function
whic
h
moun
ts
a
lesystem,
in
`mount'
(see
man
()
mount).
The
moun
t
table
is
stored
in
a
le
/etc/mtab
on
BSD
systems
(again
the
name
v
aries
wildly
from
UNIX
to
UNIX,
mn
ttab
on
HPUX
for
instance).
The
le
/etc/rmtab
on
an
NFS
serv
er
con
tains
a
list
of
remote-moun
ted
lesystems
whic
h
are
moun
ted
b
y
remote
clien
ts.
C
functions
exist
whic
h
can
read
the
lesystem
tables
and
place
the
resulting
data
in
C
struct
t
yp
es.
Alas,
these
struct
den
tions
are
also
quite
dieren
t
on
dieren
t
systems.
See
`/usr/include/sys/mount.h',
so
the
user
wishing
to
write
system-indep
enden
t
co
de
is
confounded
at
the
lo
w
est
lev
el.
0.
Exercises
.
Use
`gethostbyname()'
to
mak
e
a
simple
program
lik
e
`nslookup'
whic
h
giv
es
the
in
ternet
address
of
a
named
host.
.
Mo
dify
the
clien
t
serv
er
example
ab
o
v
e
to
mak
e
a
`remote
ls'
command
called
`rls'.
Y
ou
should
b
e
able
to
use
the
syn
tax
rls
(options)
hostname:/path/to/file

App
endix
A:
Summary
of
programming
idioms.

App
endix
A
Summary
of
programming
idioms.
T
rue
and
false
#
C
shell
True
-
non-zero/non-empty
value
False
-
zero
or
null
string
#
Bourne
shell
True
-
0
returned
by
shell
command
False
-
non-zero
returned
by
shell
command
(
Note
that
"test"
converts
from
C
shell
style
to
Bourne
shell)
#
Perl
True
-
non-zero/non-empty
value
False
-
zero
or
null
string
/*
C
*/
True
-
non
zero
integer
False
-
zero
integer
Input
fr
om
tty
#
C
shell
$<
#
Bourne
shell
line
read
#
Perl
<STDIN>
/*
C
*/
scanf
R
e
dir
e
ction
of
I/O
#
C
shell
command
>
file


The
unix
programming
en
vironmen
t
command
>&
file
command
>>
file
command
|
command
#
Bourne
shell
command
>
file
command
>
file
>&
command
>>
file
command
|
command
#
Perl
open
(HANDLE,">file")
open
(HANDLE,">file
>&")
open
(HANDLE,">>file")
open
(HANDLE,"command
|")
open
(HANDLE,"|
command")
/*
C
*/
fopen
("file","w");
printf(..)
fopen
("file","w");
printf(..);
fprintf(stderr,..)
fopen
("file","a");
printf(..)
popen
("command
","r")
popen
("command
","w")
L
o
ops
and
tests
/*
C
*/
Shell
foreach
end
if
then
else
endif
while
end
switch
case
breaksw
endsw
repeat
#
Bourne
shell
while
do
done
if
then
else
fi
until
do
done
case
in
esac
for
in
do
done
#
Perl
while
if
then
else
for
unless
else
foreach
until
do
while
do
until

App
endix
A:
Summary
of
programming
idioms.

/*
C
*/
while
if
then
else
do
while
switch
case
for
A
r
guments
fr
om
c
ommand
line
#
C
shell
$argv[]
$#argv
#
Bourne
Shell
$,
$,
$...
$*
$#
#
Perl
$ARGV[]
$#ARGV
/*
C
*/
char
argv[][]
int
argc
A
rithmetic
#
C
shell
a
=
$b
+
$c
#
Bourne
shell
a
=
`expr
$b
+
$c`
#
Perl
$a
=
$b
+
$c;
/*
C
*/
a
=
b
+
c;
Numeric
al
c
omp
arison
#
C
shell
if
(
$x
==
$y
)
then
endif


The
unix
programming
en
vironmen
t
#
Bourne
shell
if
[
$x
-eq
$y
];
then
fi
#
Perl
if
(
$x
==
$y
)
{
}
/*
C
*/
if
(
x
==
y
)
{
}
String
c
omp
arison
#
C
shell
if
(
$x
==
$y
)
then
endif
#
Bourne
shell
if
[
$x
=
$y
];
then
fi
#
Perl
if
(
$x
eq
$y
)
then
{
}
/*
C
*/
if
(strcmp(x,y)
==
0)
{
}
Op
ening
a
le
#
C
shell,
Bourne
shell
-
cannot
be
done
(pipes
only)
#
Perl
open
(READ_HANDLE,"filename"
);

App
endix
A:
Summary
of
programming
idioms.

open
(WRITE_HANDLE,">
filename");
open
(APPEND_HANDLE,">>
filename");
/*
C
*/
FILE
*fp;
fp
=
fopen
("file","r");
fp
=
fopen
("file","w");
fp
=
fopen
("file","a");
Op
ening
a
dir
e
ctory
#
C
shell
foreach
dir
(
directory
/*
)
...
end
#
Bourne
shell
for
dir
in
directory
/*
;
do
...
done
#
Perl
opendir
(HANDLE,"directory
")
||
die;
while
($entry
=
readdir(HANDLE))
{
}
closedir(HANDLE);
#
C
#include
<dirent.h>
DIR
*dirh;
struct
dirent
*dirp;
if
((dirh
=
opendir(name))
==
NULL)
{
perror("opendir")
exit();
}
for
(dirp
=
readdir(dirh);
dirp
!=
NULL;
dirp
=
readdir(dirh))


The
unix
programming
en
vironmen
t
{
...
/*
dirp->d_name
points
to
child
*/
}
closedir(dirh);
T
esting
le
typ
es
#
C
shell
if
(
-f
file
)
#
plain
file
if
(
-d
file
)
#
directory
#
Bourne
shell
if
[
-f
file
]
#
plain
file
if
[
-d
file
]
#
directory
#
Perl
if
(
-f
file
)
#
plain
file
if
(
-d
file
)
#
directory
if
(
-l
file
)
#
symbolic
link
/*
C
*/
#include
<sys/stat.h>
struct
stat
statvar;
stat("file",
&statvar);
if
(S_ISREG(statvar.mode))
/*
plain
file
*/
if
(S_ISDIR(statvar.mode))
/*
directory
*/
lstat("file",
&statvar);
if
(S_ISLNK(statvar.mode))
/*
symbolic
link
*/

Command
and
V
ariable
Index
	
Command
and
V
ariable
Index
!
`!'
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`!'
not
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`!='
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`!='
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`!~'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

$
$
in
regular
expressions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

$?
in
make
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

$@
in
make
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

$<
in
make
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

&
&
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`&'
AND
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
'
'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

(
()
in
csh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

*
*
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

*
in
regular
expressions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

-
`-'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`--'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
--help
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`-='
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`-a'
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

-d
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`-d'
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

-e
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`-eq'
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

-f
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`-f'
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`-g'
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`-ge'
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`-gt'
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

-h
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`-le'
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`-lt'
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`-ne'
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`-o'
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

-r
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`-r'
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`-s'
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`-u'
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

-w
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`-w'
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`-x'
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

-z
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

-z
in
perl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
in
regular
expressions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.cshrc
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.profile
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.xsession
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

/
`/bin'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`/bin/csh'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`/bin/sh'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`/dev'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`/devices'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`/etc'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`/export'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`/home'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`/sbin'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`/sys'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`/users'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`/usr'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`/usr/bin'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`/usr/local'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`/var'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`/var/adm'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`/vr/spool'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.


0
The
unix
programming
en
vironmen
t
:
:e
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

:h
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

:r
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

:t
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

=
`='
assignment
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`='
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`=='
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
,

`=='
equal
to
(compare)
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`=~'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

?
?
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

?
in
regular
expressions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

[
[]
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

[]
in
regular
expressions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`
`
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`...`
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

``
shell
construction
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

|
|
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`|'
OR
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`||'
logical
OR
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
"
"
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

+
`+'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
+
in
regular
expressions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`+='
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`++'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
>
>
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`>'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`>'
greater
than
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`>='
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

>>
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`>>'
shift
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
^
^
in
regular
expressions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`^'
XOR
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
<
<
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`<'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`<'
less
than
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`<='
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

<<
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
,

`<<'
shift
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
A
apropos
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`ar'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`archie'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
argc
in
C
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

argv
in
C
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`awk'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

B
breaksw
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

C
`cat'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`cc'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`CC'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`chgrp'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`chmod'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`chown'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`cmdtool'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

continue
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`cp'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

crypt()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

h
CTRL-A
i
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.


Command
and
V
ariable
Index

h
CTRL-C
i
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

h
CTRL-D
i
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

h
CTRL-E
i
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

h
CTRL-L
i
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

h
CTRL-Z
i
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`cut'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

D
`date'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`dbx'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`dc'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
ddd
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`df'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

DISPLAY
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`domainname'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`du'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`dvips'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
E
`ed'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`elm'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`emacs'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

env
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`eq'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

F
`find'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`finger'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`fmgr'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`fnews'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
foreach
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

fork()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`ftp'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

G
`g++'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`gcc'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`gdb'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
getenv()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`ghostscript'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`ghostview'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
H
HOME
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

HOST
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`hostname'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
I
ioctl()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`irc'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`ispell'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
K
keys
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

L
`latex'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`ld'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
LD_LIBRARY_PATH
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`LD_LIBRARY_PATH'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`less'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

ln
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

ln
-s
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`locate'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`lp'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`lpq'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`lpstat'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`ls'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

M
man
-k
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`mesg'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

mkdir
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`mkdir'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`more'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`mv'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

N
`ncftp'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`netstat'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`nslookup'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	


The
unix
programming
en
vironmen
t
P
`paste'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

PATH
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`pico'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`pine'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`ping'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
PRINTER
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`PRINTER'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`ps'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
R
rand()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`rcpinfo'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`rename'
in
perl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
repeat
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`rlogin'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`rmail'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`rmdir'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`rsh'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

S
`screen'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`sed'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

set
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`setroot'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`shelltool'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`showmount'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
stderr
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
stdin
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
stdout
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
T
`talk'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`tcl'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`telnet'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

TERM
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`tex'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`texinfo'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`textedit'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`touch'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

U
`uname'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`unlink'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

unset
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`users'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

V
`vi'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`vmstat'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`vmunix'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

W
`w'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`whereis'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

which
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

while
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`who'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`write'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

X
`xarchie'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`xcalc'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`xdvi'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`xedit'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`xemacs'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`xfig'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`xmosaic'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`xpaint'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`xrn'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`xterm'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`xv'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`xxgdb'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Z
`zmail'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.


Concept
Index

Concept
Index
#
`#!program'
sequence
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
,

$
$
in
regular
expressions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`$<'
op
erator
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

'
h
'
i
and
h
"
i
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

(
()
and
subshells
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

()
op
erators
to
mak
e
arra
y
in
csh
.
.
.
.
.
.
.
.
.
.
.
.
.

*
*
in
regular
expressions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

-
`-I'
option
to
cc
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`-L'
option
to
cc
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
directory
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
,

.
in
regular
expressions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
directory
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
,

`.cshrc'
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`.login'
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`.profile'
set
up
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.xsession
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

/
`/etc/group'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

?
?
in
regular
expressions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

[
`[]'
for
test
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

[]
in
regular
expressions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`
h
`
i
sym
b
ol
and
em
b
edded
shells
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

``..`'
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

|
`|'
sym
b
ol
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
,

+
+
in
regular
expressions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

^
^
in
regular
expressions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

<
`<>'
lehandle
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.


`>'
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.


`>'
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`>&'
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

A
`a.out'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

accept()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Access
bits
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Access
bits,
o
ctal
form
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Access
bits,
text
form
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Access
con
trol
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Access
con
trol
lists
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Access
righ
ts
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Access
to
les
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

A
CLs
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

ANSI
C
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.



The
unix
programming
en
vironmen
t
App
ending
to
a
le
with
`>>'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

aprop
os
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`ar'
arc
hiv
er
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`archie'
program
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Argumen
t
v
ector
in
csh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Argumen
t
v
ector
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
,

Argumen
ts,
command
line
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`argv'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Arithem
tic
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Arithem
tic
op
erations
in
csh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Arra
ys
(asso
ciated)
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Arra
ys
(normal)
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Arra
ys
and
`split'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Arra
ys
in
csh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Arra
ys
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Asso
ciated
arra
ys,
iteration
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`at'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

A
T&T
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`awk'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`awk'
pattern
extractor
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

B
`Background
picture'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Bac
kground
pro
cess
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
,

Bac
kw
ards
quotes
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

bash
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0,

`batch'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Berk
eley
In
ternet
Name
Domain
(BIND)
.
.
.
.
.
0
`bg'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Big
endian
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

BIND
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
bind()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Bourne
shell
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0,

Break
k
ey
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`breaksw'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Bro
wsing
through
a
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

BSD
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Build
soft
w
are
script
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Built
in
commands
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Byte
order
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

C
C
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

C
library
calls
and
shell
commands
.
.
.
.
.
.
.
.
.
.
.
.
0
C
programming
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

C
shell
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
C
shell
setup
les
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

C,
role
in
unix
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
C++
sux
rules
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Calculator,
shell
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Calculator,
X
windo
ws
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`cat'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`cc'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`CC'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
CGI
proto
col
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Changing
le
mo
de
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`chgrp'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

chgrp
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`chmod'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

chmod
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`chop'
command
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`chown'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

chown
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`close'
command
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

closedir
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`cmdtool'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Command
completion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Command
history
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Command
in
terpreter
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Command
line
argumen
ts
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Command
line
argumen
ts
in
C
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Command
line
argumen
ts
in
p
erl
.
.
.
.
.
.
.
.
.
.
,

Command
line
argumen
ts
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Command
path
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Command
windo
w
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Commands
as
les
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Commands
path
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Comparison
op
erators
in
csh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Compiler
script
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Compilers
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Compiling
h
uge
programs
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Compiling
programs
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

connect()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`continue'
in
csh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Con
tin
uing
long
lines
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Cop
y
of
output
to
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

core
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`cp'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Creating
directories
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Creating
les
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`csh'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
csh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

h
CTRL-A
i
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

h
CTRL-C
i
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.


Concept
Index

h
CTRL-D
i
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

h
CTRL-D
i
and
EOF
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
h
CTRL-E
i
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

h
CTRL-L
i
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

h
CTRL-Z
i
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Curses
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`cut'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Cut
as
a
p
erl
script
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`cut'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

D
Database
maps
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Database
supp
ort
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	0
`date'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Date
stamp,
up
dating
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`dbx'
debugger
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Debugger
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Debugger
for
C
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Debugger
GUI
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Decisions
and
return
co
des
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.

delete
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Dep
endencies
in
Mak
eles
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`df'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`die'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Directories,
creating
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Directories,
deleting
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

diren
t
directory
in
terface
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Disk
usage.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

DISPLA
Y
v
ariable
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Displa
y
,
X
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

DNS
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`do..while'
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Domainname
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`domainname'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
DOS
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Dra
wing
program
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`du'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

dvi
to
p
ostscript
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
E
`ed'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

egrep
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`elm'
mailer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`emacs'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Em
b
edded
shell
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Encryption
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

End
of
le
h
CTRL-D
i
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
env
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

En
vironmen
t
v
ariables
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	,

En
vironmen
t
v
ariables
in
C
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

En
vironmen
t
v
ariables
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
,
	
En
vironmen
t,
unix
user
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
envp
in
C
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`eq'
and
`=='
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Error
messages
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Errors
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Executable,
making
programs
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Exiting
on
errors
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`EXPORT'
command
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Expressions,
regular
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

extern
v
ariables
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Extracting
lename
comp
onen
ts
.
.
.
.
.
.
.
.
.
.
.
.
.
.

F
`fg'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
File
access
p
ermission
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

File
handles
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

File
hierarc
h
y
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

File
mo
de,
c
hanging
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

File
protection
bits
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

File
transfer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

File
t
yp
e,
determining
in
C
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Filename
completion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Files
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Files,
iterating
o
v
er
lines
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`find'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
,

Finding
commands
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Finding
FTP
les
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`finger'
service
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`fmgr'
le
manager
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`fnews'
news
reader
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
F
or
lo
op
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

for
lo
op
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

for
lo
op
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

F
or
lo
ops
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

foreach
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

foreach
example
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

F
oreac
h
lo
op
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

foreach
lo
op
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

F
oreground
pro
cess
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

F
orking
new
pro
cesses
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
F
ormatting
text
in
a
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

F
orms
in
HTML
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0


The
unix
programming
en
vironmen
t
`ftp'
program
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

FTP
resources,
nding
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
F
ully
qualied
name
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

G
`g++'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`gcc'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`gdb'
debugger
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
getenv()
function
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

getgrnam()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
gethostbyname()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
,

gethostent()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
getnetgrent()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
getpwnam()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
getpwuid()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
getservbyname()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
getservbyport()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Getting
command
output
in
to
a
string
.
.
.
.
.
.
.
.

`ghostscript'
"GNU
p
ostscript"
in
terpreter
.
.
.
0
`ghostview'
p
ostscript
preview
er
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
gif
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Global
v
ariables
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Global
v
ariables
in
csh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Global
v
ariables
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Gran
ting
p
ermission
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

groups
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

H
Hard
links
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
,

Help
function
for
commands
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Hierarc
h
y
,
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`hostname'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Hyp
ertext
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
I
I/O
streams
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`if'
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

if..then..else
in
csh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

if..then..else..fi
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`IFS'
v
ariable
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
INADDR_ANY
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Include
le
searc
h
path
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Include
les
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Index
no
des
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Information
ab
out
le
prop
erties
.
.
.
.
.
.
.
.
.
.
.
.
.

init
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
ino
des
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Input
in
csh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Input
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Input
o
v
er
man
y
lines
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Inserting
a
command
in
to
a
string
.
.
.
.
.
.
.
.
.
.
.
.
.

In
ternet
rela
y
c
hat
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

In
ternet
resources
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
In
terpretation
of
v
alues
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

In
terrupt
handler
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

ioctl()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`IRC'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Iterating
o
v
er
les
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Iteration
o
v
er
arra
ys
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

J
Job
con
trol
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Job
n
um
b
ers
in
csh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Job,
mo
ving
to
bac
kground
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Jok
er
notation
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

jpg
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
jsh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

K
k
ernel
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Kernel
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Kernighan
and
Ritc
hie
C
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`kill'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
ksh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0,

L
`latex'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`ld'
loader/link
er
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`ld.so.cache'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`ldconfig'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`less'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

lex
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`lex'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Lexer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

lib
c
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

lib
curses
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

libm
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Library
path
for
C
loader
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Limitations
of
shell
programs
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Links
in
C
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.


Concept
Index

Links,
where
do
they
p
oin
t?
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

listen()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Little
endian
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

ln
-s
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Lo
cal
v
ariables
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Lo
cal
v
ariables
in
csh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Lo
cal
v
ariables
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Lo
cal
v
ariables
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`locate'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Logging
on
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Login
en
vironmen
t
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Login
evironmen
t
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Long
le
listing
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Long
lines,
con
tin
uing
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Lo
ops
and
list
separators
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Lo
ops
in
csh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Lo
ops
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`lp'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`lpq'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`lpr'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`lpstat'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

ls
-l
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`ls
command'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

lstat()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

M
MacIn
tosh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Macros
for
stat
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Mail
clien
ts
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

mak
e
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Mak
e
rules
for
C++
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Mak
e
soft
w
are
script
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Making
a
script
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Making
directories
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Making
scripts
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Masking
programs
executable
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Matc
hing
lenames
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Matc
hing
strings
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

mc
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Mercury
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`mesg'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Messages
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Mime
t
yp
es
in
W
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
mkdir
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`mkdir'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`more'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`mosaic'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Moun
ted
le
systems
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Mo
ving
a
job
to
the
bac
kground
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Mo
ving
les
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Multiple
C
les,
compiling
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Multiple
screens
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`mv'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

N
nc
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`ncftp'
program
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`netstat'
net
w
ork
statistics
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Net
w
ork
b
yte
order
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Net
w
ork
databases
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Net
w
ork
information
service
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Nev
er
do
in
unix
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

NFS
and
C
supp
ort
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

NIS
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
nob
o
dy
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

noclobber
o
v
erwrite
protection
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

noclobber
v
ariable
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`nslookup'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
O
`open'
command
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

opendir
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Op
ening
a
pip
e
in
C
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Op
erating
system
name
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Op
erators
in
csh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Output
to
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Output,
sending
to
a
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

P
P
ain
ting
program
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
P
anic
button
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

P
arameters
in
p
erl
functions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

P
arser
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

P
arts
of
a
lename
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`passwd'
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`paste'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

P
aste
as
a
p
erl
script
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`paste'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

path
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
path
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

PATH
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
P
attern
matc
hing
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	,
	


The
unix
programming
en
vironmen
t
P
attern
replacemen
t
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
PC
windo
ws
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

P
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

P
erl
v
ariables
and
t
yp
es
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

P
erl,
strings
and
scalar
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

P
erl,
truncating
strings
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

P
ermissions
on
les
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

P
ermissions,
determining
in
C
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`pico'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Picture
pro
cessing
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`pine'
mailer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Pip
e
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Pip
es
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Pip
es
in
C
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Piping
to
more
to
prev
en
t
scrolling
.
.
.
.
.
.
.
.
.
.
.
.

popen()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

POSIX
standard
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

P
ostscript
view
ers
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Prin
ter
queue
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Prin
ter
status
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`PRINTER'
v
ariable
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Prin
ting
a
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Prin
ting
m
ultiple
lines
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Pro
cedures
and
subroutines
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.

Pro
cess.
mo
ving
to
bac
kground
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Pro
cesses
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Prompt,
redening
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Protecting
les
from
o
v
erwrite
with
`>'
.
.
.
.
.
.
.
.

Protection
bits
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`ps'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
R
readdir
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

readlink()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

recv()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Redening
list
separator
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Redirecting
stdio
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Redirection
of
stdio
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Regular
expressions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Reliable
so
c
k
et
proto
col
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Renaming
les
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

repeat
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Result
of
a
command
in
to
a
string
.
.
.
.
.
.
.
.
.
.
.
.

Return
co
des
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`rlogin'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

rlogin
program
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`rm'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`rmail'
in
emacs
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`rmdir'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Role
of
C
in
unix
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Ro
ot
privileges
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

ro
ot
user
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

rp
cgen
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`rpcinfo'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`rsh'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

S
s-bit
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	,
0
Scalar
v
ariables
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

sc
heme
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`screen'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Screens
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Script
aliases
in
W
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Script,
making
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Scripts
in
sh,
making
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Searc
hing
and
replacing
in
p
erl
(example)
.
.
.
.
.
	
`sed'
as
a
p
erl
script
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`sed'
batc
h
editor
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`sed'
editor
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`sed',
searc
h
and
replace
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

send()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Sending
messages
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

set
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

setenv
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

setgid
bit
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Setting
the
prompt
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Setting
up
the
C
shell
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Setting
up
the
x
en
vironmen
t
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

setuid
bit
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
SetUID
scripts
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`sh'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Shared
libraries
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

shell
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
,
	
Shell
commands
and
C
library
calls
.
.
.
.
.
.
.
.
.
.
.
0
h
Shells,
v
arious
i
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`shelltool'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`shift'
and
arra
ys
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`shift'
and
arra
ys
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
shift
op
erator
on
strings
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`showmount'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Signal
handler
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.


Concept
Index
	
Single
and
double
quotes
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`sleep'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

socket()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

So
c
k
ets
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Soft
links
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`Sonar'
ping
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Sp
elling
c
hec
k
er
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`split'
and
arra
ys
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`split'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Splitting
C
in
to
man
y
les.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Splitting
output
to
sev
eral
les
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Standard
error
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Standard
I/O
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Standard
I/O
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Standard
I/O,
redirection
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Standard
input
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Standard
output
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Starting
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Starting
shell
jobs
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
stat()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Static
linking
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Statistics
ab
out
a
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Stic
ky
bit
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Strings
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`stty'
and
switc
hing
o
term
ec
ho
.
.
.
.
.
.
.
.
.
.
.
.

Subroutines
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Subshells
and
()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Sux
rules
in
Mak
eles
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

sup
eruser
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Susp
ending
a
job
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Sw
apping
text
strings
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

switch..case
in
csh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Sym
b
olic
links
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

System

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`System
details'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
System
iden
tit
y
and
`uname'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

System
name
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
System
V
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

T
t-bit
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
h
T
AB
i
completion
k
ey
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`talk'
service
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`TCL'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
TCP/IP
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

tcsh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0,

`tee'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

T
elet
yp
e
terminal
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

telnet
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`telnet'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

T
erminal
ec
ho
and
`stty'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

T
erminals
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`test'
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

test
programs
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
test,
don't
call
y
our
program
this
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
T
esting
les
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

T
esting
rep
onse
from
other
hosts.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
T
ests
and
conditions
in
csh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

T
ests
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`tex'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`texinfo'
system
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
T
ext
form
of
access
bits
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

T
ext
formatting
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`textedit'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

The
arguemen
t
v
ector
in
C
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

The
domain
name
service
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
ti
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Time
and
date
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Time
stamp,
up
dating
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Tk
library
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`touch'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

T
raps
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

T
runcating
strings
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

tt
y
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`type'
in
DOS
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

T
yp
es
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

U
umask
v
ariable
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`uname'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Undening
v
ariables
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

undelete
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
UNIX
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

UNIX
history
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`unless'
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`unlink'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

unset
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`until'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Up
arro
w
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Up
dating
le
time
stamp
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

User
database
supp
ort
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	0
User
en
vironmen
t
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`users'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.


0
The
unix
programming
en
vironmen
t
V
V
ariables,
global
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

V
ariables,
lo
cal
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`vi'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Viewing
a
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`vmstat'
virtual
memory
stats
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
W
`w'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`wait.h'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

W
aiting
for
c
hild
pro
cesses
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`whereis'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

whic
h
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

while
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`while'
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`while'
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
while
lo
op
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`who'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`whoami'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Wildcards
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	,

Windo
ws
on
PC
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

W
rapp
er
functions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
W
rapp
ers
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`write'
command
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

write
example
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

W
riting
a
script
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

WTERMSIG(status)
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

X
X
access
con
trol
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

X
displa
y
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
,

X
proto
col
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

X
windo
w
system
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

X
windo
ws
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

X
windo
ws
access
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

X
windo
ws
authen
tication
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

X-windo
ws
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
`xarchie'
clien
t
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
Xauthorit
y
mec
hanism
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`xedit'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`xemacs'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`xfig'
dra
wing
program
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
xhost
mec
hanism
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`xpaint'
program
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`xrn'
news
reader
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`xterm'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

xterm
program
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

`xv'
picture
pro
cessor
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`xxgdb'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Y
y
acc
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
`yacc'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
,

Z
`zmail'
clien
t
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

zsh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.


i
T
able
of
Con
ten
ts
F
orew
ord
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

W
elcome
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.


Ov
erview
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
What
is
unix?
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Fla
v
ours
of
unix
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Ho
w
to
use
this
reference
guide
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
NEVER-DO's
in
UNIX
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
What
y
ou
should
kno
w
b
efore
starting
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
..
One
library:
sev
eral
in
terfaces
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
..
Unix
commands
are
les
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
..
Kernel
and
Shell
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
..
The
role
of
C
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
..
Stdin,
stdout,
stderr
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
.
The
sup
eruser
(ro
ot)
and
nob
o
dy
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
The
le
hierarc
h
y
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Sym
b
olic
links
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.	
Hard
links
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.


Getting
started
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Logging
in
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Mouse
buttons
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
E-mail
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Simple
commands
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
T
ext
editing
and
w
ord
pro
cessing
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.


The
login
en
vironmen
t
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
.
Shells
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
..
Shell
commands
generally
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
..
En
vironmen
t
and
shell
v
ariables
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
Wildcards
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
Regular
expressions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
Nested
shell
commands
and
\
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
UNIX
command
o
v
erview
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
Imp
ortan
t
k
eys
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
Alternativ
e
shells
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
Windo
w
based
terminal
em
ulators
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
Remote
shells
and
logins
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
T
ext
editors
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
File
handling
commands
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
File
bro
wsing
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.


ii
The
unix
programming
en
vironmen
t
..
Ownership
and
gran
ting
access
p
ermission
.
.
.
.
.
.
.

..	
Extracting
from
and
rebuilding
les
.
.
.
.
.
.
.
.
.
.
.
.
.

..0
Lo
cating
les
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
Disk
usage.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
Sho
w
other
users
logged
on
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
Con
tacting
other
users
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
Mail
senders/readers
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
File
transfer
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
Compilers
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
..
Other
in
terpreted
languages
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
..
Pro
cesses
and
system
statistics
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
..	
System
iden
tit
y
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
..0
In
ternet
resources
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
..
T
ext
formatting
and
p
ostscript
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
..
Picture
editors
and
pro
cessors
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
..
Miscellaneous
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
.
T
erminals
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
The
X
windo
w
system
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
The
comp
onen
ts
of
the
X-windo
w
system
.
.
.
.
.
.
.
.

..
Ho
w
to
set
up
X
windo
ws
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
X
displa
ys
and
authorit
y
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Multiple
screens
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.


Files
and
access
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Protection
bits
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
c
hmo
d
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Umask
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
..
Making
programs
executable
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
..
c
ho
wn
and
c
hgrp
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
..
Making
a
group
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
.
s-bit
and
t-bit
(stic
ky
bit)
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0

C
shell
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.cshrc
and
.login
les
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Dening
v
ariables
with
set,
seten
v
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Arra
ys
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Pip
es
and
redirection
in
csh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
`tee'
and
`script'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Command
history
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Command/lename
completion
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Single
and
double
quotes
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.	
Job
con
trol,
break
k
ey
,
`fg',
`bg'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.	.
Unix
Pro
cesses
and
BSD
signals
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.	.
Child
Pro
cesses
and
zom
bies
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
.	.
C-shell
builtins:
`jobs',
`kill',
`fg',`bg',
break
k
ey
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
.0
Scripts
with
argumen
ts
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Sub-shells
()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.


iii
.
T
ests
and
conditions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
Switc
h
example:
congure
script
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Lo
ops
in
csh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Input
from
the
user
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Extracting
parts
of
a
pathname
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Arithmetic
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
.
Examples
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	

Bourne
shell
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.prole
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
V
ariables
and
exp
ort
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Stdin,
stdout
and
stderr
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Arithmetic
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Scripts
and
argumen
ts
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Return
co
des
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
T
ests
and
conditionals
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Input
from
the
user
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.	
Lo
ops
in
sh
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
.0
Pro
cedures
and
traps
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
setuid
and
setgid
scripts
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Summary:
Limitations
of
shell
programming
.
.
.
.
.
.
.
.
.
.
.
.

.
Exercises
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.


P
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Sed
and
a
wk,
cut
and
paste
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Program
structure
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
P
erl
v
ariables
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
Scalar
v
ariables
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
The
default
scalar
v
ariable.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
Arra
y
(v
ector)
v
ariables
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
Sp
ecial
arra
y
commands
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
Asso
ciated
arra
ys
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
..
Arra
y
example
program
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
.
Lo
ops
and
conditionals
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
The
for
lo
op
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
The
foreac
h
lo
op
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
Iterating
o
v
er
elemen
ts
in
arra
ys
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
Iterating
o
v
er
lines
in
a
le
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
Files
in
p
erl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
A
simple
p
erl
program
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
==
and
`eq'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
c
hop
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
P
erl
subroutines
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
die
-
exit
on
error
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
The
stat()
idiom
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.	
P
erl
example
programs
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.	.
The
passwd
program
and
`crypt()'
function
.
.
.
.
.

.	.
Example
with
`fork()'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	

iv
The
unix
programming
en
vironmen
t
.	.
Example
reading
databases
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	0
.0
P
attern
matc
hing
and
extraction
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
.
Searc
hing
and
replacing
text
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
.
Example:
con
v
ert
mail
to
WWW
pages
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
.
Generate
WWW
pages
automagically
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
.
Other
supp
orted
functions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
00
.
Summary
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
.
Exercises
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
.
Pro
ject
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0

WWW
and
CGI
programming
.
.
.
.
.
.
.
.
.
.
.
0
.
P
ermissions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
.
Proto
cols
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
.
HTML
co
ding
of
forms
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
.
P
erl
and
the
w
eb
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
..
In
terpreting
data
from
forms
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
..
A
complete
guestb
o
ok
example
in
p
erl
.
.
.
.
.
.
.
.
.
0	
.
PHP
and
the
w
eb
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
Em
b
edded
PHP
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

..
PHP
and
forms
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	
C
programming
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	.
Shell
or
C?
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	.
C
program
structure
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	..
The
form
of
a
C
program
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	..
Macros
and
declarations
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	..
Sev
eral
les
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	.
A
note
ab
out
UNIX
system
calls
and
standards
.
.
.
.
.
.
.
.
.
.

	.
Compiling:
`cc',
`ld'
and
`a.out'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	..
Libraries
and
`LD_LIBRARY_PATH'
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	..
Include
les
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	..
Shared
and
static
libraries
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	..
Kno
wing
ab
out
imp
ortan
t
paths:
directory
structure
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
	.
Mak
e
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
	..
Compiling
large
pro
jects
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
	..
Mak
eles
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	..
New
sux
rules
for
C++
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	.
The
argv,
argc
and
envp
param
ters
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	.
En
vironmen
t
v
ariables
in
C
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	.
Files
and
directories
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	..
op
endir,
readdir
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	..
stat()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	..
lstat
and
readlink
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	.	
stat()
test
macros
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	.	.
Example
ling
program
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
	.0
Pro
cess
con
trol,
fork(),
exec(),
popen()
and
system
.
.
0
	.
A
more
secure
popen()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.


v
	.
T
raps
and
signals
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	.
Regular
expressions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	.
DES
encryption
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	.
Device
con
trol:
io
ctl
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	.
Database
example
(Berk
eley
db)
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	.
T
ext
parsing
to
ols:
`lex'
and
`yacc'
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

	.
Exercises
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
0
Net
w
ork
Programming
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

0.
So
c
k
et
streams
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

0.
Multithreading
a
serv
er
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

0.
System
databases
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
0.
DNS
-
The
Domain
Name
Service
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
0..
gethostb
yname()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

0.
C
supp
ort
for
NFS
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

0.
Exercises
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

App
endix
A
Summary
of
programming
idioms.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

Command
and
V
ariable
Index
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
	
Concept
Index
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.


vi
The
unix
programming
en
vironmen
t

